<html>
<head><meta http-equiv="content-type" content="text/html;charset=utf-8">
<title>A Programming Language</title>
<link href="adoc.css" rel=stylesheet>
</head>

<body>

<br>

<table width=520 align=center><tr><td>

<table border=1 cellspacing=0 cellpadding=12 align=center>
<tr><td><br><br><br><img src="APLimg/title.jpg">
<br><br><br><br><br><br><br><br><br></td></tr>
</table>

<p align=center><br><i>To My Many Teachers</i>
<br><br><br>&nbsp;</p>



<a name="preface"></a>
<p><font size=+1>Preface</font></p>

<p>Applied mathematics is largely concerned with the design 
and analysis of explicit procedures for calculating the 
exact or approximate values of various functions. 
Such explicit procedures are called algorithms or <i>programs</i>. 
Because an effective notation for the description of programs 
exhibits considerable syntactic structure, it is called 
a <i>programming language</i>.</p>

<p>Much of applied mathematics, particularly the more recent 
computer-related areas which cut across the older disciplines, 
suffers from the lack of an adequate programming language. 
It is the central thesis of this book that the descriptive 
and analytic power of an adequate programming language 
amply repays the considerable effort required for its mastery. 
This thesis is developed by first presenting the entire language 
and then applying it in later chapters to several major topics.</p>

<p>The areas of application are chosen primarily for their
intrinsic interest and lack of previous treatment, but they are 
also designed to illustrate the universality and other facets 
of the language.  For example, the microprogramming
of Chapter 2 illustrates the divisibility of the language,
i.e., the ability to treat a restricted area using only a small
portion of the complete language.  Chapter 6 (Sorting) shows
its capacity to compass a relatively complex and detailed topic
in a short space.  Chapter 7 (The Logical Calculus) emphasizes
the formal manipulability of the language and its utility
in theoretical work.</p>

<p>The material was developed largely in a graduate course
given for several years at Harvard and in a later course
presented repeatedly at the IBM Systems Research Institute
in New York.  It should prove suitable for a two-semester
course at the senior or graduate level.  Although for certain
audiences an initial presentation of the entire language
may be appropriate, I have found it helpful to motivate
the development by presenting the minimum notation required
for a given topic, proceeding to its treatment (e.g.,
microprogramming), and then returning to further notation.
The 130-odd problems not only provide the necessary finger
exercises but also develop results of general interest.</p>

<p>Chapter 1 or some part of it is prerequisite to each of the 
remaining &ldquo;applications&rdquo; chapters, 
but the applications 
chapters are virtually independent of one another.
A complete appreciation of search techniques (Chapter 4)
does, however, require a knowledge of methods of
representation (Chapter 3).  The cross references which
do occur in the applications chapters are either
nonessential or are specific to a given figure, table,
or program.  The entire language presented in Chapter 1
is summarized for reference at the end of the book.</p>

<p>In any work spanning several years it is impossible to 
acknowledge adequately the many contributions made by others.  
Two major acknowledgments are in order:  
the first to Professor Howard Aiken, 
Director Emeritus of the Harvard Computation Laboratory, 
and the second to Dr. F.P. Brooks, Jr. now of IBM.</p>

<p>It was Professor Aiken who first guided me into this work and who 
provided support and encouragement in the early years when it mattered.
The unusually large contribution by Dr. Brooks arose as follows.
Several chapters of the present work were originally prepared for
inclusion in a joint work which eventually passed the bounds of
a single book and evolved into our joint <i>Automatic Data Processing</i>
and the present volume.  Before the split, several drafts of these
chapters had received careful review at the hands of Dr. Brooks,
reviews which contributed many valuable ideas on organization,
presentation, and direction of investigation, as well as numerous
specific suggestions.</p>

<p>The contributions of the 200-odd students 
who suffered through the development of the material 
must perforce be acknowledged collectively,
as must the contributions of many of my colleagues at the
Harvard Computation Laboratory.  
To Professor G.A. Salton and Dr. W.L. Eastman, 
I am indebted for careful reading of drafts
of various sections and for comments arising from their use of
some of the material in courses.  
Dr. Eastman, in particular,
exorcised many subtle errors from the sorting programs of Chapter 6.
To Professor A.G. Oettinger and his students I am indebted for many
helpful discussions arising out of his early use of the notation.
My debt to Professor R.L. Ashenhurst, now of the University of Chicago,
is apparent from the references to his early (and unfortunately
unpublished) work in sorting.</p>

<p>Of my colleagues at the IBM Research Center, Messrs. L.R. Johnson
and A.D. Falkoff, and Dr. H. Hellerman have, through their
own use of the notation, contributed many helpful suggestions.
I am particularly indebted to L.R. Johnson for many fruitful discussions 
on the applications of trees, and for his unfailing support.</p>

<p>On the technical side, I have enjoyed the assistance of
unusually competent typists and draughtsmen, chief among
them being Mrs. Arthur Aulenback, Mrs. Philip J. Seaward, Jr.,
Mrs. Paul Bushek, Miss J.L. Hegeman, and Messrs. William Minty
and Robert Burns.  Miss Jacquelin Sanborn provided much
early and continuing guidance in matters of style,
format, and typography.  I am indebted to my wife for
assistance in preparing the final draft.</p>

<table width=500>
<tr><td align=right>Kenneth E. Iverson</td></tr>
<tr><td><i>May, 1962</i></td></tr>
<tr><td><i>Mount Kisco, New York</i></td></tr>
</table>
<br><br>



<a name="1"></a>
<p><font size=+1>Chapter 1 &nbsp; The Language</font></p>

<a name="1.1"></a>
<p><b>1.1 Introduction</b></p>

<p>Applied mathematics is concerned
with the design and analysis of algorithms or <i>programs</i>.
The systematic treatment of complex algorithms 
requires a suitable <i>programming language</i>
for their description, 
and such a programming language should be
concise, precise, consistent over a wide area of application,
mnemonic, and economical of symbols;
it should exhibit clearly the constraints 
on the sequence in which operations are performed;
and it should permit the description
of a process to be independent 
of the particular representation chosen for the data.</p>

<p>Existing languages prove unsuitable
for a variety of reasons.
Computer coding specifies sequence constraints adequately
and is also comprehensive,
since the logical functions provided 
by the branch instructions can,
in principle, be employed to synthesize
any finite algorithm.
However, the set of basic operations provided is not,
in general, directly suited to the execution
of commonly needed processes,
and the numeric symbols used for variables
have little mnemonic value.
Moreover, the description provided by computer coding
depends directly on the particular representation
chosen for the data,
and it therefore cannot serve as a description
of the algorithm per se.</p>

<p>Ordinary English lacks both precision and conciseness.
The widely used 
<acronym title="Goldstine, H.H., and J. von Neumann (1947), 
“Planning and Coding of Problems for 
an Electronic Computing Instrument”, 
Report on the Mathematical and Logical Aspects 
of an Electronic Computing Instrument, 
Part II, vol. 1, Institute for Advanced Study, Princeton.">
Goldstine-von Neumann (1947)</acronym>
flowcharting provides the conciseness
necessary to an over-all view of the processes,
only at the cost of suppressing essential detail.
The so-called pseudo-English used
as a basis for certain automatic programming systems
suffers from the same defect.
Moreover, the potential mnemonic advantage
in substituting familiar English words and phrases
for less familiar but more compact mathematical symbols
fails to materialize because of the obvious
but unwonted precision required in their use.</p>

<p>Most of the concepts and operations needed
in a programming language have already been defined
and developed in one or another branch of mathematics.
Therefore, much use can and will be made 
of existing notations.
However, since most notations are specialized
to a narrow field of discourse,
a consistent unification must be provided.
For example, separate and conflicting notations
have been developed for the treatment of sets,
logical variables, vectors, matrices, and trees,
all of which may, in the broad universe of discourse
of data processing, occur in a single algorithm.
<br>&nbsp;</p>


<a name="1.2"></a>
<p><b>1.2 Programs</b></p>

<p>A <i>program statement</i> is the specification
of some quantity or quantities in terms 
of some finite operation upon specified operands.
Specification is symbolized by an arrow
directed toward the specified quantity.
thus &ldquo;<i>y</i> is specified 
by sin <i>x</i>&rdquo; is a statement denoted by</p>

<p>&nbsp; &nbsp; &nbsp; <i>y</i> &larr; sin <i>x</i>.</p>

<p>A set of statements together 
with a specified order of execution 
constitutes a <i>program</i>.
The program is <i>finite</i> if the number
of executions is finite.
The <i>results</i> of the program
are some subset of the quantities 
specified by the program.
The <i>sequence</i> or order of execution
will be defined by the order of listing
and otherwise by arrows connecting 
any statement to its successor.
A cyclic sequence of statements
is called a <i>loop</i>.</p>

<table>
<tr><td>&nbsp; &nbsp;</td>
 <td valign=bottom align=center><img src="APLimg/prog1x1.bmp"></td>
 <td><tt>&nbsp; &nbsp; &nbsp; &nbsp;</tt></td>
 <td valign=bottom align=center><img src="APLimg/prog1x2.bmp"></td></tr>
<tr><td>&nbsp;</td>
 <td align=center><b>Program 1.1&nbsp;</b> Finite Program</td>
 <td>&nbsp;</td>
 <td align=center><b>Program 1.2&nbsp;</b> Infinite Program</td></tr>
</table>

<p>Thus Program 1.1 is a program 
of two statements defining the result <i>v</i>
as the (approximate) area of a circle
of radius <i>x</i>,
whereas Program 1.2 is an infinite program
in which the quantity <i>z</i> is specified
as (2<i>y</i>)<sup><i>n</i></sup> 
on the <i>n</i>th execution 
of the two statement loop.
Statements will be numbered
on the left for reference.</p>

<p>A number of similar programs may be subsumed
under a single more general program as follows.
At certain <i>branch points</i> in the program
a finite number of alternative statements
are specified as possible successors.
One of these successors is chosen
according to criteria determined in the statement
or statements preceding the branch point.
These criteria are usually stated 
as a <i>comparison</i> or test 
of a specified relation 
between a specified pair of quantities.
A branch is denoted by a set of arrows
leading to each of the alternative successors,
with each arrow labeled by the comparison condition
under which the corresponding successor is chosen.
The quantities compared are separated 
by a colon in the statement at the branch point,
and a labeled branch is followed
if and only if the relation indicated
by the label holds 
when substituted for the colon.
The conditions on the branches
of a properly defined program 
must be disjoint and exhaustive.</p>

<p>Program 1.3 illustrates the use of a branch point.
Statement &alpha;5 is a comparison which determines
the branch to 
statements &beta;1, &delta;1, or &gamma;1,
according as 
<i>z</i> &gt; <i>n</i>, <i>z</i> = <i>n</i>,
or <i>z</i> &lt; <i>n</i>.
The program represents a crude by effective
process for determining <i>x</i> = <i>n</i><sup>2/3</sup>
for any positive cube <i>n</i>.</p>

<img src="APLimg/prog1x3.bmp">
<p align=center><b>Program 1.3&nbsp;</b> Program for <i>x</i> = <i>n</i><sup>2/3</sup></p>

<p>Program 1.4 shows the preceding program
reorganized into a compact linear array
and introduces two further conventions
on the labeling of branch points.
The listed successor of a branch statement
is selected if none of the labeled conditions is met.
Thus statement 6 follows statement 5
if neither of the arrows
(to exit or to statement 8) are followed,
i.e. if <i>z</i> &lt; <i>n</i>.
Moreover, any unlabeled arrow is always followed;
e.g., statement 7 is invariably followed
by statement 3, never by statement 8.</p>

<p>A program begins at a point indicated 
by an <i>entry arrow</i> (step 1) and ends
at a point indicated by an <i>exit arrow</i> (step 5).
There are two useful consequences 
of confining a program to the form
of a linear array:
the statements may be referred to by a unique
serial index (statement number),
and unnecessarily complex organization
of the program manifests itself
in crossing branch lines.
The importance of the latter characteristic
in developing clear and comprehensible programs
is not sufficiently appreciated.</p>

<table>
<tr><td>&nbsp; &nbsp;</td><td align=center><img src="APLimg/prog1x4.bmp"></td></tr>
<tr><td>&nbsp;</td><td align=center><b>Program 1.4&nbsp;</b> Linear arrangement of Program 1.3</td></tr>
</table>

&nbsp;<br>

<table>
<tr><td>&nbsp; &nbsp;</td><td align=center><img src="APLimg/prog1x5.bmp"></td></tr>
<tr><td>&nbsp;</td><td align=center><b>Program 1.5&nbsp;</b> Matrix multiplication</td></tr>
</table>

<p>A process which is repeated a number of times
is said to be <i>iterated</i>, and a process
(such as in Program 1.4) which includes 
one or more iterated subprocesses
is said to be <i>iterative</i>.
Program 1.5 shows an iterative process
for the matrix multiplication</p>

<p>&nbsp; &nbsp; &nbsp; <b><i>C</i></b> &larr; <b><i>A</i></b><b><i>B</i></b></p>

<p>defined in the usual way as</p>

<table>
<tr><td>&nbsp; &nbsp; &nbsp; </td><td>
<b><i>C</i></b><sub><i>j</i></sub><sup><i>i</i></sup> = <img align=middle src="APLimg/sigmamm.bmp"> 
<b><i>A</i></b><sub><i>k</i></sub><sup><i>i</i></sup> &times;
<b><i>B</i></b><sub><i>j</i></sub><sup><i>k</i></sup> ,
</td>
<td>&nbsp; &nbsp; &nbsp;</td><td>
<i>i</i> = 1,2, &#133;, <i>&mu;</i>(<b><i>A</i></b>),<br>
<i>j</i> = 1,2, &#133;, <i>&nu;</i>(<b><i>B</i></b>),
</td></tr>
</table>

<p>where the dimensions of an 
<nobr><i>m</i> &times; <i>n</i></nobr>
matrix <b><i>X</i></b> (of <i>m</i> rows and <i>n</i> columns)
is denoted by 
<nobr><i>&mu;</i>(<b><i>X</i></b>) &times; <i>&nu;</i>(<b><i>X</i></b>).</nobr></p>

<table><tr><td>&nbsp;</td><td>
<p><b>Program 1.5</b>. Steps 1-3 initialize the indices,
and the loop 5-7 continues to add successive products
to the partial sum until <i>k</i> reaches zero.
When this occurs, the process continues through step 8
to decrement <i>j</i> and to repeat the entire summation
for the new value of <i>j</i>,
providing that it is not zero.
If <i>j</i> is zero, the branch to step 10 decrements <i>i</i>
and the entire process over <i>j</i> and <i>k</i>
is repeated from <i>j</i> = <i>&nu;</i>(<b><i>B</i></b>),
providing that <i>i</i> is not zero.
If <i>i</i> is zero, the process is complete,
as indicated by the exit arrow.</p>
</td><td>&nbsp;</td></tr></table>

<p>In all examples used in this chapter,
emphasis will be placed on clarity of description
of the process,
and considerations of efficient execution by a computer
or class of computers will be subordinated.
These considerations can often be introduced later
by relatively routine modifications of the program.
For example, since the execution of a computer operation
involving an indexed variable is normally more costly
than the corresponding operation 
upon a nonindexed variable,
the substitution of a variable <i>s</i>
for the variable 
<b><i>C</i></b><sub><i>j</i></sub><sup><i>i</i></sup>
specified by statement 5 of Program 1.5
would accelerate the execution of the loop.
The variable <i>s</i> would be initialized
to zero before each entry to the loop
and would be used to specify
<b><i>C</i></b><sub><i>j</i></sub><sup><i>i</i></sup>
at each termination.</p>

<p>The practice of first setting an index
to its maximum value and then decrementing it
(e.g., the index <i>k</i> in Program 1.5)
permits the termination comparison 
to be made with zero.
Since zero often occurs in comparisons,
it is convenient to omit it.
Thus, if a variable stands alone at a branch point,
comparison with zero is implied.
Moreover, since a comparison on an index
frequently occurs immediately 
after it is modified,
a branch at the point of modification
will denote branching upon comparison
of the indicated index with zero,
the comparison occurring <i>after</i> modification.
Designing programs to execute decisions
immediately after modification
of the controlling variable results
in efficient execution as well as
notational elegance,
since the variable must be present 
in a central register for both operations.</p>

<p>Since the sequence of execution of statements
is indicated by connecting arrows
as well as by the order of listing,
the latter can be chosen arbitrarily.
This is illustrated by the functionally
identical Programs 1.3 and 1.4.
Certain principles of ordering may yield
advantages such as clarity or simplicity
of the pattern of connections.
Even though the advantages 
of a particular organizing principle 
are not particularly marked,
the uniformity resulting 
from its consistent application
will itself be a boon.
The scheme here adopted is called
the <i>method of leading decisions</i>:
the decision on each parameter
is placed as early in the program 
as practicable,
normally just before the operations
indexed by the parameter.
This arrangement groups at the head
of each iterative segment
the initialization, modification, 
and the termination test
of the controlling parameter.
Moreover, it tends to avoid program flaws
occasioned by unusual values 
of the argument.</p>

<table>
<tr><td>&nbsp; &nbsp;</td><td align=center><img src="APLimg/prog1x6.bmp"></td></tr>
<tr><td>&nbsp;</td><td align=center><b>Program 1.6&nbsp;</b> Matrix multiplication using leading decisions</td></tr>
</table>

<p>For example, Program 1.6
(which is a reorganization of Program 1.5)
behaves properly for matrices of dimension zero,
whereas Program 1.5 treats every matrix
as if it were of dimension one or greater.</p>

<p>Although the labeled arrow representation
of program branches provides a complete 
and graphic description,
it is deficient in the following respects:
(1) a routine translation to another language
(such as computer code) would require
the tracing of arrows, and 
(2) it does not permit programmed modification
of the branches.</p>

<p>The following alternative form 
of a branch statement will therefore
be used as well:</p>

<p>&nbsp; &nbsp; &nbsp; <i>x</i> : <i>y</i>,&nbsp;
<b><i>r</i></b> &rarr; <b><i>s</i></b>.</p>

<p>This denotes a branch to statement number <b><i>s</i></b><sub><i>i</i></sub>
of the program if the relation 
<i>x</i><b><i>r</i></b><sub><i>&nbsp;i&nbsp;</i></sub><i>y</i> holds.
The parameters <b><i>r</i></b> and <b><i>s</i></b>
may themselves be defined and redefined 
in other parts of the program.
The <i>null element</i> <tt>∘</tt> 
will be used to denote the relation
which complements the remaining
relations <b><i>r</i></b><sub><i>&nbsp;i</i></sub>;
in particular, (<tt>∘</tt>)&rarr;(<i>s</i>),
or simply &rarr;<i>s</i>,
will denote an unconditional branch 
to statement <i>s</i>.
Program 1.7 shows the use of these conventions
in a reformulation of Program 1.6.
More generally, two or more otherwise independent
programs may interact through a statement
in one program specifying a branch in a second.
The statement number occurring in the branch
must then be augmented by the name of the program
in which the branch is effected.
Thus the statement (<tt>∘</tt>)&nbsp;&rarr;&nbsp;Program&nbsp;2.24
executed in Program 1 causes a branch to step 24
to occur in Program 2.</p>

<table>
<tr><td>&nbsp; &nbsp;</td><td align=center><img src="APLimg/prog1x7.bmp"></td></tr>
<tr><td>&nbsp;</td><td align=center><b>Program 1.7&nbsp;</b> A reformulation of Program 1.6,<br>
using an algebraic statement of the branching</td></tr>
</table>

<p>One statement in a program can be modified
by another statement which changes certain
of its parameters, usually indices.
More general changes in statements can be effected
by considering the program itself
as a vector <b><i>p</i></b> whose components
are the individual, serially numbered statements.
All the operations to be defined on general vectors
can then be applied to the statements themselves.
For example, the <i>j</i>th statement can be
respecified by the <i>i</i>th 
through the occurrence of the statement 
<b><i>p</i></b><sub><i>j</i></sub>&nbsp;&larr;&nbsp;<b><i>p</i></b><sub><i>i</i></sub>.</p>

<p>The interchange of two quantities <i>y</i> and <i>x</i> 
(that is, <i>x</i> specifies <i>y</i> and 
the <i>original</i> value of <i>y</i> specifies <i>x</i>)
will be denoted by the statement <i>y</i> &harr; <i>x</i>.
<br>&nbsp;</p>



<a name="1.3"></a>
<p><b>1.3 Structure of the language</b></p>

<a name="1.3.1"></a>
<p><b>Conventions</b></p>

<p>The Summary of Notation
at the end of the book summarizes the notation
developed in this chapter.
Although intended primarily for reference,
it supplements the text in several ways.
It frequently provides a more concise
alternative definition 
of an operation discussed in the text,
and it also contains important 
but easily grasped extensions
not treated explicitly in the text.
By grouping the operations into related classes
it displays their family relationships.</p>

<p>A concise programming language must incorporate
families of operations whose members are related
in a systematic manner.
Each family will be denoted 
by a specific operation symbol,
and the particular member of the family
will be designated by an associated
<i>controlling parameter</i>
(scalar, vector, matrix, or tree)
which immediately precedes 
the main operation symbol.
The operand is placed immediately 
after the main operation symbol.
For example, the operation 
<i>k</i> <tt>↑</tt> <b><i>x</i></b>
(left rotation of <b><i>x</i></b> by <i>k</i> places)
may be viewed as the <i>k</i>th member
of the set of rotation operators 
denoted by the symbol <tt>↑</tt>.</p>

<p>Operations involving a single operand
and no controlling parameter
(such as 
<nobr><tt>⌊</tt><i>x</i><tt>&rfloor;</tt>,</nobr> 
or 
<nobr><tt>⌈</tt><i>x</i><tt>&rceil;</tt></nobr>)
will be denoted by a pair of operation symbols
which enclose the operand.
Operations involving two operands 
and a controlling parameter
(such as the mask operation 
<nobr>/<b><i>a</i></b>, <b><i>u</i></b>, <b><i>b</i></b>/</nobr>)
will be denoted by a pair of operation symbols
enclosing the entire set of variables,
and the controlling parameter will appear
between the two operands.
In these cases the operation symbols themselves
serve as grouping symbols.</p>

<p>In interpreting a compound operation
such as <i>k</i> <tt>↑</tt> (<i>j</i> <tt>↓</tt> <b><i>x</i></b>)
it is important to recognize that the operation symbol
and its associated controlling parameter
together represent an indivisible operation
and must not be separated.
It would, for example, be incorrect to assume that
<i>j</i> <tt>↑</tt> (<i>k</i> <tt>↓</tt> <b><i>x</i></b>)
were equivalent to 
<i>k</i> <tt>↑</tt> (<i>j</i> <tt>↓</tt> <b><i>x</i></b>),
although it can be shown that the complete operations
<i>j</i>&nbsp;<tt>↓</tt> and <i>k</i>&nbsp;<tt>↑</tt>
do commute, that is
<i>k</i>&nbsp;<tt>↑</tt>&nbsp;(<i>j</i>&nbsp;<tt>↓</tt>&nbsp;<b><i>x</i></b>) =
<i>j</i>&nbsp;<tt>↓</tt>&nbsp;(<i>k</i>&nbsp;<tt>↑</tt>&nbsp;<b><i>x</i></b>).</p>

<p>The need for parentheses will be reduced
by assuming that compound statements are,
except for intervening parentheses,
executed from right to left. Thus 
<i>k</i>&nbsp;<tt>↑</tt>&nbsp;<i>j</i>&nbsp;<tt>↓</tt>&nbsp;<b><i>x</i></b> 
is equivalent to 
<i>k</i>&nbsp;<tt>↑</tt>&nbsp;(<i>j</i>&nbsp;<tt>↓</tt>&nbsp;<b><i>x</i></b>),
not to
(<i>k</i>&nbsp;<tt>↑</tt>&nbsp;<i>j</i>)&nbsp;<tt>↓</tt>&nbsp;<b><i>x</i></b>.</p>

<p>Structured operands such as vectors and matrices,
together with a systematic component-by-component generalization
of elementary operations, 
provide an important subordination of detail
in the description of algorithms.
The use of structured operands will be facilitated
by <i>selection operations</i> 
for extracting a specified portion of an operand,
<i>reduction operations</i>
for extending an operation
(such as logical or arithmetic multiplication)
over all components,
and <i>permutation operations</i>
for reordering components.
Operations defined on vectors are extended
to matrices:
the extended operation is called a <i>row</i> operation
if the underlying vector operation is applied to each row
of the matrix and a <i>column</i> operation
if it is applied to each column.
A column operation is denoted by doubling
the symbol employed for the corresponding
row (and vector) operation.</p>

<p>A distinct typeface will be used for each class
of operand as detailed in Table 1.8.
Special quantities (such as the prefix vectors 
<tt><b>⍺</b></tt><sup><i>i</i></sup> defined
in Sec. 1.7</a>)
will be denoted by Greek letters 
in the appropriate typeface.
For mnemonic reasons, an operation closely related
to such a special quantity will be denoted
by the same Greek letter.
For example, <tt>⍺/</tt><b><i>u</i></b> denotes
the maximum prefix (Sec. 1.10)
of the logical vector <b><i>u</i></b>.
Where a Greek letter is indistinguishable
from a Roman, sanserif characters will be used,
e.g. <font face=Arial><b><i>E</i></b></font> and <font face=Arial><b><i>I</i></b></font>
for the capitals of epsilon and iota.</p>

<table border=1 cellspacing=0 cellpadding=8>
<tr><td rowspan=2 align=center>Type of<br>Operand</td><td colspan=2 align=center>Representation</td></tr>
<tr><td align=center>Printed</td><td align=center>Typed</td></tr>
<tr>
<td><table>
<tr><td>&nbsp;</td><td colspan=2>Literal</td></tr>
<tr><td>&nbsp;</td><td>&nbsp; &nbsp;</td><td>Alphabetic</td></tr>
<tr><td>&nbsp;</td><td>&nbsp; &nbsp;</td><td>Numeric</td></tr>
<tr><td>&nbsp;</td><td colspan=2>Variable</td></tr>
<tr><td>&nbsp;</td><td>&nbsp; &nbsp;</td><td>Alphabetic</td></tr>
<tr><td>&nbsp;</td><td>&nbsp; &nbsp;</td><td>Numeric</td></tr>
<tr><td>&nbsp;</td><td colspan=2>Vector</td></tr>
<tr><td>&nbsp;</td><td colspan=2>Matrix</td></tr>
<tr><td>&nbsp;</td><td colspan=2>Tree</td></tr>
</table></td>
<td><table>
<tr><td>&nbsp;</td></tr>
<tr><td>Roman, u.c. and l.c.</td></tr>
<tr><td>Standard numeral</td></tr>
<tr><td>&nbsp;</td></tr>
<tr><td>Italic, u.c. and l.c.</td></tr>
<tr><td>Italic numeral</td></tr>
<tr><td>l.c. boldface italic</td></tr>
<tr><td>u.c. boldface italic</td></tr>
<tr><td>u.c. boldface roman</td></tr>
</table></td>
<td><table>
<tr><td>&nbsp;</td></tr>
<tr><td>Circled u.c. and l.c. roman</td></tr>
<tr><td>Standard numeral</td></tr>
<tr><td>&nbsp;</td></tr>
<tr><td>Unmarked</td></tr>
<tr><td>Underscore</td></tr>
<tr><td>Underscore</td></tr>
<tr><td>Underscore</td></tr>
<tr><td>Wavy underscore</td></tr>
</table></td>
</tr>
</table>

<p>&nbsp; &nbsp; &nbsp;<b>Table 1.8&nbsp;</b> Typographic conventions for classes of operands
</p>



<a name="1.3.2"></a>
<p><b>Literals and variables</b></p>

<p>The power of any mathematical notation rests
largely on the use of symbols to represent general quantities
which, in given instances, are further
specified by other quantities.
Thus Program 1.4 represents
a general process which determines
<i>x</i> = <i>n</i><sup>2/3</sup>
for any suitable value of <i>n</i>.
In a specific case, say <i>n</i> = 27,
the quantity <i>x</i> is specified
as the number 9.</p>

<p>Each operand occurring in a meaningful process
must be specified ultimately in terms
of commonly accepted concepts.
The symbols representing such accepted concepts
will be called <i>literals</i>.
Examples of literals are the integers,
the characters of the various alphabets,
punctuation marks, and miscellaneous symbols
such as $ and %.
The literals occurring 
in Program 1.4
are 0, 1, 2.</p>

<p>It is important to distinguish clearly
between general symbols and literals.
In ordinary algebra this presents little difficulty,
since the only literals occurring are the integers
and the decimal point,
and each general symbol employed includes
an alphabetic character.
In describing more general processes, however,
alphabetic literals (such as proper names)
also appear.
Moreover, in a computer program,
numeric symbols (register addresses)
are used to represent the variables.</p>

<p>In general, then, alphabetic literals,
alphabetic variables, numeric literals,
and numeric variables may all appear 
in a complex process and must be 
clearly differentiated.
The symbols used for literals will
be Roman letters 
(enclosed in quotes when appearing in text)
and standard numerals.
The symbols used for variables will be
italic letters, italic numerals, and
boldface letters as detailed in Table 1.8.
Miscellaneous signs and symbols when used
as literals will be enclosed in quotes
in both programs and text.</p>

<p>It is sometimes desirable
(e.g., for mnemonic reasons) to denote
a variable by a string of alphabetic
or other symbols rather than by a single symbol.
The monolithic interpretation of such a string
will be indicated by the <i>tie</i>
used in musical notation, thus:
<img align=middle src="APLimg/tie1x3a.bmp"> and 
<img align=middle src="APLimg/tie1x3b.bmp">
may denote the variable &ldquo;inventory&rdquo;,
a vector of inventory values,
and a matrix of inventory values, 
respectively.</p>

<a name="null_element"></a>
<p>In the set of alphabetic characters,
the <i>space</i> plays a special role.
For other sets a similar role is usually played
by some one element,
and this element is given the special name
of <i>null element</i>.
In the set of numeric digits, the <i>zero</i>
plays a dual role as both null element
and numeric quantity.
The null element will be denoted by
the degree symbol <tt>∘</tt>.</p>

<p>In any determinate process,
each operand must be specified ultimately
in terms of literals.
In Program 1.4,
for example, the quantity <i>k</i> is specified
in terms of known arithmetic operations
(multiplication and division)
involving the literals 1 and 2.
The quantity <i>n</i>, on the other hand,
is not determined within the process
and must presumably be specified
within some larger process which includes
Program 1.4.
Such a quantity is called an <i>argument</i>
of the process.</p>



<a name="1.3.3"></a>
<p><b>Domain and range</b></p>

<p>The class of arguments and the class of results
of a given operator are called its <i>domain</i>
and <i>range</i>, respectively.
Thus the domain and range of the magnitude operation
(|<i>x</i>|) are the real numbers 
and the nonnegative real numbers, respectively.</p>

<p>A variable is classified according
to the range of values it may assume:
it is <i>logical</i>, <i>integral</i>, or <i>numerical</i>,
according as the range is the set of logical variables
(that is, 0 and 1), the set of integers,
or the set of real numbers.
Each of the foregoing classes is clearly 
a subclass of each class following it,
and any operation defined on a class clearly
applies to any of its subclasses.
A variable which is nonnumeric 
will be called <i>arbitrary</i>.
In the Summary of Notation,
the range and domain of each of the operators
defined is specified in terms of the foregoing classes
according to the conventions shown in Sec. S.1.
<br>&nbsp;</p>



<a name="1.4"></a>
<p><b>1.4 Elementary operations</b></p>

<p>The elementary operations employed include 
the ordinary arithmetic operations,
the elementary operations of the logical calculus,
and the residue and related operations
arising in elementary number theory.
In defining operations in the text,
the symbol &harr; will be used to denote
equivalence of the pair of statements
between which it occurs.</p>

<a name="1.4.1"></a>
<p><b>Arithmetic operations</b></p>

<a name="plus"></a><a name="minus"></a><a name="times"></a><a name="divide"></a>
The ordinary arithmetic operations will be denoted
by the ordinary symbols +, &ndash;,
&times;, and <tt>÷</tt> and defined
as usual except that the domain and range
of multiplication will be extended slightly as follows.
If one of the factors is a logical variable
(0 or 1),
the second may be arbitrary and the product
then assumes the value of the second factor
or zero according as the value of the first factor
(the logical variable) is 1 or 0.
Thus if the arbitrary factor is the literal &ldquo;q&rdquo;,
then</p>

<table>
<tr><td>&nbsp;</td><td>&nbsp; &nbsp; &nbsp; 0 &times; q = q &times; 0 = 0</td></tr>
<tr><td>and   </td><td>&nbsp; &nbsp; &nbsp; 1 &times; q = q &times; 1 = q</td></tr>
</table>

<p>According to the usual custom in ordinary algebra,
the multiplication symbol may be elided.</p>



<a name="1.4.2"></a>
<p><b>Logical operations</b></p>

<a name="and"></a><a name="or"></a><a name="not"></a>
<p>The elementary logical operations <i>and</i>,
<i>or</i>, and <i>not</i> will be denoted
by &and;, &or; and an overbar
and are defined in the usual way as follows:</p>

<table>
<tr><td>&nbsp; &nbsp; &nbsp; <i>w</i> &larr; <i>u</i> &and; <i>v</i></td>  <td>&nbsp; &harr; &nbsp;</td>
 <td><i>w</i> = 1 if and only if <i>u</i> = 1 and&nbsp;</td><td><i>v</i> = 1,</td></tr>
<tr><td>&nbsp; &nbsp; &nbsp; <i>w</i> &larr; <i>u</i> &or; <i>v</i></td>  <td>&nbsp; &harr; &nbsp;</td>
 <td><i>w</i> = 1 if and only if <i>u</i> = 1 or</td>       <td><i>v</i> = 1,</td></tr>
<tr><td>&nbsp; &nbsp; &nbsp; <i>w</i> &larr; <img src="APLimg/uoscore.bmp"></td><td>&nbsp; &harr; &nbsp;</td>
 <td><i>w</i> = 1 if and only if <i>u</i> = 0.</td></tr>
</table>

<p>If <i>x</i> and <i>y</i> are numerical quantities, 
then the expression <i>x</i> &lt; <i>y</i> implies
that the quantity <i>x</i> stands in the relation
&ldquo;less than&rdquo; to the quantity <i>y</i>.
<a name="relation"></a>
More generally, if <i>&alpha;</i> and <i>&beta;</i> are arbitrary entities
and <font face="Script">R</font> is any relation defined on them,
the <i>relational statement</i> 
<nobr>(<i>&alpha;</i> <font face="Script">R</font> <i>&beta;</i>)</nobr>
is a logical variable which is true (equal to 1)
if and only if <i>&alpha;</i> stands 
in the relation <font face="Script">R</font> to <i>&beta;</i>. 
For example, if <i>x</i> is any real number,
then the function</p>

<p>&nbsp; &nbsp; &nbsp;(<i>x</i> &gt; 0) &ndash; (<i>x</i> &lt; 0)</p>

<p>(commonly called the <i>sign function</i> or sgn <i>x</i>)
assumes the values 1, 0, or &ndash;1 according as
<i>x</i> is strictly positive, 0, or strictly negative.
<a name="abs"></a>
Moreover, the magnitude function |<i>x</i>| may be defined
as |<i>x</i>| = <i>x</i> &times; sgn <i>x</i> = 
<i>x</i> &times; ((<i>x</i> &gt; 0) &ndash; (<i>x</i> &lt; 0)).</p>

<p>The relational statement is a useful generalization
of the Kronecker delta, that is 
<nobr><i>&delta;</i><sub><i>j</i></sub><sup><i>i</i></sup> = (<i>i</i> = <i>j</i>).</nobr>
Moreover, it provides a convenient expression 
for a number of familiar logical operations.
The <i>exclusive or</i>, for example,
may be denoted by (<i>u</i> &ne; <i>v</i>),
and its negation (i.e., the equivalence function)
may be denoted by  (<i>u</i> = <i>v</i>).</p>



<a name="1.4.3"></a>
<p><b>Residues and congruence</b></p>

<a name="residue"></a>
<p>For each set of integers <i>n</i>, <i>j</i>, and <i>b</i>,
with <i>b</i> &gt; 0, 
there exists a unique pair of integers
<i>q</i> and <i>r</i> such that</p>

<p>&nbsp; &nbsp; &nbsp; <i>n</i> = <i>b</i><i>q</i> + <i>r</i>,&nbsp;&nbsp;
<i>j</i> &le; <i>r</i> &lt; <i>j</i> + <i>b</i>.</p>

<p>The quantity <i>r</i> is called 
the <i>j-residue of n modulo b</i> and is denoted
by <i>b</i>&nbsp;|<sub><i>&nbsp;j</i></sub>&nbsp;<i>n</i>.
For example, 
3&nbsp;|<sub>0</sub>&nbsp;9 = 0,
3&nbsp;|<sub>1</sub>&nbsp;9 = 3, and
3&nbsp;|<sub>0</sub>&nbsp;10 = 1.
Moreover, if <i>n</i> &ge; 0, 
then <i>b</i>&nbsp;|<sub>0</sub>&nbsp;<i>n</i>
is the remainder obtained in dividing <i>n</i>
by <i>b</i> and <i>q</i> is the integral
part of the quotient.
A number <i>n</i> is said to be of <i>even parity</i>
if its 0-residue modulo 2 is zero
and of <i>odd parity</i> 
if 2&nbsp;|<sub>0</sub>&nbsp;<i>n</i> = 1.</p>

<p>If two numbers <i>n</i> and <i>m</i>
have the same <i>j</i>-residue modulo <i>b</i>,
they differ by an integral multiple of <i>b</i>
and therefore have the same <i>k</i>-residue
module <i>b</i> for any <i>k</i>.
If <i>b</i>&nbsp;|<sub><i>&nbsp;j</i></sub>&nbsp;<i>n</i> =
<i>b</i>&nbsp;|<sub><i>&nbsp;j</i></sub>&nbsp;<i>m</i>,
then <i>m</i> and <i>n</i> are said to be
<i>congruent mod b</i>.
Congruency is transitive and reflexive
and is denoted by</p>

<p>&nbsp; &nbsp; &nbsp; <i>m</i> &equiv; <i>n</i> (mod <i>b</i>).</p>

<p>In classical treatments, such as
<acronym title="Wright, H.N. (1939), 
First Course in Theory of Numbers, 
Wiley, New York.">Wright (1939)</acronym>,
only the 0-residue is considered.
The use of 1-origin indexing (cf. Sec. 1.5) 
accounts for the interest of the 1-residue.</p>

<p>A number represented in a positional notation
(e.g., in a base ten or a base two number system)
must, in practice, employ only a finite number
of digits.
It is therefore often desirable to approximate
a number <i>x</i> by an integer.
For this purpose two functions are defined:</p>
<a name="floor"></a><a name="ceiling"></a>

<table>
<tr><td valign=top>1.</td><td>&nbsp;</td><td>
the <i>floor of x</i> (or integral part of <i>x</i>),
denoted by
<tt>⌊</tt><i>x</i><tt>&rfloor;</tt>
and defined as the largest integer not exceeding <i>x</i>,
</td></tr>
<tr><td valign=top>2.</td><td>&nbsp;</td><td>
the <i>ceiling of x</i>,
denoted by
<tt>⌈</tt><i>x</i><tt>&rceil;</tt>
and defined as the smallest integer not exceeded by <i>x</i>.
</td></tr>
</table>

<p>Thus<p>

<table>
<tr><td>&nbsp; &nbsp; &nbsp;</td>
<td><tt>⌈</tt>3.14<tt>&rceil;</tt> = 4,</td><td>&nbsp; &nbsp;</td>
<td><tt>⌊</tt>3.14<tt>&rfloor;</tt> = 3,</td><td>&nbsp; &nbsp;</td>
<td><tt>⌊</tt>&ndash;3.14<tt>&rfloor;</tt> = &ndash;4,</td>
</tr>
<tr><td>&nbsp;</td>
<td><tt>⌈</tt>3.00<tt>&rceil;</tt> = 3,</td><td>&nbsp; &nbsp;</td>
<td><tt>⌊</tt>3.00<tt>&rfloor;</tt> = 3,</td><td>&nbsp; &nbsp;</td>
<td><tt>⌊</tt>&ndash;3.00<tt>&rfloor;</tt> = &ndash;3.</td>
</tr>
</table>

<p>Clearly <tt>⌈</tt><i>x</i><tt>&rceil;</tt> =  
&ndash;<tt>⌊</tt>&ndash;<i>x</i><tt>&rfloor;</tt> and
<tt>⌊</tt><i>x</i><tt>&rfloor;</tt> 
&le; <i>x</i> &le; <tt>⌈</tt><i>x</i><tt>&rceil;</tt>.
Moreover, <i>n</i> = <i>b</i><tt>⌊</tt><i>n</i> <tt>÷</tt> <i>b</i><tt>&rfloor;</tt>
+ <i>b</i>&nbsp;|<sub>0</sub>&nbsp;<i>n</i> for all integers <i>n</i>.
Hence the integral quotient 
<tt>⌊</tt><i>n</i> <tt>÷</tt> <i>b</i><tt>&rfloor;</tt>
is equivalent to the quantity <i>q</i> occurring in the definition
of the <i>j</i>-residue for the case <i>j</i> = 0.
<br>&nbsp;</p>



<a name="1.5"></a>
<p><b>1.5 Structured operands</b></p>

<a name="1.5.1"></a>
<p><b>Elementary operations</b></p>

<p>Any operation defined on a single operand
can be generalized to apply to each member
of an array of related operands.
Similarly, any binary operation
(defined on two operands) can be generalized
to apply to pairs of corresponding
elements of two arrays.
Since algorithms commonly incorporate processes
which are repeated on each member 
of an array of operands,
such generalization permits effective subordination
of detail in their description.
For example, the accounting process
defined on the data of an individual bank account
treats a number of distinct operands
within the account, 
such as account number, name, and balance.
Moreover, the over-all process is defined
on a large number of similar accounts,
all represented in a common format.
Such structured arrays of variables
will be called <i>structured operands</i>,
and extensive use will be made of three types,
called <i>vector</i>, <i>matrix</i>, and <i>tree</i>.
As indicated in Sec. S.1
of the Summary of Notation,
a structured operand is further classified
as <i>logical</i>, <i>integral</i>,
<i>numerical</i>, or <i>arbitrary</i>,
according to the type of elements in contains.</p>

<p>A <i>vector</i> <b><i>x</i></b> is the
ordered array of elements
(<b><i>x</i></b><sub>1</sub>,
<b><i>x</i></b><sub>2</sub>,
<b><i>x</i></b><sub>3</sub>, &#133;,
<b><i>x</i></b><sub><i>&nu;</i>(<b><i>x</i></b>)</sub>).
The variable <b><i>x</i></b><sub><i>i</i></sub>
is called the <i>i</i>th <i>component</i>
of the vector <b><i>x</i></b>,
and the number of components,
<a name="nu_vector"></a>
denoted by <i>&nu;</i>(<b><i>x</i></b>)
(or simply by <i>&nu;</i> when the determining vector
is clear from context),
is called the <i>dimension</i> of <b><i>x</i></b>.
Vectors and their components will be represented
in lower case boldface italics.
<a name="scalar_multiple"></a>
A numerical vector <b><i>x</i></b>
may be multiplied by a numerical
quantity <i>k</i> to produce the
<i>scalar multiple</i> 
<i>k</i> &times; <b><i>x</i></b>
(or <i>k</i><b><i>x</i></b>)
defined as the vector <b><i>z</i></b> 
such that 
<b><i>z</i></b><sub><i>&nbsp;i</i></sub> = 
<i>k</i>&nbsp;&times;&nbsp;<b><i>x</i></b><sub><i>i</i></sub>.</p>

<p>All elementary operations defined 
on individual variables are extended
consistently to vectors as
component-by-component operations.
For example,</p>

<table>
<tr><td>&nbsp; &nbsp; &nbsp;</td><td>
 <b><i>z</i></b> = <b><i>x</i></b> + <b><i>y</i></b></td>
 <td>&nbsp; &harr; &nbsp;</td>
 <td><b><i>z</i></b><sub><i>i</i></sub> = <b><i>x</i></b><sub><i>i</i></sub> + <b><i>y</i></b><sub><i>i</i></sub>,</td></tr>
<tr><td>&nbsp;</td><td>
 <b><i>z</i></b> = <b><i>x</i></b> &times; <b><i>y</i></b></td>
 <td>&nbsp; &harr; &nbsp;</td>
 <td><b><i>z</i></b><sub><i>i</i></sub> = <b><i>x</i></b><sub><i>i</i></sub> &times; <b><i>y</i></b><sub><i>i</i></sub>,</td></tr>
<tr><td>&nbsp;</td><td>
 <b><i>z</i></b> = <b><i>x</i></b> <tt>÷</tt> <b><i>y</i></b></td>
 <td>&nbsp; &harr; &nbsp;</td>
 <td><b><i>z</i></b><sub><i>i</i></sub> = <b><i>x</i></b><sub><i>i</i></sub> <tt>÷</tt> <b><i>y</i></b><sub><i>i</i></sub>,</td></tr>
<tr><td>&nbsp;</td><td>
 <b><i>z</i></b> = <tt>⌈</tt><b><i>x</i></b><tt>&rceil;</tt></td>
 <td>&nbsp; &harr; &nbsp;</td>
 <td><b><i>z</i></b><sub><i>i</i></sub> = <tt>⌈</tt><b><i>x</i></b><sub><i>i</i></sub><tt>&rceil;</tt></td>
<tr><td>&nbsp;</td><td>
 <b><i>w</i></b> = <b><i>u</i></b> &and; <b><i>v</i></b></td>
 <td>&nbsp; &harr; &nbsp;</td>
 <td><b><i>w</i></b><sub><i>i</i></sub> = <b><i>u</i></b><sub><i>i</i></sub> &and; <b><i>v</i></b><sub><i>i</i></sub>,</td></tr>
<tr><td>&nbsp;</td><td>
 <b><i>w</i></b> = (<b><i>x</i></b> &lt; <b><i>y</i></b>)</td>
 <td>&nbsp; &harr; &nbsp;</td>
 <td><b><i>w</i></b><sub><i>i</i></sub> = (<b><i>x</i></b><sub><i>i</i></sub> &lt; <b><i>y</i></b><sub><i>i</i></sub>).</td></tr>
</table>

<p>Thus if <b><i>x</i></b> = (1,&nbsp;0,&nbsp;1,&nbsp;1) and <b><i>y</i></b> = (0,&nbsp;1,&nbsp;1,&nbsp;0)
then <b><i>x</i></b> + <b><i>y</i></b> = (1,&nbsp;1,&nbsp;2,&nbsp;1),
<b><i>x</i></b> &and; <b><i>y</i></b> = (0,&nbsp;0,&nbsp;1,&nbsp;0),
and (<b><i>x</i></b> &lt; <b><i>y</i></b>) = (0,&nbsp;1,&nbsp;0,&nbsp;0).</p>



<a name="1.5.2"></a>
<p><b>Matrices</b></p>

<p>A matrix <b><i>M</i></b> is the ordered two-dimensional 
array of variables</p>

<table><tr><td>&nbsp; &nbsp; &nbsp;</td><td><table>
<tr><td rowspan=4><img src="APLimg/matrixl1x5.bmp"></td>
 <td><b><i>M</i></b><sub>1</sub><sup>1</sup>,</td>
 <td><b><i>M</i></b><sub>2</sub><sup>1</sup>,</td>
 <td>&#133;,</td>
 <td><b><i>M</i></b><sub><i>&nu;</i>(<b><i>M</i></b>)</sub><sup>1</sup></td>
 <td rowspan=4><img src="APLimg/matrixr1x5.bmp"></td>
 <td rowspan=4 valign=middle>.</td></tr>
<tr>
 <td><b><i>M</i></b><sub>1</sub><sup>2</sup>,</td>
 <td><b><i>M</i></b><sub>2</sub><sup>2</sup>,</td>
 <td>&#133;,</td>
 <td><b><i>M</i></b><sub><i>&nu;</i>(<b><i>M</i></b>)</sub><sup>2</sup></td></tr>
<tr>
 <td align=center>.</td>
 <td align=center>.</td>
 <td align=center>.</td>
 <td align=center>.</td></tr>
<tr>
 <td><b><i>M</i></b><sub>1</sub><sup><i>&mu;</i>(<b><i>M</i></b>)</sup>,</td>
 <td><b><i>M</i></b><sub>2</sub><sup><i>&mu;</i>(<b><i>M</i></b>)</sup>,</td>
 <td>&#133;,</td>
 <td><b><i>M</i></b><sub><i>&nu;</i>(<b><i>M</i></b>)</sub><sup><i>&mu;</i>(<b><i>M</i></b>)</sup></td></tr>
</table></td></tr></table>

<p>The vector 
<nobr>(<b><i>M</i></b><sub>1</sub><sup><i>i</i></sup>,
<b><i>M</i></b><sub>2</sub><sup><i>i</i></sup>, &#133;,
<b><i>M</i></b><sub><i>&nu;</i></sub><sup><i>i</i></sup>)</nobr>
is called the <i>i</i>th <i>row vector</i> of
<b><i>M</i></b> and is denoted by
<b><i>M</i></b><sup><i>&nbsp;i</i></sup>.
<a name="nu_matrix"></a>
Its dimension <i>&nu;</i>(<b><i>M</i></b>) is called
the <i>row dimension</i> of the matrix.
The vector
<nobr>(<b><i>M</i></b><sub><i>&nbsp;j</i></sub><sup>1</sup>,
<b><i>M</i></b><sub><i>&nbsp;j</i></sub><sup>2</sup>, &#133;,
<b><i>M</i></b><sub><i>&nbsp;j</i></sub><sup><i>&nbsp;&mu;</i></sup>)</nobr>
is called the <i>j</i>th <i>column vector</i>
of <b><i>M</i></b> and is denoted by
<b><i>M</i></b><sub><i>&nbsp;j</i></sub>.
<a name="mu_matrix"></a>
Its dimension <i>&mu;</i>(<b><i>M</i></b>) is called
the <i>column dimension</i> of the matrix.</p>

<p>The variable <b><i>M</i></b><sub><i>&nbsp;j</i></sub><sup><i>i</i></sup>
is called the (<i>i</i>,<i>j</i>)th <i>component</i>
or <i>element</i> of the matrix.
A matrix and its elements will be represented 
by upper case boldface italics.
Operations defined on each element of a matrix
are generalized component by component
to the entire matrix.
Thus, if <img src="APLimg/circledot.bmp">
is any binary operator,

<p>&nbsp; &nbsp; &nbsp; <b><i>P</i></b> = <b><i>M</i></b> 
<img src="APLimg/circledot.bmp"> <b><i>N</i></b> &harr;
<b><i>M</i></b><sub><i>j</i></sub><sup><i>i</i></sup>
<img src="APLimg/circledot.bmp">
<b><i>N</i></b><sub><i>j</i></sub><sup><i>i</i></sup>.</p>



<a name="1.5.3"></a>
<p><b>Index systems</b></p>

<p>The subscript appended to a vector to designate
a single component is called an <i>index</i>,
and the indices are normally chosen as a set of
successive integers beginning at 1, that is,
<b><i>x</i></b> = (<b><i>x</i></b><sub>1</sub>,
<b><i>x</i></b><sub>2</sub>, &#133; <b><i>x</i></b><sub><i>&nu;</i></sub>).
It is, however, convenient to admit more general 
<i>j</i>-<i>origin indexing</i> in which
the set of successive integers employed as indices
in any structured operand begin 
with a specified integer <i>j</i>.</p>

<p>The two systems of greatest interest
are the common 1-origin system, 
which will be employed
almost exclusively in this chapter,
and the 0-origin system.
The latter system is particularly convenient
whenever the index itself must be represented
in a positional number system and will therefore
be employed exclusively in the treatment
of computer organization in Chapter 2.
<br>&nbsp;</p>



<a name="1.6"></a>
<p><b>1.6 Rotation</b></p>

<p>The <i>left rotation</i> of a vector <b><i>x</i></b>
is denoted by <i>k</i>&nbsp;&uarr;&nbsp;<b><i>x</i></b>
and specifies the vector obtained by cyclical
left shift of the components of <b><i>x</i></b>
by <i>k</i> places.
Thus if 
<nobr><b><i>a</i></b> = (1, 2, 3, 4, 5, 6),</nobr> and
<nobr><b><i>b</i></b> = (c, a, n, d, y),</nobr> then
<nobr>2 &uarr; <b><i>a</i></b> = (3, 4, 5, 6, 1, 2)</nobr>
and 
<nobr>3 &uarr; <b><i>b</i></b> = </nobr>
<nobr>8 &uarr; <b><i>b</i></b> = </nobr>
<nobr>(d, y, c, a, n).</nobr>
Formally,<sup><a href="APL1.htm#note1a">[a]</a></sup></p>

<p>&nbsp; &nbsp; &nbsp; <b><i>z</i></b> = <i>k</i> &uarr; <b><i>x</i></b>
&harr; <b><i>z</i></b><sub><i>&nbsp;i</i></sub> = 
<b><i>x</i></b><sub><i>&nbsp;j</i></sub>, &nbsp; &nbsp;
where <i>j</i> = <i>&nu;</i>|<sub>1</sub>(<i>i</i> + <i>k</i>).</p>

<a name="right_rotation"></a>
<p><i>Right rotation</i> is denoted by 
<i>k</i>&nbsp;&darr;&nbsp;<b><i>x</i></b>
and is defined analogously.  Thus</p>

<p>&nbsp; &nbsp; &nbsp; <b><i>z</i></b> = <i>k</i> &darr; <b><i>x</i></b>
&harr; <b><i>z</i></b><sub><i>&nbsp;i</i></sub> = 
<b><i>x</i></b><sub><i>&nbsp;j</i></sub>, &nbsp; &nbsp;
where <i>j</i> = <i>&nu;</i>|<sub>1</sub>(<i>i</i> &ndash; <i>k</i>).</p>

<p>If <i>k</i> = 1, it may be elided.
Thus &uarr; <b><i>b</i></b> = (a,&nbsp;n,&nbsp;d,&nbsp;y,&nbsp;c).</p>

<a name="rotate_row"></a>
<a name="rotate_col"></a>
<p>Left rotation is extended to matrices
in two ways as follows:</p>

<table>
<tr><td>&nbsp; &nbsp; &nbsp;</td><td><b><i>A</i></b> &larr; <b><i>j</i></b> &uarr; <b><i>B</i></b></td>
 <td>&nbsp;&harr;&nbsp;</td>
 <td><b><i>A</i></b><sup><i>i</i></sup> = <b><i>j</i></b><sub><i>i</i></sub> &uarr; <b><i>B</i></b><sup><i>i</i></sup></td>
</tr>
<tr><td>&nbsp; &nbsp; &nbsp;</td><td><b><i>C</i></b> &larr; <b><i>k</i></b> <img src="APLimg/uarr.bmp"> <b><i>B</i></b></td>
 <td>&nbsp;&harr;&nbsp;</td>
 <td><b><i>C</i></b><sub><i>i</i></sub> = <b><i>k</i></b><sub><i>j</i></sub> &uarr; <b><i>B</i></b><sub><i>j</i></sub></td>
</tr>
</table>

<p>The first operation is an extension
of the basic vector rotation to each row
of the matrix and is therefore called <i>row rotation</i>.
The second operation is the corresponding 
column operation and is therefore denoted
by the doubled operation symbol <img src="APLimg/uarr.bmp">.
For example, if</p>

<p>&nbsp; &nbsp; &nbsp; <b><i>k</i></b> = (0,&nbsp;1,&nbsp;2),</p>

and

<table>
<tr><td>&nbsp; &nbsp; &nbsp;</td><td><b><i>B</i></b> = &nbsp; </td><td><table>
<tr><td rowspan=3><img src="APLimg/matrixl3.bmp">&nbsp;</td>
 <td><i>a</i><sup>&nbsp;</sup><sub>&nbsp;</sub>&nbsp; &nbsp;</td>
 <td><i>b</i><sup>&nbsp;</sup><sub>&nbsp;</sub>&nbsp; &nbsp;</td>
 <td><i>c</i><sup>&nbsp;</sup><sub>&nbsp;</sub></td>
 <td rowspan=3><img src="APLimg/matrixr3.bmp"></td></tr>
<tr>
 <td><i>d</i><sup>&nbsp;</sup><sub>&nbsp;</sub>&nbsp; &nbsp;</td>
 <td><i>e</i><sup>&nbsp;</sup><sub>&nbsp;</sub>&nbsp; &nbsp;</td>
 <td><i>f</i><sup>&nbsp;</sup><sub>&nbsp;</sub></td></tr>
<tr>
 <td><i>g</i><sup>&nbsp;</sup><sub>&nbsp;</sub>&nbsp; &nbsp;</td>
 <td><i>h</i><sup>&nbsp;</sup><sub>&nbsp;</sub>&nbsp; &nbsp;</td>
 <td><i>i</i><sup>&nbsp;</sup><sub>&nbsp;</sub></td></tr>
</table></td></tr>
</table>

then

<table><tr><td>
<table>
<tr><td>&nbsp; &nbsp; &nbsp;</td><td><b><i>k</i></b> &uarr; <b><i>B</i></b> = &nbsp; </td><td><table>
<tr><td rowspan=3><img src="APLimg/matrixl3.bmp">&nbsp;</td>
 <td><i>a</i><sup>&nbsp;</sup><sub>&nbsp;</sub>&nbsp; &nbsp;</td>
 <td><i>b</i><sup>&nbsp;</sup><sub>&nbsp;</sub>&nbsp; &nbsp;</td>
 <td><i>c</i><sup>&nbsp;</sup><sub>&nbsp;</sub></td>
 <td rowspan=3><img src="APLimg/matrixr3.bmp"></td></tr>
<tr>
 <td><i>e</i><sup>&nbsp;</sup><sub>&nbsp;</sub>&nbsp; &nbsp;</td>
 <td><i>f</i><sup>&nbsp;</sup><sub>&nbsp;</sub>&nbsp; &nbsp;</td>
 <td><i>d</i><sup>&nbsp;</sup><sub>&nbsp;</sub></td></tr>
<tr>
 <td><i>i</i><sup>&nbsp;</sup><sub>&nbsp;</sub>&nbsp; &nbsp;</td>
 <td><i>g</i><sup>&nbsp;</sup><sub>&nbsp;</sub>&nbsp; &nbsp;</td>
 <td><i>h</i><sup>&nbsp;</sup><sub>&nbsp;</sub></td></tr>
</table></td></tr>
</table>
</td><td>&nbsp; &nbsp; &nbsp; and &nbsp; &nbsp; &nbsp;</td><td>
<table>
<tr><td><b><i>k</i></b> <img src="APLimg/uarr.bmp"> <b><i>B</i></b> = &nbsp; </td><td><table>
<tr><td rowspan=3><img src="APLimg/matrixl3.bmp">&nbsp;</td>
 <td><i>a</i><sup>&nbsp;</sup><sub>&nbsp;</sub>&nbsp; &nbsp;</td>
 <td><i>e</i><sup>&nbsp;</sup><sub>&nbsp;</sub>&nbsp; &nbsp;</td>
 <td><i>i</i><sup>&nbsp;</sup><sub>&nbsp;</sub></td>
 <td rowspan=3><img src="APLimg/matrixr3.bmp"></td></tr>
<tr>
 <td><i>d</i><sup>&nbsp;</sup><sub>&nbsp;</sub>&nbsp; &nbsp;</td>
 <td><i>h</i><sup>&nbsp;</sup><sub>&nbsp;</sub>&nbsp; &nbsp;</td>
 <td><i>c</i><sup>&nbsp;</sup><sub>&nbsp;</sub></td></tr>
<tr>
 <td><i>g</i><sup>&nbsp;</sup><sub>&nbsp;</sub>&nbsp; &nbsp;</td>
 <td><i>b</i><sup>&nbsp;</sup><sub>&nbsp;</sub>&nbsp; &nbsp;</td>
 <td><i>f</i><sup>&nbsp;</sup><sub>&nbsp;</sub></td></tr>
</table></td></tr>
</table>
</td><td>.</td></tr></table>

<p>Right rotation is extended analogously.
<br>&nbsp;</p>



<a name="1.7"></a>
<p><b>1.7 Special vectors</b></p>

<p>Certain special vectors warrant special symbols.
In each of the following definitions,
the parameter <i>n</i> will be used to specify the dimension.
<a name="interval_vector"></a>
The <i>interval vector</i> 
<tt><b>⍳</b></tt><sup><i>j</i></sup>(<i>n</i>)
is defined as the vector of integers
beginning with <i>j</i>.
Thus <tt><b>⍳</b></tt><sup>0</sup>(4)=(0,&nbsp;1,&nbsp;2,&nbsp;3),
<tt><b>⍳</b></tt><sup>1</sup>(4)=(1,&nbsp;2,&nbsp;3,&nbsp;4),
and <tt><b>⍳</b></tt><sup>&ndash;7</sup>(5)=
(&ndash;7,&nbsp;&ndash;6,&nbsp;&ndash;5,&nbsp;&ndash;4,&nbsp;&ndash;3).
Four types of logical vectors are defined as follows.
<a name="unit_vector"></a>
The <i>j</i>th <i>unit vector</i>
<tt><b>∊</b></tt><sup><i>&nbsp;j</i></sup>(<i>n</i>)
has a one in the <i>j</i>th position, that is,
(<tt><b>∊</b></tt><sup><i>&nbsp;j</i></sup>(<i>n</i>))<sub><i>k</i></sub>
= (<i>k</i>&nbsp;=&nbsp;<i>j</i>).
<a name="full_vector"></a>
The <i>full vector</i> <tt><b>∊</b></tt></sup>(<i>n</i>)
consists of all ones.
<a name="zero_vector"></a>
The vector consisting of all zeros is denoted
both by 0 and by <img src="APLimg/epsboscore.bmp">(<i>n</i>).
<a name="prefix_vector"></a>
The <i>prefix vector of weight j</i> is denoted by
<tt><b>⍺</b></tt><sup><i>&nbsp;j</i></sup>(<i>n</i>)
and possesses ones in the first <i>k</i> positions,
where <i>k</i> is the lesser 
of <i>j</i> and <i>n</i>.
<a name="suffix_vector"></a>
The <i>suffix vector</i>
<tt><b>⍵</b></tt><sup><i>&nbsp;j</i></sup>(<i>n</i>)
is defined analogously.
Thus <tt><b>∊</b></tt><sup>2</sup>(3) = (0,&nbsp;1,&nbsp;0),
<tt><b>∊</b></tt>(4) = (1,&nbsp;1,&nbsp;1,&nbsp;1),
<tt><b>⍺</b></tt><sup>3</sup>(5) = (1,&nbsp;1,&nbsp;1,&nbsp;0,&nbsp;0),
<tt><b>⍵</b></tt><sup>3</sup>(5) = (0,&nbsp;0,&nbsp;1,&nbsp;1,&nbsp;1), and 
<tt><b>⍺</b></tt><sup>7</sup>(5) = 
<tt><b>⍺</b></tt><sup>5</sup>(5) = (1,&nbsp;1,&nbsp;1,&nbsp;1,&nbsp;1).
Moreover, 
<tt><b>⍵</b></tt><sup><i>&nbsp;j</i></sup>(<i>n</i>) =
<i>j</i> &uarr; <tt><b>⍺</b></tt><sup><i>&nbsp;j</i></sup>(<i>n</i>),
and <tt><b>⍺</b></tt><sup><i>&nbsp;j</i></sup>(<i>n</i>) =
<i>j</i> &darr; <tt><b>⍵</b></tt><sup><i>&nbsp;j</i></sup>(<i>n</i>).
</p>

<a name="infix_vector"></a>
<p>A logical vector of the form
<tt><b>⍺</b></tt><sup><i>h</i></sup>(<i>n</i>) &and;
<tt><b>⍵</b></tt><sup><i>&nbsp;j</i></sup>(<i>n</i>) 
is called an <i>infix vector</i>.
An infix vector can also be specified in the form
<i>j</i>&nbsp;&darr;&nbsp;<tt><b>⍺</b></tt><sup><i>k</i></sup>(<i>n</i>),
which displays its weight and location more directly.</p>

<p>An operation such as <b><i>x</i></b> &and; <b><i>y</i></b>
is defined only for <i>compatible</i> vectors 
<b><i>x</i></b> and <b><i>y</i></b>, that is,
for vectors of like dimension.
Since this compatibility requirement can be assumed
to specify implicitly the dimension of 
one of the operands, elision of the parameter <i>n</i>
may be permitted in the notation for the special vectors.
Thus, if <i>y</i> = (3,&nbsp;4,&nbsp;5,&nbsp;6,&nbsp;7),
the expression <tt><b>∊</b></tt> &times; <b><i>y</i></b>
and <tt><b>∊</b></tt><sup><i>&nbsp;j</i></sup> &times; <b><i>y</i></b>
imply that the dimensions of <tt><b>∊</b></tt>
and <tt><b>∊</b></tt><sup><i>&nbsp;j</i></sup>
are both 5.
Moreover, elision of <i>j</i> will be permitted
for the interval vector 
<tt><b>⍳</b></tt><sup><i>&nbsp;j</i></sup>(<i>n</i>)
(or <tt><b>⍳</b></tt><sup><i>&nbsp;j</i></sup>),
and for the residue operator |<sub><i>&nbsp;j</i></sub>
when <i>j</i> is the index origin in use.</p>

<p>It is, of course, necessary to specify
the index origin in use at any given time.
For example, the unit vector 
<tt><b>∊</b></tt><sup>3</sup>(5) is
(0,&nbsp;0,&nbsp;1,&nbsp;0,&nbsp;0) in a 1-origin system and
(0,&nbsp;0,&nbsp;0,&nbsp;1,&nbsp;0) in a 0-origin system,
even though the definition
(that is,  (<tt><b>∊</b></tt><sup><i>&nbsp;j</i></sup>(<i>n</i>))<sub><i>k</i></sub>
= (<i>k</i> = <i>j</i>)) remains unchanged.
The prefix and suffix vectors are, of course,
independent of the index origin.
Unless otherwise specified, 
1-origin indexing will be assumed.</p>

<p>The vector <tt><b>∊</b></tt>(0) is a vector
of dimension zero and will be called 
the <i>null vector</i>. 
It should not be confused 
with the special null element <tt>∘</tt>.
<br>&nbsp;</p>



<a name="1.8"></a>
<p><b>1.8 Reduction</b></p>

<p>An operation (such as summation) which is applied
to all components of a vector to produce a result
of a simpler structure is called a <i>reduction</i>.
The <img src="APLimg/circledot.bmp">-reduction
of a vector <b><i>x</i></b> is denoted by
<img src="APLimg/circledot.bmp">/<b><i>x</i></b>
and defined as</p>

<p>&nbsp; &nbsp; &nbsp; <b><i>z</i></b> &larr; 
<img src="APLimg/circledot.bmp">/<b><i>x</i></b>
&nbsp;&harr;&nbsp; <b><i>z</i></b> = 
(&#133; ((<b><i>x</i></b><sub>1</sub>
<img src="APLimg/circledot.bmp"> <b><i>x</i></b><sub>2</sub>)
<img src="APLimg/circledot.bmp"> <b><i>x</i></b><sub>3</sub>)
<img src="APLimg/circledot.bmp"> &#133;) 
<img src="APLimg/circledot.bmp"> <b><i>x</i></b><sub><i>&nu;</i></sub>),</p>

<p>where <img src="APLimg/circledot.bmp"> 
is any binary operator with a suitable domain.
Thus +/<b><i>x</i></b> is the sum,
&times;/<b><i>x</i></b> is the product, 
and &or;/<b><i>x</i></b>
is the logical sum of the components
of a vector <b><i>x</i></b>.
For example, &times;/<tt><b>⍳</b></tt><sup>1</sup>(5)
= 1 &times; 2 &times; 3 &times; 4 &times; 5,
&times;/<tt><b>⍳</b></tt><sup>1</sup>(<i>n</i>) = <i>n</i>!,
and +/<tt><b>⍳</b></tt><sup>1</sup>(<i>n</i>) =
<i>n</i>(<i>n</i> + 1)/2.</p>

<p>As a further example, De Morgan&rsquo;s law
may be expressed as &and;/<b><i>u</i></b>
= <img src="APLimg/ex1x10a.bmp">,
where <b><i>u</i></b> is 
a logical vector of dimension two.
Moreover, a simple inductive argument (Exercise 1.10)
shows that the foregoing expression is the
valid generalization of De Morgan&rsquo;s law
for a logical vector <b><i>u</i></b>
of arbitrary dimension.</p>

<p>A relation <font face="Script">R</font> incorporated 
into a relational statement (<i>x</i><font face="Script">R</font><i>y</i>)
becomes, in effect, an operator on the variables
<i>x</i> and <i>y</i>.
Consequently, the reduction <font face="Script">R</font>/<b><i>x</i></b>
can be defined in a manner analogous to that of
(<img src="APLimg/circledot.bmp">/<b><i>x</i></b>),
that is,</p>

<p>&nbsp; &nbsp; &nbsp; <font face="Script">R</font>/<b><i>x</i></b> =
(&#133; ((<b><i>x</i></b><sub>1</sub> <font face="Script">R</font> 
<b><i>x</i></b><sub>2</sub>) <font face="Script">R</font>
<b><i>x</i></b><sub>3</sub>) <font face="Script">R</font> &#133;)
<font face="Script">R</font> <b><i>x</i></b><sub><i>&nu;</i></sub>).</p>

<p>The parentheses now imply relational statements
as well as grouping.  
The relational reductions of practical interest
are &ne;/<b><i>u</i></b>, and =/<b><i>u</i></b>,
the <i>exclusive-or</i> and the <i>equivalence</i>
reduction, respectively.</p>

<p>The inductive argument of Exercise 1.10
shows that &ne;/<b><i>u</i></b> = 
2 |<sub>0</sub> (+/<b><i>u</i></b>).
For example, if <b><i>u</i></b> = (1,0,1,1,0), then</p>

<table>
<tr><td>&nbsp; &nbsp; &nbsp; </td><td>&ne;/<b><i>u</i></b></td>
 <td>&nbsp;=&nbsp;</td><td>((((1 &ne; 0) &ne; 1) &ne; 1) &ne; 0)</td>
<tr><td colspan=2>&nbsp;</td>
 <td>&nbsp;=&nbsp;</td><td>(((1 &ne; 1) &ne; 1) &ne; 0)</td></tr>
<tr><td colspan=2>&nbsp;</td>
 <td>&nbsp;=&nbsp;</td><td>((0 &ne; 1) &ne; 0)</td></tr>
<tr><td colspan=2>&nbsp;</td>
 <td>&nbsp;=&nbsp;</td><td>(1 &ne; 0) = 1,</td></tr>
</table>

<p>and 2 |<sub>0</sub> (+/<b><i>u</i></b>) = 2 |<sub>0</sub> 3 = 1.
Similarly, =/<b><i>u</i></b> = <img align=top src="APLimg/ex1x10c.bmp">,
and as a consequence,</p>

<p>&nbsp; &nbsp; &nbsp; &ne;/<b><i>u</i></b> = <img src="APLimg/ex1x10d.bmp">,</p>

<p>a useful companion to De Morgan&rsquo;s law.</p>

<p>To complete the system it is essential to define
the value of 
<img src="APLimg/circledot.bmp">/<tt><b>∊</b></tt>(0),
the reduction of the null vector of dimension zero,
as the identity element of the operator 
or relation <img src="APLimg/circledot.bmp">.
Thus +/<tt><b>∊</b></tt>(0) = &or;/<tt><b>∊</b></tt>(0) = 0,
and &times;/<tt><b>∊</b></tt>(0) = 
&and;/<tt><b>∊</b></tt>(0) = 1.</p>

<a name="reduce_row"></a>
<p>A reduction operation is extended 
to matrices in two ways.
A <i>row reduction</i> of a matrix <b><i>X</i></b>
by an operator <img src="APLimg/circledot.bmp">
is denoted by</p>

<p>&nbsp; &nbsp; &nbsp; <b><i>y</i></b> &larr; 
<img src="APLimg/circledot.bmp">/<b><i>X</i></b></p>

<p>and specifies a vector <b><i>y</i></b> of dimension
<i>&mu;</i>(<b><i>X</i></b>) such that 
<b><i>y</i></b><sub><i>i</i></sub> =
<img src="APLimg/circledot.bmp">/<b><i>X</i></b><sup><i>i</i></sup>.
<a name="reduce_col"></a>
A <i>column reduction</i> of <b><i>X</i></b> is denoted
by <b><i>z</i></b> &larr; 
<img src="APLimg/circledot.bmp">//<b><i>X</i></b>
and specifies a vector <b><i>z</i></b>
of dimension <i>&nu;</i>(<b><i>X</i></b>)
such that <b><i>z</i></b><sub><i>&nbsp;j</i></sub> =
<img src="APLimg/circledot.bmp">//<b><i>X</i></b><sub><i>&nbsp;j</i></sub>.
</p>

<p>For example, if</p>

<table>
<tr><td rowspan=3>&nbsp; &nbsp; &nbsp; <b><i>U</i></b> &nbsp;=&nbsp;</td>
 <td rowspan=3><img src="APLimg/matrixl3.bmp"></td>
 <td><sup>&nbsp;</sup>1 &nbsp; 0 &nbsp; 1 &nbsp; 0<sub>&nbsp;</sub></td>
 <td rowspan=3><img src="APLimg/matrixr3.bmp"></td>
</tr>
<tr><td><sup>&nbsp;</sup>0 &nbsp; 0 &nbsp; 1 &nbsp; 1<sub>&nbsp;</sub></td></tr>
<tr><td><sup>&nbsp;</sup>1 &nbsp; 1 &nbsp; 1 &nbsp; 0<sub>&nbsp;</sub></td></tr>
</table>

<p>then +/<b><i>U</i></b> = <nobr>(2, 2, 3),</nobr> 
+//<b><i>U</i></b> = <nobr>(2, 1, 3, 1),</nobr>
&and;//<b><i>U</i></b> = <nobr>(0, 0, 1, 0),</nobr>
&ne;/<b><i>U</i></b> = <nobr>(0, 0, 1),</nobr>
=//<b><i>U</i></b> = <nobr>(0, 1, 1, 1),</nobr> and
<nobr>+/(=//<b><i>U</i></b>) = 3.</nobr>
<br>&nbsp;</p>



<a name="1.9"></a>
<p><b>1.9 Selection</b></p>

<a name="1.9.1"></a>
<p><b>Compression</b></p>

<p>The effective use of structured operands depends not only
on generalized operations but also on the ability to specify
and select certain elements or groups of elements.
The selection of single elements can be indicated by indices,
as in the expressions 
<b><i>v</i></b><sub><i>i</i></sub>,
<b><i>M</i></b><sup><i>&nbsp;i</i></sup>,
<b><i>M</i></b><sub><i>&nbsp;j</i></sub>, and
<b><i>M</i></b><sub><i>&nbsp;i</i></sub><sup><i>&nbsp;j</i></sup>.
Since selection is a binary operation
(i.e., to select or not to select),
more general selection is conveniently specified
by a logical vector, 
each unit component indicating selection 
of the corresponding component of the operand.</p>

<p>The selection operation defined on an arbitrary
vector <b><i>a</i></b> and a compatible
(i.e., equal in dimension) 
logical vector <b><i>u</i></b> is denoted by
<b><i>c</i></b> &larr; <b><i>u</i></b>/<b><i>a</i></b>
and is defined as follows:
the vector <b><i>c</i></b> is obtained from
<b><i>a</i></b> by suppressing from
<b><i>a</i></b> each component 
<b><i>a</i></b><sub><i>i</i></sub>
for which <b><i>u</i></b><sub><i>i</i></sub> = 0.
The vector <b><i>u</i></b> is said to <i>compress</i>
the vector <b><i>a</i></b>.
Clearly <i>&nu;</i>(<b><i>c</i></b>) = +/<b><i>u</i></b>.
For example, if <b><i>u</i></b> = 
<nobr>(1, 0, 0, 0, 1, 1)</nobr>
and <b><i>a</i></b> = <nobr>(M, o, n, d, a, y),</nobr>
then <b><i>u</i></b>/<b><i>a</i></b> = <nobr>(M, a, y).</nobr>
Moreover, if <i>n</i> is even and
<b><i>v</i></b> = 
<nobr>(2<tt><b>∊</b></tt>) |<sub>0</sub> <tt><b>⍳</b></tt><sup>1</sup>(<i>n</i>)</nobr>
= <nobr>(1, 0, 1, 0, 1, &#133;),</nobr>
then <b><i>v</i></b>/<tt><b>⍳</b></tt><sup>1</sup>(<i>n</i>) =
<nobr>(1, 3, 5, &#133;, <i>n</i>&ndash;1)</nobr> and
+/(<b><i>v</i></b>/<tt><b>⍳</b></tt><sup>1</sup>(<i>n</i>)) 
= (<i>n</i>/2)&sup2;.
</p>

<a name="compress_row"></a>
<p><i>Row compression</i> of a matrix,
denoted by <b><i>u</i></b>/<b><i>A</i></b>,
compresses each row vector <b><i>A</i></b><sup><i>i</i></sup>
to form a matrix of dimension 
<nobr><i>&mu;</i>(<b><i>A</i></b>) &times; +/<b><i>u</i></b>.</nobr>
<a name="compress_col"></a>
<i>Column compression</i>, 
denoted by <b><i>u</i></b>//<b><i>A</i></b>,
compresses each column vector <b><i>A</i></b><sub><i>&nbsp;j</i></sub>
to form a matrix of dimension 
<nobr>+/<b><i>u</i></b> &times; <i>&nu;</i>(<b><i>A</i></b>).</nobr>
Compatibility conditions are 
<i>&nu;</i>(<b><i>u</i></b>) = <i>&nu;</i>(<b><i>A</i></b>)
for row compression, and 
<i>&nu;</i>(<b><i>u</i></b>) = <i>&mu;</i>(<b><i>A</i></b>)
for column compression.
For example, if <b><i>A</i></b> is an arbitrary 
3&nbsp;&times&nbsp;4 matrix,
<b><i>u</i></b> = <nobr>(0, 1, 0, 1)</nobr>
and <b><i>v</i></b> = <nobr>(1, 0, 1);</nobr> then</p>

<table>
<tr><td>&nbsp; &nbsp; &nbsp;</td><td><table>
<tr><td rowspan=3><b><i>u</i></b>/<b><i>A</i></b> &nbsp;=&nbsp;</td>
<td rowspan=3><img src="APLimg/matrixl3.bmp"></td>
<td>
<b><i>A</i></b><sub>2</sub><sup>1</sup>  &nbsp;
<b><i>A</i></b><sub>4</sub><sup>1</sup>
</td>
<td rowspan=3><img src="APLimg/matrixr3.bmp"></td>
<td rowspan=3>,</td>
</tr>
<tr><td>
<b><i>A</i></b><sub>2</sub><sup>3</sup> &nbsp;
<b><i>A</i></b><sub>4</sub><sup>3</sup>
</td></tr>
<tr><td>
<b><i>A</i></b><sub>2</sub><sup>2</sup>  &nbsp;
<b><i>A</i></b><sub>4</sub><sup>2</sup>
</td></tr>
</table></td>
<td>&nbsp; &nbsp; &nbsp;</td><td><table>
<tr><td rowspan=2><b><i>v</i></b>//<b><i>A</i></b> &nbsp;=&nbsp;</td>
<td rowspan=2><img src="APLimg/matrixl2.bmp"></td>
<td>
<b><i>A</i></b><sub>1</sub><sup>1</sup> &nbsp;
<b><i>A</i></b><sub>2</sub><sup>1</sup> &nbsp;
<b><i>A</i></b><sub>3</sub><sup>1</sup> &nbsp;
<b><i>A</i></b><sub>4</sub><sup>1</sup>
</td>
<td rowspan=2><img src="APLimg/matrixr2.bmp"></td>
<td rowspan=2>,</td>
</tr>
<tr><td>
<b><i>A</i></b><sub>1</sub><sup>3</sup> &nbsp;
<b><i>A</i></b><sub>2</sub><sup>3</sup> &nbsp;
<b><i>A</i></b><sub>3</sub><sup>3</sup> &nbsp;
<b><i>A</i></b><sub>4</sub><sup>3</sup>
</td></tr>
</table></td></tr>
</table>

and

<table><tr>
<td rowspan=2>&nbsp; &nbsp; &nbsp; 
<b><i>u</i></b>/<b><i>v</i></b>//<b><i>A</i></b> &nbsp;=&nbsp;
<b><i>v</i></b>//<b><i>u</i></b>/<b><i>A</i></b> &nbsp;=&nbsp;</td>

<td rowspan=2><img src="APLimg/matrixl2.bmp"></td>
<td><table>
<tr><td>
<b><i>A</i></b><sub>2</sub><sup>1</sup> &nbsp;
<b><i>A</i></b><sub>4</sub><sup>1</sup>
</td></tr>
<tr><td>
<b><i>A</i></b><sub>2</sub><sup>3</sup> &nbsp;
<b><i>A</i></b><sub>4</sub><sup>3</sup>
</td></tr>
</table></td>
<td rowspan=2><img src="APLimg/matrixr2.bmp"></td>
<td rowspan=2>.</td>
</tr></table>

<p>It is clear that <i>row</i> compression
<i>suppresses columns</i> corresponding to zeros
of the logical vector and that
<i>column</i> compression <i>suppresses rows</i>.
This illustrates the type of confusion in nomenclature
which is avoided by the convention
adopted in Sec. 1.3:
an operation is called a <i>row operation</i>
if the underlying operation from which
it is generalized is applied to the row vectors
of the matrix,
and a <i>column operation</i>
if it is applied to columns.</p>

<table><tr><td>&nbsp;</td><td>
<p><b>Example 1.1</b>. A bank makes a quarterly review
of accounts to produce the following four lists:</p>
<table>
<tr><td valign=top>1.</td><td>&nbsp;</td><td>
the name, account number, and balance for each account
with a balance less than two dollars.</p>
<tr><td valign=top>2.</td><td>&nbsp;</td><td>
the name, account number, and balance for each account
with a negative balance exceeding one hundred dollars.</p>
<tr><td valign=top>3.</td><td>&nbsp;</td><td>
the name and account number of each account
with a balance exceeding one thousand dollars.</p>
<tr><td valign=top>4.</td><td>&nbsp;</td><td>
all unassigned account numbers.</p>
</table>

<p>The ledger may be described by a matrix</p>

<table><tr>
<td>&nbsp; &nbsp; &nbsp; <b><i>L</i></b> =
(<b><i>L</i></b><sub>1</sub>,<b><i>L</i></b><sub>2</sub>,<b><i>L</i></b><sub>3</sub>) 
&nbsp;=&nbsp;</td>
<td><img src="APLimg/matrixl1x9c.bmp"></td>
<td><p align=center><b><i>L</i></b><sup>1</sup><br>.<br>.<br>.<br><b><i>L</i></b><sup><i>m</i></sup></p></td>
<td><img src="APLimg/matrixr1x9c.bmp"></td>
</tr></table>

<p>with column vectors <b><i>L</i></b><sub>1</sub>, 
<b><i>L</i></b><sub>2</sub>, and <b><i>L</i></b><sub>3</sub>,
representing names, account numbers,
and balances, respectively, and with row vectors
<b><i>L</i></b><sup>1</sup>, <b><i>L</i></b><sup>2</sup>, &#133;,
<b><i>L</i></b><sup><i>m</i></sup>, representing
individual accounts.
An unassigned account number is identified by the word
&ldquo;none&rdquo; in the name position.
The four output lists will be denoted
by the matrices <b><i>P</i></b>, <b><i>Q</i></b>,
<b><i>R</i></b>, and <b><i>S</i></b>, respectively.
They can be produced by Program 1.9.</p>
</td><td>&nbsp;</td></tr></table>
<br>

<table><tr><td valign=top><img src="APLimg/prog1x9.bmp"></td><td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td><td>
<table border=1 cellspacing=0 cellpadding=0><tr><td><table>
<tr><td valign=top><b><i>L</i></b></td><td>&nbsp;</td>
 <td>Bank ledger.</td></tr>
<tr><td valign=top><b><i>L</i></b><sup><i>k</i></sup></td><td>&nbsp;</td>
 <td><i>k</i>th account.<sup>&nbsp;</sup></td></tr>
<tr><td valign=top><b><i>L</i></b><sub>3</sub><sup><i>k</i></sup></td><td>&nbsp;</td>
 <td>Balance of <i>k</i>th account.<sub>&nbsp;</sub><sup>&nbsp;</sup></td></tr>
<tr><td valign=top><b><i>L</i></b><sub>2</sub><sup><i>k</i></sup></td><td>&nbsp;</td>
 <td>Account number of <i>k</i>th <sub>&nbsp;</sub><sup>&nbsp;</sup> account.</td></tr>
<tr><td valign=top><b><i>L</i></b><sub>1</sub><sup><i>k</i></sup></td><td>&nbsp;</td>
 <td>Name of <i>k</i>th account or &ldquo;none&rdquo;
if account number <b><i>L</i></b><sub>2</sub><sup><i>k</i></sup> unused.</td></tr>
</table></td></tr></table>
<p align=center><b>Legend</b></p></td></tr>
</table>

<p align=center><b>Program 1.9&nbsp;</b> Selection on bank ledger <b><i>L</i></b> (Example 1.1)</p>

<table><tr><td>&nbsp;</td><td>
<p><b>Program 1.9</b>. Since <b><i>L</i></b><sub>3</sub>
is the vector of balances, and 2<tt><b>∊</b></tt>
is a compatible vector each of whose components equals two,
the relational statement 
(<b><i>L</i></b><sub>3</sub> &lt; 2<tt><b>∊</b></tt>)
defines a logical vector having unit components
corresponding to those accounts to be included
in the list <b><i>P</i></b>.
Consequently, the column compression of step 1 selects
the appropriate rows of <b><i>L</i></b> to define <b><i>P</i></b>.
Step 2 is similar, but step 3 incorporates 
an additional row  compression by the compatible prefix
vector <tt><b>⍺</b></tt>&sup2; = (1,1,0) to
select columns one and two of <b><i>L</i></b>.
Step 4 represents the comparison of the name
(in column <b><i>L</i></b><sub>1</sub>)
with the literal &ldquo;none&rdquo;,
the selection of each row which shows agreement,
and the suppression of all columns but the second.
The expression &ldquo;none <tt><b>∊</b></tt>&rdquo;
occurring in step 4 illustrates the use 
of the extended definition of multiplication.</p>
</td><td>&nbsp;</td></tr></table>



<a name="1.9.2"></a>
<p><b>Mesh, mask, and expansion</b></p>

<p>A logical vector <b><i>u</i></b> 
and the two vectors 
<b><i>a</i></b> = 
<img src="APLimg/uboscore.bmp">/<b><i>c</i></b> and
<b><i>b</i></b> = <b><i>u</i></b>/<b><i>c</i></b>,
obtained by compressing a vector <b><i>c</i></b>,
collectively determine the vector <b><i>c</i></b>.
The operation which specifies <b><i>c</i></b>
as a function of <b><i>a</i></b>, <b><i>b</i></b>, and
<b><i>u</i></b> is called a <i>mesh</i>
and is defined as follows:
If <b><i>a</i></b> and <b><i>b</i></b> are
arbitrary vectors and if <b><i>u</i></b>
is a logical vector such that +/<img src="APLimg/uboscore.bmp">
= <i>&nu;</i>(<b><i>a</i></b>) and +/<b><i>u</i></b> 
= <i>&nu;</i>(<b><i>b</i></b>), then the <i>mesh of</i>
<b><i>a</i></b> <i>and</i> <b><i>b</i></b> <i>on</i>
<b><i>u</i></b> is denoted by 
<nobr>\<b><i>a</i></b>, <b><i>u</i></b>, <b><i>b</i></b>\</nobr>
and is defined as the vector <b><i>c</i></b>
such that <img src="APLimg/uboscore.bmp">/<b><i>c</i></b>
= <b><i>a</i></b> and <b><i>u</i></b>/<b><i>c</i></b> 
= <b><i>b</i></b>.
The mesh operation is equivalent to choosing successive
components of <b><i>c</i></b> from <b><i>a</i></b>
or <b><i>b</i></b> according as the successive components
of <b><i>u</i></b> are 0 or 1.
If, for example, <b><i>a</i></b> = <nobr>(s, e, k),</nobr>
<b><i>b</i></b> = <nobr>(t, a),</nobr> and 
<b><i>u</i></b> = <nobr>(0, 1, 0, 1, 0),</nobr> then
<nobr>\<b><i>a</i></b>, <b><i>u</i></b>, <b><i>b</i></b>\ =</nobr>
<nobr>(s, t, e, a, k).</nobr>  As a further example, </p>

<table>
<tr><td align=center rowspan=2><img src="APLimg/prog1x10a.bmp"><br>(a)</td>
 <td nowrap rowspan=2>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
 <td align=center><img src="APLimg/prog1x10b.bmp"><br>(b)<br><br></td></tr>
<tr><td><table border=1 cellspacing=0 cellpadding=8><tr><td>
<table>
<tr><td><b><i>a</i></b>, <b><i>b</i></b></td><td>&nbsp;</td><td>Given vectors.</td></tr>
<tr><td><b><i>c</i></b></td><td>&nbsp;</td><td><b><i>c</i></b> = 
(<b><i>a</i></b><sub>1</sub>, <b><i>b</i></b><sub>1</sub>, <b><i>b</i></b><sub>2</sub>, 
<b><i>a</i></b><sub>2</sub>, <b><i>b</i></b><sub>3</sub>, <b><i>b</i></b><sub>4</sub>, &#133;) &nbsp;</td></tr>
<tr><td><i>i</i></td><td>&nbsp;</td><td>Index of <b><i>a</i></b>.</td></tr>
<tr><td><i>j</i></td><td>&nbsp;</td><td>Index of <b><i>b</i></b>.</td></tr>
<tr><td><i>k</i></td><td>&nbsp;</td><td>Index of <b><i>c</i></b>.</td></tr>
<tr><td><i>u</i></td><td>&nbsp;</td><td><b><i>a</i></b> = (0, 1, 1, 0, 1, 1, 0, &#133;).</td></tr>
</table></td></tr>
</table><p align=center><b>Legend</b></p></td></tr>
</table>

<p align=center><b>Program 1.10&nbsp;</b> Interfiling program</p>

<p>Program 1.10a (which describes the merging of
the vectors <b><i>a</i></b> and <b><i>b</i></b>,
with the first and every third component thereafter
chosen from <b><i>a</i></b>) can be described
alternatively as shown in Program 1.10b.
Since <tt><b>⍳</b></tt><sup>1</sup> = 
<nobr>(1, 2, 3, 4, 5, 6, &#133;),</nobr>
then 
<nobr>(3<tt><b>∊</b></tt>) |<sub>0</sub> <tt><b>⍳</b></tt><sup>1</sup></nobr>
= <nobr>(1, 2, 0, 1, 2, 0, &#133;),</nobr> and consequently
the vector <b><i>u</i></b> specified by step 1
is of the form <b><i>u</i></b> = <nobr>(0, 1, 1, 0, 1, 1, 0, &#133;).</nobr></p>

<p>Mesh operations on matrices are defined analogously,
row mesh and column mesh being denoted by single
and double reverse virgules, respectively.</p>

<a name="catenation"></a>
<p>The <i>catenation</i> of vectors 
<nobr><b><i>x</i></b>, <b><i>y</i></b>, 
&#133;, <b><i>z</i></b></nobr> 
is denoted by
<nobr><b><i>x</i></b> <img src="APLimg/circleplus.bmp"> 
<b><i>y</i></b> <img src="APLimg/circleplus.bmp"> &#133; 
<img src="APLimg/circleplus.bmp"> <b><i>z</i></b></nobr>
and is defined by the relation</p>

<p>&nbsp; &nbsp; &nbsp; 
<b><i>x</i></b> <img src="APLimg/circleplus.bmp">
<b><i>y</i></b> <img src="APLimg/circleplus.bmp"> &#133;
<img src="APLimg/circleplus.bmp"> <b><i>z</i></b> &nbsp;=&nbsp;
(<b><i>x</i></b><sub>1</sub>, <b><i>x</i></b><sub>2</sub>, &#133;,
<b><i>x</i></b><sub><i>&nu;</i>(<b><i>x</i></b>)</sub>,
<b><i>y</i></b><sub>1</sub>, <b><i>y</i></b><sub>2</sub>, &#133;,
<b><i>z</i></b><sub><i>&nu;</i>(<b><i>z</i></b>)</sub>).</p>

<p>Catenation is clearly associative and
for two vectors <b><i>x</i></b> and <b><i>y</i></b>
it is a special case of the mesh 
\<b><i>x</i></b>, <b><i>u</i></b>, <b><i>y</i></b>\
in which <b><i>u</i></b> is a suffix vector.</p>

<p>In numerical vectors (for which addition of two vectors
is defined), the effect of the general mesh operation
can be produced as the sum of two meshes,
each involving one zero vector.  Specifically,</p>

<table>
<tr><td>&nbsp; &nbsp; &nbsp; \<b><i>x</i></b>, <b><i>u</i></b>, <b><i>y</i></b>\</td>
 <td>&nbsp;=&nbsp;</td><td> \<b><i>x</i></b>, <b><i>u</i></b>, 0\ + 
\0, <b><i>u</i></b>, <b><i>y</i></b>\</td></tr>
<tr><td>&nbsp;</td>
 <td>&nbsp;=&nbsp;</td><td> \0, <img src="APLimg/uboscore.bmp">, <b><i>x</i></b>\ + 
\0, <b><i>u</i></b>, <b><i>y</i></b>\.</td></tr>
</table>

<a name="expansion"></a>
<p>The operation \0, <b><i>u</i></b>, <b><i>y</i></b>\ 
proves very useful in numerical work and will be called
<i>expansion</i> of the vector <b><i>y</i></b>,
denoted by <b><i>u</i></b>\<b><i>y</i></b>.
Compression of <b><i>u</i></b>\<b><i>y</i></b>
by <b><i>u</i></b> and by <img src="APLimg/uboscore.bmp">
clearly yields <b><i>y</i></b> and 0, respectively.
Moreover, any numerical vector <b><i>x</i></b>
can be <i>decomposed</i> by a compatible vector
<b><i>u</i></b> according to the relation</p>

<p>&nbsp; &nbsp; &nbsp; <b><i>x</i></b> =
<img src="APLimg/uboscore.bmp">\<img src="APLimg/uboscore.bmp">/<b><i>x</i></b> +
<b><i>u</i></b>\<b><i>u</i></b>/<b><i>x</i></b>.</p>

<p>The two terms are vectors of the same dimension
which have no nonzero components in common.
Thus if <b><i>u</i></b> = (1,&nbsp;0,&nbsp;1,&nbsp;0,&nbsp;1),
the decomposition of <b><i>x</i></b> appears as</p>

<p>&nbsp; &nbsp; &nbsp; <b><i>x</i></b> = 
(0, <b><i>x</i></b><sub>2</sub>, 0, <b><i>x</i></b><sub>4</sub>, 0) +
(<b><i>x</i></b><sub>1</sub>, 0, <b><i>x</i></b><sub>3</sub>, 0, <b><i>x</i></b><sub>5</sub>).</p>

<a name="expand_row"></a>
<a name="expand_col"></a>
<p>Row expansion and column expansion of matrices
are defined and denoted analogously. 
The decomposition relations become</p>

<p>&nbsp; &nbsp; &nbsp; 
<b><i>X</i></b> = 
<img src="APLimg/uboscore.bmp">\<img src="APLimg/uboscore.bmp">/<b><i>X</i></b> +
<b><i>u</i></b>\<b><i>u</i></b>/<b><i>X</i></b>,<br>
and<br>&nbsp; &nbsp; &nbsp; 
<b><i>X</i></b> = 
<img src="APLimg/uboscore.bmp">\\<img src="APLimg/uboscore.bmp">//<b><i>X</i></b> +
<b><i>u</i></b>\\<b><i>u</i></b>//<b><i>X</i></b>.</p>

<a name="mask"></a>
<p>The <i>mask</i> operation is defined formally as follows:</p>

<p>&nbsp; &nbsp; &nbsp; <b><i>c</i></b> &larr; 
/<b><i>a</i></b>, <b><i>u</i></b>, <b><i>b</i></b>/ &nbsp;&harr;&nbsp;
<img src="APLimg/uboscore.bmp">/<b><i>c</i></b> = 
<img src="APLimg/uboscore.bmp">/<b><i>a</i></b>, and
<b><i>u</i></b>/<b><i>c</i></b> = <b><i>u</i></b>/<b><i>b</i></b>.</p>

<p>The vectors <b><i>c</i></b>, <b><i>a</i></b>, <b><i>u</i></b>, and
<b><i>b</i></b> are clearly of a common dimension and
<b><i>c</i></b><sub><i>i</i></sub> = <b><i>a</i></b><sub><i>i</i></sub>
or <b><i>b</i></b><sub><i>i</i></sub> according as
<b><i>u</i></b><sub><i>i</i></sub> = 0 or 
<b><i>u</i></b><sub><i>i</i></sub> = 1.
Moreover, the compress, expand, mask, and mesh operations
on vectors are related as follows:</p>

<table>
<tr><td>&nbsp; &nbsp; &nbsp; /<b><i>a</i></b>, <b><i>u</i></b>, <b><i>b</i></b>/</td>
 <td>&nbsp;=&nbsp;</td>
 <td>\<img src="APLimg/uboscore.bmp">/<b><i>a</i></b>,
 <b><i>u</i></b>, <b><i>u</i></b>/<b><i>b</i></b>\,</td></tr>
<tr><td>&nbsp; &nbsp; &nbsp; \<b><i>a</i></b>, <b><i>u</i></b>, <b><i>b</i></b>\</td>
<td>&nbsp;=&nbsp;</td>
 <td>/<img src="APLimg/uboscore.bmp">\<b><i>a</i></b>,
 <b><i>u</i></b>, <b><i>u</i></b>\<b><i>b</i></b>/.</td></tr>
</table>
 
<p>Analogous relations hold for the row mask
and row mesh and for the column mask and column mesh.</p>

<p>Certain selection operations are controlled
by logical matrices rather than by logical vectors.
<a name="compress_rowrow"></a>
The <i>row compression</i> <b><i>U</i></b>/<b><i>A</i></b>
selects elements of <b><i>A</i></b> corresponding
to the nonzero elements of <b><i>U</i></b>.
Since the nonzero elements of <b><i>U</i></b>
may occur in an arbitrary pattern, 
the result must be construed as a vector 
rather than a matrix.
More precisely, <b><i>U</i></b>/<b><i>A</i></b>
denotes the catenation of the vectors
<b><i>U</i></b><sup><i>&nbsp;i</i></sup>/<b><i>A</i></b><sup><i>i</i></sup>
obtained by row-by-row compression
of <b><i>A</i></b> by <b><i>U</i></b>.
<a name="compress_colcol"></a>
The <i>column compression</i> <b><i>U</i></b>//<b><i>A</i></b>
denotes the catenation of the vectors
<b><i>U</i></b><sub><i>j</i></sub>/<b><i>A</i></b><sub><i>j</i></sub>.
If, for example</p>

<table>
<tr><td rowspan=3>&nbsp; &nbsp; &nbsp;<b><i>U</i></b> = </td>
    <td rowspan=3><img src="APLimg/matrixl3.bmp"></td>
    <td><sup>&nbsp;</sup>0 &nbsp; 1 &nbsp; 0 &nbsp; 1 &nbsp; 1<sub>&nbsp;</sub></td>
    <td rowspan=3><img src="APLimg/matrixr3.bmp"></td></tr>
<tr><td><sup>&nbsp;</sup>1 &nbsp; 1 &nbsp; 0 &nbsp; 0 &nbsp; 0<sub>&nbsp;</sub></td></tr>
<tr><td><sup>&nbsp;</sup>0 &nbsp; 1 &nbsp; 1 &nbsp; 0 &nbsp; 0<sub>&nbsp;</sub></td></tr>
</table>

<p>
then<br>
&nbsp; &nbsp; &nbsp; <b><i>U</i></b>/<b><i>A</i></b> =
(<b><i>A</i></b><sub>2</sub><sup>1</sup>, 
<b><i>A</i></b><sub>4</sub><sup>1</sup>, 
<b><i>A</i></b><sub>5</sub><sup>1</sup>, 
<b><i>A</i></b><sub>1</sub><sup>2</sup>, 
<b><i>A</i></b><sub>2</sub><sup>2</sup>, 
<b><i>A</i></b><sub>2</sub><sup>3</sup>, 
<b><i>A</i></b><sub>3</sub><sup>3</sup>),<br>
and<br>
&nbsp; &nbsp; &nbsp; <b><i>U</i></b>//<b><i>A</i></b> =
(<b><i>A</i></b><sub>1</sub><sup>2</sup>,
<b><i>A</i></b><sub>2</sub><sup>1</sup>,
<b><i>A</i></b><sub>2</sub><sup>2</sup>,
<b><i>A</i></b><sub>2</sub><sup>3</sup>,
<b><i>A</i></b><sub>3</sub><sup>3</sup>,
<b><i>A</i></b><sub>4</sub><sup>1</sup>,
<b><i>A</i></b><sub>5</sub><sup>1</sup>).</p>

<p>Compression by the full matrix <font face=Arial><b><i>E</i></b></font>
(defined by <img src="APLimg/ecapboscore.bmp"> = 0)
produces either a <i>row list</i> 
(<font face=Arial><b><i>E</i></b></font>/<b><i>A</i></b>)
or a <i>column list</i>
(<font face=Arial><b><i>E</i></b></font>//<b><i>A</i></b>)
of the matrix <b><i>A</i></b>.
Moreover, a numerical matrix <b><i>X</i></b>
can be represented jointly by the logical matrix
<b><i>U</i></b> and the row list 
<b><i>U</i></b>/<b><i>X</i></b>
(or the column list <b><i>U</i></b>//<b><i>X</i></b>),
where <b><i>U</i></b> = (<b><i>X</i></b> &ne; 0).
If the matrix <b><i>X</i></b> is sparse
(i.e., the components are predominantly zero),
this provides a compact representation 
which may reduce the computer storage
required for <b><i>X</i></b>.</p>

<p>The compression operations controlled
by matrices also generate a group of
corresponding mesh and mask operations
as shown in Sec. S.9.
<br>&nbsp;</p>



<a name="1.10"></a>
<p><b>1.10 Selection vectors</b></p>

<p>The logical vector <b><i>u</i></b> involved
in selection operations may itself arise in various ways.
It may be a prefix vector 
<tt><b>⍺</b></tt><sup><i>&nbsp;j</i></sup>,
a suffix
<tt><b>⍵</b></tt><sup><i>&nbsp;j</i></sup>,
or an infix 
(<i>i</i> &darr; <tt><b>⍺</b></tt><sup><i>&nbsp;j</i></sup>);
the corresponding compressed vectors
<tt><b>⍺</b></tt><sup><i>&nbsp;j</i></sup>/<b><i>x</i></b>,
<tt><b>⍵</b></tt><sup><i>&nbsp;j</i></sup>/<b><i>x</i></b>, and
(<i>i</i> &darr; <tt><b>⍺</b></tt><sup><i>&nbsp;j</i></sup>)/<b><i>x</i></b>
are called a <i>prefix</i>, <i>suffix</i>,
and <i>infix</i> of <b><i>x</i></b>, respectively.</p>

<p>Certain selection vectors arise as functions
of other vectors, e.g., the vector 
(<b><i>x</i></b>&nbsp;&ge;&nbsp;0) can be used
to select all nonnegative components of <b><i>x</i></b>,
and (<b><i>b</i></b>&nbsp;&ne;&nbsp;*<tt><b>∊</b></tt>)
serves to select all components of <b><i>b</i></b>
which are not equal to the literal &ldquo;*&rdquo;.
Two further types are important:
the selection of the longest unbroken prefix
(or suffix) of a given logical vector,
and the selection of the set of distinct
components occurring in a vector.
The first is useful in left (or right)
justification or in a corresponding compression
intended to eliminate leading or trailing
&ldquo;filler components&rdquo; of a vector
(such as left zeros in a number or right spaces
in a short name).</p>

<a name="maximum_prefix"></a>
<p>For any logical vector <i>u</i>,
the <i>maximum prefix</i> of <b><i>u</i></b>
is denoted by <tt>⍺</tt>/<b><i>u</i></b>
and defined as follows:</p>

<p>&nbsp; &nbsp; &nbsp; <b><i>u</i></b> &larr; <tt>⍺</tt>/<b><i>u</i></b> 
&nbsp;&harr;&nbsp; <b><i>v</i></b> = <tt><b>⍺</b></tt><sup><i>&nbsp;j</i></sup></p>

<p>where <i>j</i> is the maximum value for which
&and;/(<tt><b>⍺</b></tt><sup><i>&nbsp;j</i></sup>/<b><i>u</i></b>) = 1.
<a name="maximum_suffix"></a>
The maximum suffix is denoted by <tt>⍵</tt>/<b><i>u</i></b>
and is defined analogously.
If, for example, <b><i>u</i></b> = (1,&nbsp;1,&nbsp;1,&nbsp;0,&nbsp;1,&nbsp;1,&nbsp;0,&nbsp;0,&nbsp;1,&nbsp;1),
then <tt>⍺</tt>/<b><i>u</i></b> = (1,&nbsp;1,&nbsp;1,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0),
<tt>⍵</tt>/<b><i>u</i></b> = (0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;1,&nbsp;1),
+/<tt>⍺</tt>/<b><i>u</i></b> = 3, and 
+/<tt>⍵</tt>/<b><i>u</i></b> = 2.</p>

<p>The leading zeros of a numerical vector <i>x</i>
can clearly be removed either by compression:</p>

<p>&nbsp; &nbsp; &nbsp; <img src="APLimg/exp1x10.bmp"></p>

<p>or by left justification (normalization):</p>

<p>&nbsp; &nbsp; &nbsp; <b><i>z</i></b> &larr; (+/<tt>⍺</tt>/(<b><i>x</i></b> = 0)) 
&uarr; <b><i>x</i></b>.</p>

<a name="prefix_row"></a>
<a name="prefix_col"></a>
<p>The extension of the maximum prefix operation
to the rows of a logical matrix <b><i>U</i></b>
is denoted by <tt>⍺</tt>/<b><i>U</i></b> 
and defined as the compatible logical matrix
<b><i>V</i></b>, such that 
<b><i>V</i></b><sup><i>&nbsp;i</i></sup> 
= <tt>⍺</tt>/<b><i>U</i></b><sup><i>&nbsp;i</i></sup>.
The corresponding maximum column prefix operation
is denoted by <tt>⍺</tt>//<b><i>U</i></b>.
Right justification of a numerical matrix
<b><i>X</i></b> is achieved by the rotation
<b><i>k</i></b> &darr; <b><i>X</i></b>, 
where <b><i>k</i></b> = +/<tt>⍵</tt>/(<b><i>X</i></b> = 0),
and <i>top justification</i> is achieved
by the rotation 
((+//<tt>⍺</tt>//(<b><i>X</i></b> = 0) 
<img src="APLimg/uarr.bmp"> <b><i>X</i></b>
(see Sec. S.6.)</p>

<a name="forward_set_selector"></a>
<p>A vector whose components are all distinct
will be called an <i>ordered set</i>.
The <i>forward set selector</i> on <b><i>b</i></b>
is a logical vector denoted by <i>&sigma;</i>/<b><i>b</i></b>
and defined as follows:
the statement <b><i>v</i></b> &larr; <i>&sigma;</i>/<b><i>b</i></b>
implies that <b><i>v</i></b><sub><i>j</i></sub> = 1
if and only if <b><i>b</i></b><sub><i>j</i></sub>
differs from all preceding components of <b><i>b</i></b>.
Hence <b><i>v</i></b>/<b><i>b</i></b> is a set
which contains all distinct components of <b><i>b</i></b>,
and +/<b><i>v</i></b>/<tt><b>⍳</b></tt>
is a minimum.
For example, if <b><i>c</i></b> = (C,&nbsp;a,&nbsp;n,&nbsp;a,&nbsp;d,&nbsp;a),
then (<i>&sigma;</i>/<b><i>c</i></b>)/<b><i>c</i></b> =
(C,&nbsp;a,&nbsp;n,&nbsp;d) is a list of the distinct letters 
in <b><i>c</i></b> in order of occurrence.
Clearly (<i>&sigma;</i>/<b><i>b</i></b>)/<b><i>b</i></b> = <b><i>b</i></b>
if and only if <b><i>b</i></b> is a set.</p>

<a name="backward_set_selector"></a>
<p>The backward set selector <i>&tau;</i>/<b><i>b</i></b>
is defined analogously
(e.g., (<i>&tau;</i>/<b><i>c</i></b>)/<b><i>c</i></b> = 
<nobr>(C, n, d, a)).</nobr>
<a name="set_selector_row"></a>
<a name="set_selector_col"></a>
Forward and backward set selection are extended
to matrices by both 
rows (<i>&sigma;</i>/<b><i>B</i></b>, and <i>&tau;</i>/<b><i>B</i></b>) and 
columns (<i>&sigma;</i>//<b><i>B</i></b>, and <i>&tau;</i>//<b><i>B</i></b>)
in the established manner.
<br>&nbsp;</p>



<a name="1.11"></a>
<p><b>1.11 The generalized matrix product</b></p>

<p>The ordinary matrix product of matrices <b><i>X</i></b>
and <b><i>Y</i></b> is commonly denoted by
<b><i>XY</i></b> and defined as follows:</p>

<table>
<tr><td>&nbsp; &nbsp; &nbsp;</td><td>
<b><i>Z</i></b> &larr; <b><i>XY</i></b> &nbsp;&harr;&nbsp;
<b><i>Z</i></b><sub><i>&nbsp;j</i></sub><sup><i>&nbsp;i</i></sup> =
<img align=middle src="APLimg/sigma1x11.bmp">  
<b><i>X</i></b><sub><i>k</i></sub><sup><i>i</i></sup>
&times;
<b><i>Y</i></b><sub><i>j</i></sub><sup><i>k</i></sup>, &nbsp; </td>
<td><img src="APLimg/bracket1x11.bmp"></td>
<td><i>i</i> = 1, 2, &#133;, <i>&mu;</i>(<b><i>X</i></b>)<br>
<i>j</i> = 1, 2, &#133;, <i>&nu;</i>(<b><i>Y</i></b>).</td></tr>
</table>

It can be defined alternatively as follows:

<p>&nbsp; &nbsp; &nbsp; (<b><i>XY</i></b>)<sub><i>j</i></sub><sup><i>&nbsp;i</i></sup>
= +/(<b><i>X</i></b><sup><i>&nbsp;i</i></sup> &times; 
<b><i>Y</i></b><sub><i>j</i></sub>).
</p>

<p>This formulation emphasizes the fact that 
matrix multiplication incorporates two elementary operations
(+, &times;) and suggests that they be displayed explicitly.
The ordinary matrix product will therefore be written as
<b><i>X</i></b> <img src="APLimg/plustimes.bmp"> <b><i>Y</i></b>.</p>

<p>More generally, if <img src="APLimg/circledot.bmp"><sub>1</sub>
and <img src="APLimg/circledot.bmp"><sub>2</sub>
are any two operators
(whose domains include the relevant operands),
then the <i>generalized matrix product</i>
<img align=middle src="APLimg/gmp.bmp"> is defined as follows:</p>

<table>
<tr><td><p>&nbsp; &nbsp; &nbsp; 
(<img align=middle src="APLimg/gmp.bmp">)<sub><i>j</i></sub><sup><i>i</i></sup>
&nbsp;=&nbsp;
<img src="APLimg/circledot.bmp"><sub>1</sub>/(<b><i>X</i></b><sup><i>&nbsp;i</i></sup>
<img src="APLimg/circledot.bmp"><sub>2</sub> <b><i>Y</i></b><sub><i>j</i></sub>), &nbsp; </td>
<td><img src="APLimg/bracket1x11.bmp"></td>
<td><i>i</i> = 1, 2, &#133;, <i>&mu;</i>(<b><i>X</i></b>)<br>
<i>j</i> = 1, 2, &#133;, <i>&nu;</i>(<b><i>Y</i></b>).</td></tr>
</table>

For example, if

<table>
<tr><td>&nbsp; &nbsp; &nbsp;</td><td><table>
 <td rowspan=3><b><i>A</i></b> &nbsp;=&nbsp;</td>
 <td rowspan=3><img src="APLimg/matrixl3.bmp"></td></td>
 <td><sup>&nbsp;</sup>1 &nbsp; 3 &nbsp; 2 &nbsp; 0<sub>&nbsp;</sub></td>
 <td rowspan=3><img src="APLimg/matrixr3.bmp"></td></td></tr>
<tr><td><sup>&nbsp;</sup>2 &nbsp; 1 &nbsp; 0 &nbsp; 1<sub>&nbsp;</sub></td></tr>
<tr><td><sup>&nbsp;</sup>4 &nbsp; 0 &nbsp; 0 &nbsp; 2<sub>&nbsp;</sub></td></tr>
</table></td><td>&nbsp; &nbsp; and &nbsp; &nbsp;</td><td><table>
 <td rowspan=4><b><i>B</i></b> &nbsp;=&nbsp;</td>
 <td rowspan=4><img src="APLimg/matrixl4.bmp"></td></td>
 <td><sup>&nbsp;</sup>4 &nbsp; 1<sub>&nbsp;</sub></td>
 <td rowspan=4><img src="APLimg/matrixr4.bmp"></td></td></tr>
<tr><td><sup>&nbsp;</sup>0 &nbsp; 3<sub>&nbsp;</sub></td></tr>
<tr><td><sup>&nbsp;</sup>0 &nbsp; 2<sub>&nbsp;</sub></td></tr>
<tr><td><sup>&nbsp;</sup>2 &nbsp; 0<sub>&nbsp;</sub></td></tr>
</table></td></tr>
</table>

then

<table>
<tr><td>&nbsp; &nbsp; &nbsp;</td><td><table>
 <td rowspan=3><b><i>A</i></b> <img src="APLimg/plustimes.bmp"> <b><i>B</i></b> &nbsp;=&nbsp;</td>
 <td rowspan=3><img src="APLimg/matrixl3.bmp"></td></td>
 <td align=right><sup>&nbsp;</sup>4 &nbsp; 14<sub>&nbsp;</sub></td>
 <td rowspan=3><img src="APLimg/matrixr3.bmp"></td></td>
 <td rowspan=3>,</td></tr>
<tr><td align=right><sup>&nbsp;</sup>10 &nbsp; &nbsp;5<sub>&nbsp;</sub></td></tr>
<tr><td align=right><sup>&nbsp;</sup>20 &nbsp; &nbsp;4<sub>&nbsp;</sub></td></tr>
</table></td><td>&nbsp; &nbsp; &nbsp; &nbsp;</td><td><table>
 <td rowspan=3><b><i>A</i></b> <img src="APLimg/andeq.bmp"> <b><i>B</i></b> &nbsp;=&nbsp;</td>
 <td rowspan=3><img src="APLimg/matrixl3.bmp"></td></td>
 <td><sup>&nbsp;</sup>0 &nbsp; 1<sub>&nbsp;</sub></td>
 <td rowspan=3><img src="APLimg/matrixr3.bmp"></td></td>
 <td rowspan=3>,</td></tr>
<tr><td><sup>&nbsp;</sup>0 &nbsp; 0<sub>&nbsp;</sub></td></tr>
<tr><td><sup>&nbsp;</sup>1 &nbsp; 0<sub>&nbsp;</sub></td></tr>
</table></td></tr>
</table>

<table>
<tr><td>&nbsp; &nbsp; &nbsp;</td><td><table>
 <td rowspan=3><b><i>A</i></b> <img src="APLimg/orne.bmp"> <b><i>B</i></b> &nbsp;=&nbsp;</td>
 <td rowspan=3><img src="APLimg/matrixl3.bmp"></td></td>
 <td align=right><sup>&nbsp;</sup>1 &nbsp; 0<sub>&nbsp;</sub></td>
 <td rowspan=3><img src="APLimg/matrixr3.bmp"></td></td>
 <td rowspan=3>, &nbsp; &nbsp; and</td></tr>
<tr><td align=right><sup>&nbsp;</sup>1 &nbsp; 1<sub>&nbsp;</sub></td></tr>
<tr><td align=right><sup>&nbsp;</sup>0 &nbsp; 1<sub>&nbsp;</sub></td></tr>
</table></td><td>&nbsp; &nbsp;</td><td><table>
 <td rowspan=3>(<b><i>A</i></b> &ne; 0) <img src="APLimg/plusslash.bmp"> <b><i>B</i></b> &nbsp;=&nbsp;</td>
 <td rowspan=3><img src="APLimg/matrixl3.bmp"></td></td>
 <td><sup>&nbsp;</sup>4 &nbsp; 6<sub>&nbsp;</sub></td>
 <td rowspan=3><img src="APLimg/matrixr3.bmp"></td></td>
 <td rowspan=3>.</td></tr>
<tr><td><sup>&nbsp;</sup>6 &nbsp; 4<sub>&nbsp;</sub></td></tr>
<tr><td><sup>&nbsp;</sup>6 &nbsp; 1<sub>&nbsp;</sub></td></tr>
</table></td></tr>
</table>

<p>The generalized matrix product and the selection operations
together provide an elegant formulation in several established
areas of mathematics.  A few examples will be chosen
from two such areas, symbolic logic and matrix algebra.</p>

<p>In symbolic logic, De Morgan&rsquo;s laws 
(&and;/<b><i>u</i></b> = <img src="APLimg/ex1x10a.bmp"> and
=/<b><i>u</i></b> = <img src="APLimg/demorgan.bmp">)
can be applied directly to show that</p>

<p>&nbsp; &nbsp; &nbsp; <b><i>U</i></b> <img src="APLimg/neand.bmp"> <b><i>V</i></b>
= <img src="APLimg/ex1x10f.bmp">.</p>

<p>In matrix algebra, the notion of partitioning a matrix
into submatrices of contiguous rows and columns
can be generalized to an arbitrary partitioning 
specified by a logical vector <b><i>u</i></b>.
The following easily verifiable identities are
typical of the useful relations which result:</p>

<table>
<tr><td>&nbsp; &nbsp; &nbsp;</td>
 <td align=right><b><i>X</i></b> <img src="APLimg/plustimes.bmp"> <b><i>Y</i></b></td>
 <td>&nbsp;</td><td>=</td><td>&nbsp;</td>
 <td>(<img src="APLimg/uboscore.bmp">/<b><i>X</i></b>) <img src="APLimg/plustimes.bmp">
 (<img src="APLimg/uboscore.bmp">//<b><i>Y</i></b>) +
 (<b><i>u</i></b>/<b><i>X</i></b>) <img src="APLimg/plustimes.bmp">
 (<b><i>u</i></b>//<b><i>Y</i></b>),
 </tr>
<tr><td>&nbsp;</td>
 <td align=right><b><i>u</i></b>/(<b><i>X</i></b> <img src="APLimg/plustimes.bmp"> <b><i>Y</i></b>)</td>
 <td>&nbsp;</td><td>=</td><td>&nbsp;</td>
 <td><b><i>X</i></b> <img src="APLimg/plustimes.bmp"> (<b><i>u</i></b>/<b><i>Y</i></b>),</td>
 </tr>
<tr><td>&nbsp;</td>
 <td align=right><b><i>u</i></b>//(<b><i>X</i></b> <img src="APLimg/plustimes.bmp"> <b><i>Y</i></b>)</td>
 <td>&nbsp;</td><td>=</td><td>&nbsp;</td>
 <td>(<b><i>u</i></b>//<b><i>X</i></b>) <img src="APLimg/plustimes.bmp"> <b><i>Y</i></b>.</td>
 </tr>
</table>

<p>The first identity depends on the commutativity
and associativity of the operator +
and can clearly be generalized to other associative
commutative operators, such as &and;, &or;,
and &ne;.</p>

<a name="gmp_mv"></a>
<a name="gmp_vm"></a>
<a name="gmp_vv"></a>
<p>The generalized matrix product applies directly 
(as does the ordinary matrix product
<b><i>X</i></b> <img src="APLimg/plustimes.bmp"> <b><i>Y</i></b>)
to vectors considered as row (that is, 1 &times; <i>n</i>)
or as column matrices. Thus:</p>

<table>
<tr><td>&nbsp; &nbsp; &nbsp;</td>
 <td><b><i>z</i></b> &larr; <b><i>X</i></b> <img src="APLimg/circle1circle2.bmp"> <b><i>y</i></b></td>
 <td>&nbsp; &harr; &nbsp;</td>
 <td><b><i>z</i></b><sub><i>&nbsp;i</i></sub></td><td>=</td><td>
 <img src="APLimg/circledot.bmp"><sub>1</sub>/(<b><i>X</i></b><sup><i>&nbsp;i</i></sup>
 <img src="APLimg/circledot.bmp"><sub>2</sub> <b><i>y</i></b>),</td>
 </tr>
<tr><td>&nbsp;</td>
 <td><b><i>z</i></b> &larr; <b><i>y</i></b> <img src="APLimg/circle1circle2.bmp"> <b><i>X</i></b></td>
 <td>&nbsp; &harr; &nbsp;</td>
 <td><b><i>z</i></b><sub><i>&nbsp;j</i></sub></td><td>=</td><td>
 <img src="APLimg/circledot.bmp"><sub>1</sub>/(<b><i>y</i></b>
 <img src="APLimg/circledot.bmp"><sub>2</sub> <b><i>X</i></b><sub><i>j&nbsp;</i></sup>),</td>
 </tr>
<tr><td>&nbsp;</td>
 <td><b><i>z</i></b> &larr; <b><i>y</i></b> <img src="APLimg/circle1circle2.bmp"> <b><i>x</i></b></td>
 <td>&nbsp; &harr; &nbsp;</td>
 <td><b><i>z</i></b></td><td>=</td><td>
 <img src="APLimg/circledot.bmp"><sub>1</sub>/(<b><i>y</i></b>
 <img src="APLimg/circledot.bmp"><sub>2</sub> <b><i>x</i></b>).</td>
 </tr>
</table>

<p>The question of whether a vector enters a given operation
as a row vector or as a column vector is normally settled
by the requirement of conformability,
and no special indication is required.
Thus <b><i>y</i></b> enters as a column vector
in the first of the preceding group of definitions
and as a row vector in the last two.
The question remains, however, in the case
of the two vector operands, which may be considered
with the pre-operand either as a row
(as in the scalar product 
<b><i>y</i></b> <img src="APLimg/plustimes.bmp"> <b><i>x</i></b>)
or as a column.
The latter case produces a matrix <b><i>Z</i></b>
and will be denoted by</p>

<p>&nbsp; &nbsp; &nbsp; <b><i>Z</i></b> &larr;
<b><i>y</i></b> <img src="APLimg/jotcircle.bmp"><sub>2</sub> <b><i>x</i></b>,
</p>

<p>where <b><i>Z</i></b><sub><i>j</i></sub><sup><i>i</i></sup> = 
<b><i>y</i></b><sub><i>i</i></sub> 
<img src="APLimg/circledot.bmp"><sub>2</sub>
<b><i>x</i></b><sub><i>j</i></sub>,
<i>&mu;</i>(<b><i>Z</i></b>) = <i>&nu;</i>(<b><i>y</i></b>), and
<i>&nu;</i>(<b><i>Z</i></b>) = <i>&nu;</i>(<b><i>x</i></b>).<sup><a href="APL1.htm#note1b">[b]</a></sup>
For example, if each of the vectors indicated
is of dimension three, then</p>

<table>
<tr><td rowspan=3>&nbsp; &nbsp; &nbsp;</td><td><table>
<td rowspan=3><tt><b>∊</b></tt> <img src="APLimg/jottimes.bmp">
 <b><i>y</i></b> &nbsp;=&nbsp;</td>
<td rowspan=3><img src="APLimg/matrixl3.bmp"></td>
<td><sup>&nbsp;</sup><b><i>y</i></b><sub>1</sub> &nbsp;
<b><i>y</i></b><sub>2</sub> &nbsp;
<b><i>y</i></b><sub>3&nbsp;</sub></td>
<td rowspan=3><img src="APLimg/matrixr3.bmp"></td>
<td rowspan=3>;</td></tr>
<tr><td><sup>&nbsp;</sup><b><i>y</i></b><sub>1</sub> &nbsp;
 <b><i>y</i></b><sub>2</sub> &nbsp;
 <b><i>y</i></b><sub>3&nbsp;</sub></td></tr>
<tr><td><sup>&nbsp;</sup><b><i>y</i></b><sub>1</sub> &nbsp;
 <b><i>y</i></b><sub>2</sub> &nbsp;
 <b><i>y</i></b><sub>3&nbsp;</sub></td></tr>
</table></td><td>&nbsp; &nbsp; &nbsp;</td><td><table>
<tr><td rowspan=3><b><i>y</i></b> <img src="APLimg/jottimes.bmp"> <tt><b>∊</b></tt>
  &nbsp;=&nbsp;</td>
<td rowspan=3><img src="APLimg/matrixl3.bmp"></td>
<td><sup>&nbsp;</sup><b><i>y</i></b><sub>1</sub> &nbsp;
<b><i>y</i></b><sub>1</sub> &nbsp;
<b><i>y</i></b><sub>1&nbsp;</sub></td>
<td rowspan=3><img src="APLimg/matrixr3.bmp"></td>
<td rowspan=3>;</td></tr>
<tr><td><sup>&nbsp;</sup><b><i>y</i></b><sub>2</sub> &nbsp;
 <b><i>y</i></b><sub>2</sub> &nbsp;
 <b><i>y</i></b><sub>2&nbsp;</sub></td></tr>
<tr><td><sup>&nbsp;</sup><b><i>y</i></b><sub>3</sub> &nbsp;
 <b><i>y</i></b><sub>3</sub> &nbsp;
 <b><i>y</i></b><sub>3&nbsp;</sub></td></tr>
</table></td></tr>
<tr><td></td></tr>
<tr><td colspan=3 align=center><table>
<tr><td rowspan=3><tt><b>⍺</b></tt><sup>2</sup>(3) <img src="APLimg/jotand.bmp"> 
 <tt><b>⍺</b></tt><sup>2</sup>(3) 
  &nbsp;=&nbsp;</td>
<td rowspan=3><img src="APLimg/matrixl3.bmp"></td>
<td><sup>&nbsp;</sup>1 &nbsp; 1 &nbsp; 0<sub>&nbsp;</sub></td>
<td rowspan=3><img src="APLimg/matrixr3.bmp"></td>
<td rowspan=3>.</td></tr>
<tr><td><sup>&nbsp;</sup>1 &nbsp; 1 &nbsp; 0<sub>&nbsp;</sub></td></tr>
<tr><td><sup>&nbsp;</sup>0 &nbsp; 0 &nbsp; 0<sub>&nbsp;</sub></td></tr>
</table></td></tr>
</table>
<br>



<a name="1.12"></a>
<p><b>1.12 Transpositions</b></p>

<p>Since the generalized matrix product is defined
on columns of the post-operand and rows of the pre-operand,
convenient description of corresponding operations
on the rows of the post-operand 
and columns of the pre-operand demands the ability
to <i>transpose</i> a matrix <b><i>B</i></b>,
that is, to specify a matrix <b><i>C</i></b>
such that <b><i>C</i></b><sub><i>i</i></sub><sup><i>&nbsp;j</i></sup>
= <b><i>B</i></b><sub><i>j</i></sub><sup><i>i</i></sup>.
In ordinary matrix algebra this type 
of transposition suffices,
but in more general work transpositions
about either diagonal and about the horizontal
and the vertical are also useful.
Each of these transpositions of a matrix
<b><i>B</i></b> is denoted by a superior arrow
whose inclination indicates the axis 
of the transposition.  Thus:</p>

<table>
<tr><td>&nbsp; &nbsp; &nbsp;</td>
 <td><b><i>C</i></b> &larr; <img src="APLimg/bnwarr.bmp"></td>
 <td>&nbsp; &nbsp; &nbsp; &nbsp;</td>
 <td><b><i>C</i></b><sub><i>i</i></sub><sup><i>&nbsp;j</i></sup> = 
 <b><i>B</i></b><sub><i>j&nbsp;</i></sub><sup><i>i</i></sup></td>
 <td rowspan=4><img src="APLimg/bracket1x12.bmp"> &nbsp; &nbsp; </td>
 <td rowspan=4><i>i</i> = 1, 2, &#133;, <i>&mu;</i>(<b><i>B</i></b>)<br>
<i>j</i> = 1, 2, &#133;, <i>&nu;</i>(<b><i>B</i></b>)</td>
 </tr>
<tr><td>&nbsp;</td>
 <td><b><i>C</i></b> &larr; <img src="APLimg/bnearr.bmp"></td><td>&nbsp; &nbsp;</td>
 <td><img src="APLimg/1x12a.bmp"></td></tr>
<tr><td>&nbsp;</td>
 <td><b><i>C</i></b> &larr; <img src="APLimg/brarr.bmp"></td><td>&nbsp; &nbsp;</td>
 <td><img src="APLimg/1x12b.bmp"></td></tr>
<tr><td>&nbsp;</td>
 <td><b><i>C</i></b> &larr; <img src="APLimg/buarr.bmp"></td><td>&nbsp; &nbsp;</td>
 <td><img src="APLimg/1x12c.bmp"></td></tr>
</table>

<a name="reversal"></a>
<p>For a vector <b><i>x</i></b>, either <img src="APLimg/xrarr.bmp">
or <img src="APLimg/xuarr.bmp"> will denote reversal of the order
of the components.
<a name="b_tilde"></a>
For ordinary matrix transposition (that is, <img src="APLimg/bnwarr.bmp">),
the commonly used notation <img src="APLimg/btilde.bmp">
will also be employed.</p>

<p>Since transpositions can effect any one or more
of three independent alternatives
(i.e., interchange of row and column indices
or reversal of order of row or of column indices),
repeated transpositions can produce 
eight distinct configurations.
There are therefore seven distinct 
transformations possible;
all can be generated by any pair 
of transpositions having nonperpendicular 
axes.<sup><a href="APL1.htm#note1c">[c]</a></sup>
<br>&nbsp;</p>



<a name="1.13"></a>
<p><b>1.13 Special logical matrices</b></p>

<p>Certain of the special logical vectors introduced 
in Sec. 1.7 have useful analogs
in logical matrices.
Dimensions will again be indicated in parentheses
(with the column dimension first) and may be elided
whenever the dimension is determined by context.
If not otherwise specified, 
a matrix is assumed to be square.</p>

<a name="full_matrix"></a>
<a name="zero_matrix"></a>
<p>Cases of obvious interest are the <i>full matrix</i>
<font face=Arial><b><i>E</i></b></font>(<i>m</i> &times <i>n</i>),
defined by <img src="APLimg/ecapboscore.bmp">(<i>m</i> &times <i>n</i>) = 0,
<a name="identity_matrix"></a>
and the <i>identity matrix</i> 
<font face=Arial><b><i>I</i></b></font>(<i>m</i> &times <i>n</i>),
defined by <font face=Arial><b><i>I</i></b></font><sub><i>j</i></sub><sup><i>i</i></sup>
= (<i>i</i> = <i>j</i>).
<a name="superdiagonal_matrix"></a>
More generally, <i>superdiagonal</i> matrices 
<sup><i>k</i></sup><font face=Arial><b><i>I</i></b></font>(<i>m</i> &times <i>n</i>)
are defined such that 
<sup><i>k</i></sup><font face=Arial><b><i>I</i></b></font><sub><i>j</i></sub><sup><i>i</i></sup>(<i>m</i> &times <i>n</i>)
= (<i>j</i> = <i>i</i> + <i>k</i>), for <i>k</i> &ge; 0.
Clearly <sup><i>0</i></sup><font face=Arial><b><i>I</i></b></font> =
<font face=Arial><b><i>I</i></b></font>.
Moreover, for square matrices,
<sup><i>h</i></sup><font face=Arial><b><i>I</i></b></font>
<img src="APLimg/plustimes.bmp">
<sup><i>k</i></sup><font face=Arial><b><i>I</i></b></font> =
<sup>(<i>h</i> + <i>k</i>)</sup><font face=Arial><b><i>I</i></b></font>.
</p>

<a name="triangular_matrix"></a>
<p>Four <i>triangular</i> matrices will be defined,
the geometrical symbols employed for each indicating the
(right-angled isosceles) triangular area of the
<i>m</i> &times; <i>n</i> rectangular matrix
which is occupied by <i>ones</i>.  Thus</p>

<table cellpadding=3>
<tr><td>&nbsp; &nbsp; &nbsp;</td>
 <td><b><i>C</i></b> &larr; <img src="APLimg/quadnw.bmp">(<i>m</i> &times; <i>n</i>)</td>
 <td>&nbsp;&harr;&nbsp;</td>
 <td><b><i>C</i></b><sub><i>&nbsp;j</i></sub><sup><i>&nbsp;i</i></sup></td>
 <td rowspan=4><img src="APLimg/bracket1x13.bmp"></td>
 <td rowspan=4>= (<i>i</i> + <i>j</i> &le; min(<i>m</i>, <i>n</i>)) &nbsp; &nbsp;</td>
 <td rowspan=4 align=right>for <i>i</i> = 1, 2, &#133;, <i>m</i><br>
and <i>j</i> = 1, 2, &#133;, <i>n</i>.</td>
 </tr>
<tr><td>&nbsp; &nbsp; &nbsp;</td>
 <td><b><i>C</i></b> &larr; <img src="APLimg/quadne.bmp">(<i>m</i> &times; <i>n</i>)</td>
 <td>&nbsp;&harr;&nbsp;</td>
 <td><img src="APLimg/1x13a.bmp"></td></tr>
<tr><td>&nbsp; &nbsp; &nbsp;</td>
 <td><b><i>C</i></b> &larr; <img src="APLimg/quadsw.bmp">(<i>m</i> &times; <i>n</i>)</td>
 <td>&nbsp;&harr;&nbsp;</td>
 <td><img src="APLimg/1x13b.bmp"></td></tr>
<tr><td>&nbsp; &nbsp; &nbsp;</td>
 <td><b><i>C</i></b> &larr; <img src="APLimg/quadse.bmp">(<i>m</i> &times; <i>n</i>)</td>
 <td>&nbsp;&harr;&nbsp;</td>
 <td><img src="APLimg/1x13c.bmp"></td></tr>
</table>

<p>The use of the matrices <font face=Arial><b><i>E</i></b></font> and
<font face=Arial><b><i>I</i></b></font> 
will be illustrated briefly.
The relation <b><i>u</i></b> <img src="APLimg/neand.bmp"> <b><i>v</i></b> = 
<nobr>2 |<sub>0</sub> (<b><i>u</i></b> 
<img src="APLimg/plustimes.bmp"> <b><i>v</i></b>)</nobr>
can be extended to logical matrices as follows:</p>

<p>&nbsp; &nbsp; &nbsp; <b><i>U</i></b> <img src="APLimg/neand.bmp"> <b><i>V</i></b>
= (2<font face=Arial><b><i>E</i></b></font>) |<sub>0</sub>
(<b><i>U</i></b> <img src="APLimg/plustimes.bmp"> <b><i>V</i></b>);</p>

<p>the trace of a square numerical matrix <b><i>X</i></b>
may be expressed as <i>t</i> = 
+/<font face=Arial><b><i>I</i></b></font>/<b><i>X</i></b>.
The triangular matrices are employed in the succeeding section.
<br>&nbsp;</p>



<a name="1.14"></a>
<p><b>1.14 Polynomials and positional number systems</b></p>

<p>Any positional representation of a number
<i>n</i> in a base <i>b</i> number system
can be considered as a numerical vector <b><i>x</i></b>
whose <i>base b value</i> is the quantity
<i>n</i> = <b><i>w</i></b> 
<img src="APLimg/plustimes.bmp"> <b><i>x</i></b>,
where the <i>weighting vector</i> <b><i>w</i></b> 
is defined by <b><i>w</i></b> =
(<i>b</i><sup><i>&nu;</i>(<b><i>x</i></b>)&ndash;1</sup>,
<i>b</i><sup><i>&nu;</i>(<b><i>x</i></b>)&ndash;2</sup>, &#133;
<i>b</i><sup>2</sup>, <i>b</i><sup>1</sup>, 1).
More generally, <b><i>x</i></b> may represent
a number in a mixed-radix system in which
the successive radices (from high to low order)
are the successive components of a
<i>radix vector</i> <b><i>y</i></b>.</p>

<a name="base_value"></a>
<p>The <i>base</i> <b><i>y</i></b> <i>value of</i>
<b><i>x</i></b> is a scalar denoted by 
<b><i>y</i></b>&nbsp;<tt>⊥</tt>&nbsp;<b><i>x</i></b>
and defined as the scalar product 
<b><i>y</i></b>&nbsp;<tt>⊥</tt>&nbsp;<b><i>x</i></b>
= <b><i>w</i></b> <img src="APLimg/plustimes.bmp"> <b><i>x</i></b>,
where <b><i>w</i></b> = <img src="APLimg/quadne.bmp">
<img src="APLimg/timesslash.bmp"> <b><i>y</i></b>
is the weighting vector.
For example, if <b><i>y</i></b> = (7,&nbsp;24,&nbsp;60,&nbsp;60)
is the radix vector for the common temporal system 
of units,
and if <b><i>x</i></b> = (0,&nbsp;2,&nbsp;1,&nbsp;18) 
represents elapsed time in days, hours, minutes, and seconds,
then</p>

<p>&nbsp; &nbsp; &nbsp; <i>t</i> = <b><i>w</i></b> 
<img src="APLimg/plustimes.bmp"> <b><i>x</i></b> =
(86400, 3600, 60, 1) <img src="APLimg/plustimes.bmp"> 
(0, 2, 1, 18) = 7278</p>

<p>is the elapsed time in seconds, and the
weighting vector <b><i>w</i></b> is obtained
as the product</p>

<table>
<tr><td rowspan=4>&nbsp; &nbsp; &nbsp;</td>
<td rowspan=4><img src="APLimg/quadne.bmp">
<img src="APLimg/timesslash.bmp"> <b><i>y</i></b> &nbsp; = &nbsp;</td>
<td rowspan=4><img src="APLimg/matrixl4.bmp"></td>
<td><sup>&nbsp;</sup>0 &nbsp; 1 &nbsp; 1 &nbsp; 1<sub>&nbsp;</sub></td>
<td rowspan=4><img src="APLimg/matrixr4.bmp"></td>
<td rowspan=4>&nbsp; <img src="APLimg/timesslash.bmp"> &nbsp;</td>
<td rowspan=4><img src="APLimg/matrixl4.bmp"></td>
<td align=right><sup>&nbsp;</sup>7<sub>&nbsp;</sub></td>
<td rowspan=4><img src="APLimg/matrixr4.bmp"></td>
<td rowspan=4>&nbsp; = &nbsp;</td>
<td rowspan=4><img src="APLimg/matrixl4.bmp"></td>
<td align=left><sup>&nbsp;</sup>&times;/(24, 60, 60)<sub>&nbsp;</sub></td>
<td rowspan=4><img src="APLimg/matrixr4.bmp"></td>
<td rowspan=4>&nbsp; = &nbsp;</td>
<td rowspan=4><img src="APLimg/matrixl4.bmp"></td>
<td align=right><sup>&nbsp;</sup>86400<sub>&nbsp;</sub></td>
<td rowspan=4><img src="APLimg/matrixr4.bmp"></td></tr>
<tr>
 <td><sup>&nbsp;</sup>0 &nbsp; 0 &nbsp; 1 &nbsp; 1<sub>&nbsp;</sub></td>
 <td align=right><sup>&nbsp;</sup>24<sub>&nbsp;</sub></td>
 <td align=left><sup>&nbsp;</sup>&times;/(60, 60)<sub>&nbsp;</sub></td>
 <td align=right><sup>&nbsp;</sup>3600<sub>&nbsp;</sub></td></tr>
<tr>
 <td><sup>&nbsp;</sup>0 &nbsp; 0 &nbsp; 0 &nbsp; 1<sub>&nbsp;</sub></td>
 <td align=right><sup>&nbsp;</sup>60<sub>&nbsp;</sub></td>
 <td align=left><sup>&nbsp;</sup>&times;/(60)<sub>&nbsp;</sub></td>
 <td align=right><sup>&nbsp;</sup>60<sub>&nbsp;</sub></td></tr>
<tr>
 <td><sup>&nbsp;</sup>0 &nbsp; 0 &nbsp; 0 &nbsp; 0<sub>&nbsp;</sub></td>
 <td align=right><sup>&nbsp;</sup>60<sub>&nbsp;</sub></td>
 <td align=left><sup>&nbsp;</sup>&times;/<tt><b>∊</b></tt>(0)<sub>&nbsp;</sub></td>
 <td align=right><sup>&nbsp;</sup>1<sub>&nbsp;</sub></td></tr>
</table>

<p>If <i>b</i> is any integer, then the value of <b><i>x</i></b>
in the fixed base <i>b</i> is denoted by
(<i>b</i><tt><b>∊</b></tt>)&nbsp;<tt>⊥</tt>&nbsp;<b><i>x</i></b>.
For example, 
(2<tt><b>∊</b></tt>)&nbsp;<tt>⊥</tt>&nbsp;<tt><b>⍺</b><sup>2</sup></tt>(5) = 24.
More generally, if <i>y</i> is any real number, then
(<i>y</i><tt><b>∊</b></tt>)&nbsp;<tt>⊥</tt>&nbsp;<b><i>x</i></b>
is clearly a polynomial in <i>y</i> with coefficients
<b><i>x</i></b><sub>1</sub>,
<b><i>x</i></b><sub>2</sub>, &#133;
<b><i>x</i></b><sub><i>&nu;</i></sub>, that is,</p>

<p>&nbsp; &nbsp; &nbsp; (<i>y</i><tt><b>∊</b></tt>) <tt>⊥</tt>
<b><i>x</i></b> &nbsp;=&nbsp;
<b><i>x</i></b><sub>1</sub> <i>y</i><sup><i>&nu;</i>(<b><i>x</i></b>)&ndash;1</sup> + &#133; +
<b><i>x</i></b><sub><i>&nu;</i>&ndash;1</sub> <i>y</i> + 
<b><i>x</i></b><sub><i>&nu;</i></sub> .</p>

<p>Writing the definition of 
<b><i>y</i></b> <tt>⊥</tt> <b><i>x</i></b>
in the form</p>

<p>&nbsp; &nbsp; &nbsp; <b><i>y</i></b> <tt>⊥</tt> <b><i>x</i></b>
&nbsp;=&nbsp; (<img src="APLimg/quadne.bmp"> <img src="APLimg/timesslash.bmp"> 
<b><i>y</i></b>) <img src="APLimg/plustimes.bmp"> <b><i>x</i></b></p>

<p>exhibits the fact that the operation <tt>⊥</tt>
is of the double operator type.
Its use in the generalized matrix product
therefore requires no secondary scan operator.
This will be indicated by a null placed 
over the symbol <tt>⊥</tt>. Thus</p>

<p>&nbsp; &nbsp; &nbsp; <b><i>Z</i></b> &larr; <b><i>X</i></b>
<img src="APLimg/jotbase.bmp"> <b><i>Y</i></b> &nbsp;&harr;&nbsp;
<b><i>Z</i></b><sub><i>&nbsp;j</i></sub><sup><i>&nbsp;i</i></sup> =
<b><i>X</i></b><sup><i>&nbsp;i</i></sup> <tt>⊥</tt> 
<b><i>Y</i></b><sub><i>&nbsp;j</i></sub>.</p>

<p>For example, (<i>y</i><tt><b>∊</b></tt>) 
<img src="APLimg/jotbase.bmp"> <b><i>X</i></b>
represents a set of polynomials in <i>y</i>
with coefficients 
<b><i>X</i></b><sub>1</sub>,
<b><i>X</i></b><sub>2</sub>, &#133;,
<b><i>X</i></b><sub><i>&nu;</i></sub>, and
<b><i>Y</i></b>&nbsp;<img src="APLimg/jotbase.bmp">&nbsp;<b><i>x</i></b>
represents a set of evaluations
of the vector <b><i>x</i></b> in a set of bases
<b><i>Y</i></b><sup>1</sup>,
<b><i>Y</i></b><sup>2</sup>, &#133;,
<b><i>Y</i></b><sup><i>&mu;</i></sup>.
<br>&nbsp;</p>



<a name="1.15"></a>
<p><b>1.15 Set operations</b></p>

<p>In conventional treatments, such as
<acronym title="Jacobson, N. (1951), 
Lectures in Abstract Algebra, vol. 1, 
Van Nostrand, New York.">Jacobson (1951)</acronym> or
<acronym title="Birkhoff, G., and S. MacLane (1941), 
A Survey of Modern Algebra, Macmillian, 
New York.">Birkhoff and MacLane (1941)</acronym>,
a <i>set</i> is defined as an unordered collection
of distinct elements.
A calculus of sets is then based
on such elementary relations as
set membership and on such elementary operations as
<i>set intersection</i> and
<i>set union</i>, none of which imply or depend
on an ordering among members of a set.
In the present context it is more fruitful
to develop a calculus of <i>ordered sets</i>.</p>

<p>A vector whose components are all distinct
has been called (Sec. 1.10)
an <i>ordered set</i> and 
(since no other types are to be considered)
will hereafter be called a <i>set</i>.
In order to provide a closed system,
all of the &ldquo;set operations&rdquo; will,
in fact, be defined on vectors.
However, the operations will, 
in the special case of sets,
be analogous to classical set operations.
The following vectors, the first four of which are sets,
will be used for illustration throughout.</p>

<table>
<tr><td>&nbsp; &nbsp; &nbsp;</td>
 <td><b><i>t</i></b> = (t, e, a)</td></tr>
<tr><td>&nbsp;</td><td><b><i>a</i></b> = (a, t, e)</td></tr>
<tr><td>&nbsp;</td><td><b><i>s</i></b> = (s, a, t, e, d)</td></tr>
<tr><td>&nbsp;</td><td><b><i>d</i></b> = (d, u, s, k)</td></tr>
<tr><td>&nbsp;</td><td><b><i>n</i></b> = (n, o, n, s, e, t)</td></tr>
<tr><td>&nbsp;</td><td><b><i>r</i></b> = (r, e, d, u, n, d, a, n, t)</td></tr>
</table>

<a name="membership"></a>
<p>A variable <i>z</i> is a <i>member</i>
of a vector <b><i>x</i></b> if 
<i>z</i> = <b><i>x</i></b><sub><i>i</i></sub>
for some <i>i</i>.
Membership is denoted by <i>z</i> &epsilon; <b><i>x</i></b>.
<a name="inclusion"></a>
A vector <b><i>x</i></b> <i>includes</i> a vector <b><i>y</i></b>
(denoted by either <b><i>x</i></b> <tt>&supe;</tt> <b><i>y</i></b> or
<b><i>y</i></b> <tt>&sube;</tt> <b><i>x</i></b>)
if each element <b><i>y</i></b><sub><i>i</i></sub>
is a member of <b><i>x</i></b>.
<a name="similarity"></a>
If both <b><i>x</i></b> <tt>&supe;</tt> <b><i>y</i></b>
and <b><i>x</i></b> <tt>&sube;</tt> <b><i>y</i></b>,
then <b><i>x</i></b> and <b><i>y</i></b> are said
to be <i>similar</i>. 
Similarity of <b><i>x</i></b> and <b><i>y</i></b>
is denoted by <b><i>x</i></b>&nbsp;<tt>≡</tt>&nbsp;<b><i>y</i></b>.
For example, <b><i>t</i></b> <tt>&sube;</tt> <b><i>s</i></b>,
<b><i>t</i></b>&nbsp;<tt>&sube;</tt>&nbsp;<b><i>r</i></b>,
<b><i>t</i></b>&nbsp;<tt>&sube;</tt>&nbsp;<b><i>a</i></b>,
<b><i>a</i></b>&nbsp;<tt>&sube;</tt>&nbsp;<b><i>t</i></b>,
<b><i>t</i></b>&nbsp;<tt>≡</tt>&nbsp;<b><i>a</i></b>,
and <b><i>t</i></b>&nbsp;<tt>≢</tt>&nbsp;<b><i>r</i></b>.
<a name="strict_inclusion"></a>
If <b><i>x</i></b>&nbsp;<tt>&sube;</tt>&nbsp;<b><i>y</i></b>
and <b><i>x</i></b>&nbsp;<tt>≢</tt>&nbsp;<b><i>y</i></b>,
then <b><i>x</i></b> is <i>strictly</i> 
included in <b><i>y</i></b>.
Strict inclusion is denoted 
by <b><i>x</i></b>&nbsp;<tt>⊂</tt>&nbsp;<b><i>y</i></b>.</p>

<a name="characteristic_vector"></a>
<p>The <i>characteristic vector</i> of <b><i>x</i></b>
on <b><i>y</i></b> is a logical vector denoted by
<tt><b>∊</b></tt><sub><b><i>y</i></b></sub><sup><b><i>x</i></b></sup>,
and defined as follows:</p>

<p>&nbsp; &nbsp; &nbsp; <b><i>u</i></b> = <tt><b>∊</b></tt><sub><b><i>y</i></b></sub><sup><b><i>x</i></b></sup>
&nbsp;&harr;&nbsp; <i>&nu;</i>(<b><i>u</i></b>) = <i>&nu;</i>(<b><i>y</i></b>),
and <b><i>u</i></b><sub><i>j</i></sub> = (<b><i>y</i></b><sub><i>j</i></sub> &epsilon; <b><i>x</i></b>).</p>

<p>For example, 
<tt><b>∊</b></tt><sub><b><i>s</i></b></sub><sup><b><i>t</i></b></sup> = (0,&nbsp;1,&nbsp;1,&nbsp;1,&nbsp;0), 
<tt><b>∊</b></tt><sub><b><i>t</i></b></sub><sup><b><i>s</i></b></sup> = (1,&nbsp;1,&nbsp;1), 
<tt><b>∊</b></tt><sub><b><i>s</i></b></sub><sup><b><i>d</i></b></sup> = (1,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;1), 
<tt><b>∊</b></tt><sub><b><i>d</i></b></sub><sup><b><i>s</i></b></sup> = (1,&nbsp;0,&nbsp;1,&nbsp;0), and
<tt><b>∊</b></tt><sub><b><i>n</i></b></sub><sup><b><i>r</i></b></sup> = (1,&nbsp;0,&nbsp;1,&nbsp;0,&nbsp;1,&nbsp;1).</p> 

<a name="intersection"></a>
<p>The intersection of <b><i>y</i></b> with <b><i>x</i></b>
is denoted by <b><i>y</i></b> <tt>∩</tt> <b><i>x</i></b>,
and defined as follows:</p>

<p>&nbsp; &nbsp; &nbsp; <b><i>y</i></b> <tt>∩</tt> <b><i>x</i></b> =
<tt><b>∊</b></tt><sub><b><i>y</i></b></sub><sup><b><i>x</i></b></sup>/<b><i>y</i></b>.</p>

<p>For example, 
<b><i>s</i></b> <tt>∩</tt> <b><i>d</i></b> = (s,&nbsp;d),
<b><i>d</i></b> <tt>∩</tt> <b><i>s</i></b> = (d,&nbsp;s),
<b><i>s</i></b> <tt>∩</tt> <b><i>r</i></b> = (a,&nbsp;t,&nbsp;e,&nbsp;d), and
<b><i>r</i></b> <tt>∩</tt> <b><i>s</i></b> = (e,&nbsp;d,&nbsp;d,&nbsp;a,&nbsp;t).
Clearly, <b><i>x</i></b> <tt>∩</tt> <b><i>y</i></b> <tt>≡</tt>
<b><i>y</i></b> <tt>∩</tt> <b><i>x</i></b>,
although <b><i>x</i></b> <tt>∩</tt> <b><i>y</i></b> is not,
in general, equal to <b><i>y</i></b> <tt>∩</tt> <b><i>x</i></b>,
since the components may occur in a different order
and may be repeated a different number of times.
The vector <b><i>x</i></b> <tt>∩</tt> <b><i>y</i></b>
is said to be <i>ordered</i> on <b><i>x</i></b>.
Thus <b><i>a</i></b> is ordered on <b><i>s</i></b>.
If <b><i>x</i></b> and <b><i>y</i></b>
contain no common elements (that is,
(<b><i>x</i></b> <tt>∩</tt> <b><i>y</i></b>) = <tt><b>∊</b></tt>(0)),
they are said to be <i>disjoint</i>.</p>

<a name="difference"></a>
<p>The <i>set difference</i> of <b><i>y</i></b>
and <b><i>x</i></b> is denoted by <b><i>y</i></b> <tt>∆</tt> <b><i>x</i></b>
and is defined as follows:</p>

<p>&nbsp; &nbsp; &nbsp; <b><i>y</i></b> <tt>∆</tt> <b><i>x</i></b> = 
<img src="APLimg/epsboscore.bmp"><sub><b><i>y</i></b></sub><sup><b><i>x</i></b></sup>/<b><i>y</i></b>.</p>

<p>Hence <b><i>y</i></b> <tt>∆</tt> <b><i>x</i></b> is obtained
from <b><i>y</i></b> by suppressing those components 
which belong to <b><i>x</i></b>.
For example, 
<img src="APLimg/epsboscore.bmp"><sub><b><i>s</i></b></sub><sup><b><i>t</i></b></sup>
= (1,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;1) and 
<b><i>s</i></b>&nbsp;<tt>∆</tt>&nbsp;<b><i>t</i></b> = (s,&nbsp;d).
Moreover, 
<img src="APLimg/epsboscore.bmp"><sub><b><i>t</i></b></sub><sup><b><i>s</i></b></sup>
= (0,&nbsp;0,&nbsp;0) and 
<b><i>t</i></b>&nbsp;<tt>∆</tt>&nbsp;<b><i>s</i></b> = <tt><b>∊</b></tt>(0).</p>

<a name="union"></a>
<p>The <i>union</i> of <b><i>y</i></b> and <b><i>x</i></b>
is denoted by <b><i>y</i></b> <tt>∪</tt> <b><i>x</i></b> 
and defined as follows:<sup><a href="APL1.htm#note1d">[d]</a></sup>
<b><i>y</i></b>&nbsp;<tt>∪</tt>&nbsp;<b><i>x</i></b> =
<b><i>y</i></b> <img src="APLimg/circleplus.bmp"> 
(<b><i>x</i></b>&nbsp;<tt>∆</tt>&nbsp;<b><i>y</i></b>).
For example, <b><i>s</i></b>&nbsp;<tt>∪</tt>&nbsp;<b><i>d</i></b> =
(s,&nbsp;a,&nbsp;t,&nbsp;e,&nbsp;d,&nbsp;u,&nbsp;k), 
<b><i>d</i></b>&nbsp;<tt>∪</tt>&nbsp;<b><i>s</i></b> =
(d,&nbsp;u,&nbsp;s,&nbsp;k,&nbsp;a,&nbsp;t,&nbsp;e),
<b><i>s</i></b>&nbsp;<tt>∪</tt>&nbsp;<b><i>a</i></b> =
<b><i>s</i></b>&nbsp;<tt>∪</tt>&nbsp;<b><i>t</i></b> = <b><i>s</i></b>,
and <b><i>n</i></b>&nbsp;<tt>∪</tt>&nbsp;<b><i>t</i></b> =
(n,&nbsp;o,&nbsp;n,&nbsp;s,&nbsp;e,&nbsp;t,&nbsp;a).
In general, 
<b><i>x</i></b>&nbsp;<tt>∪</tt>&nbsp;<b><i>y</i></b> <tt>≡</tt>
<b><i>y</i></b>&nbsp;<tt>∪</tt>&nbsp;<b><i>x</i></b>, and 
<b><i>x</i></b> <tt>≡</tt> 
(<b><i>x</i></b>&nbsp;<tt>∩</tt>&nbsp;<b><i>y</i></b>) <tt>∪</tt>
(<b><i>x</i></b>&nbsp;<tt>∆</tt>&nbsp;<b><i>y</i></b>).
If <b><i>x</i></b> and <b><i>y</i></b>
are disjoint, 
their union is equivalent to their catenation,
that is, <b><i>x</i></b>&nbsp;<tt>∩</tt>&nbsp;<b><i>y</i></b>
= <tt><b>∊</b></tt>(0) implies that
<b><i>x</i></b>&nbsp;<tt>∪</tt>&nbsp;<b><i>y</i></b> =
<b><i>x</i></b> <img src="APLimg/circleplus.bmp"> <b><i>y</i></b>.</p>

<p>In the foregoing development, the concepts
of inclusion and similarity are equivalent to the concepts
of inclusion and equality in the conventional treatment
of (unordered) sets.
The remaining definitions of intersection,
difference, and union differ from the usual formulation
in that the result of any of these operations
on a pair of ordered sets is again an <i>ordered</i> set.
With respect to <i>similarity</i>,
these operations satisfy the same identities
as do the analogous conventional set operations
on unordered sets with respect to equality.</p>

<p>The forward selection <i>&sigma;</i>/<b><i>b</i></b>
and the backward selection <i>&tau;</i>/<b><i>b</i></b>
defined in Sec. 1.10
can both be used to reduce any vector <b><i>b</i></b>
to a similar set, that is,</p>

<p>&nbsp; &nbsp; &nbsp; (<i>&sigma;</i>/<b><i>b</i></b>)/<b><i>b</i></b>
<tt>≡</tt> (<i>&tau;</i>/<b><i>b</i></b>)/<b><i>b</i></b>
<tt>≡</tt> <b><i>b</i></b>.</p>

<p>Moreover, if 
<b><i>f</i></b> = (<i>&sigma;</i>/<b><i>x</i></b>)/<b><i>b</i></b>,
<b><i>g</i></b> = (<i>&sigma;</i>/<b><i>y</i></b>)/<b><i>y</i></b>, and
<b><i>h</i></b> = (<i>&sigma;</i>/<b><i>z</i></b>)/<b><i>z</i></b>,
then <b><i>x</i></b> = <b><i>y</i></b>&nbsp;<tt>∩</tt>&nbsp;<b><i>z</i></b>
implies that <b><i>f</i></b> = <b><i>g</i></b>&nbsp;<tt>∩</tt>&nbsp;<b><i>h</i></b>,
and <b><i>x</i></b> = <b><i>y</i></b>&nbsp;<tt>∪</tt>&nbsp;<b><i>z</i></b>
implies that <b><i>f</i></b> = <b><i>g</i></b>&nbsp;<tt>∪</tt>&nbsp;<b><i>h</i></b>.
</p>

<p>The unit vector <tt><b>∊</b></tt><sup><i>&nbsp;j</i></sup>(<i>n</i>)
will be recognized as a special case of the
characteristic vector <tt><b>∊</b></tt><sub><b><i>y</i></b></sub><sup><b><i>x</i></b></sup>
in which <b><i>x</i></b> consists of the single component
<i>j</i>, and <b><i>y</i></b> = <tt><b>⍳</b></tt><sup><i>h</i></sup>(<i>n</i>),
where <i>h</i> is the index origin in use.
In fact, the notation <tt><b>∊</b></tt><sup><i>&nbsp;j</i></sup><sub><i>i</i><sup><i>h</i></sup></sub>
can be used to make explicit the index origin <i>h</i> assumed 
for <tt><b>∊</b></tt><sup><i>&nbsp;j</i></sup>.</p>

<a name="cartesian"></a>
<p>If <b><i>z</i></b> is any vector of dimension two
such that <b><i>z</i></b><sub>1</sub> &epsilon; <b><i>x</i></b>
and <b><i>z</i></b><sub>2</sub> &epsilon; <b><i>y</i></b>,
then <b><i>z</i></b> is said to belong to the
<i>Cartesian product</i> of <b><i>x</i></b>
and <b><i>y</i></b>.
Thus if <b><i>x</i></b> = (a,&nbsp;b,&nbsp;c) and
<b><i>y</i></b> = (0,&nbsp;1),
the rows of the matrix</p>

<table>
<tr>
 <td rowspan=6>&nbsp; &nbsp; &nbsp;</td>
 <td rowspan=6><b><i>A</i></b> &nbsp;=&nbsp;
 <td rowspan=6><img src="APLimg/matrixl6.bmp"></td>
 <td><sup>&nbsp;</sup>a &nbsp; 0<sub>&nbsp;</sub></td>
 <td rowspan=6><img src="APLimg/matrixr6.bmp"></td></tr>
<tr><td><sup>&nbsp;</sup>a &nbsp; 1<sub>&nbsp;</sub></td></tr>
<tr><td><sup>&nbsp;</sup>b &nbsp; 0<sub>&nbsp;</sub></td></tr>
<tr><td><sup>&nbsp;</sup>b &nbsp; 1<sub>&nbsp;</sub></td></tr>
<tr><td><sup>&nbsp;</sup>c &nbsp; 0<sub>&nbsp;</sub></td></tr>
<tr><td><sup>&nbsp;</sup>c &nbsp; 1<sub>&nbsp;</sub></td></tr>
</table>

<p>are a complete list of the vectors <b><i>z</i></b>
belonging to the product set of <b><i>x</i></b>
and <b><i>y</i></b>.
The matrix <b><i>A</i></b> will be called
the Cartesian product of <b><i>x</i></b> and 
<b><i>y</i></b> and will be denoted
<b><i>x</i></b> <img src="APLimg/circletimes.bmp"> <b><i>y</i></b>.</p>

<p>The foregoing definition by example will be formalized
in a more general way that admits the Cartesian product
of several vectors (that is, 
<b><i>u</i></b> <img src="APLimg/circletimes.bmp">
<b><i>v</i></b> <img src="APLimg/circletimes.bmp"> 
&#133; <img src="APLimg/circletimes.bmp"> <b><i>y</i></b>)
which need not be sets, and which specifies
a unique ordering of the rows of the resulting matrix.
Consider a family of vectors
<b><i>x</i></b><sup>1</sup>, <b><i>x</i></b><sup>2</sup>, 
&#133;, <b><i>x</i></b><sup><i>s</i></sup>
of dimensions <b><i>d</i></b><sub>1</sub>, <b><i>d</i></b><sub>2</sub>,
&#133;, <b><i>d</i></b><sub><i>s</i></sub>. Then</p>

<p>&nbsp; &nbsp; &nbsp; <b><i>A</i></b> &larr;
<b><i>x</i></b><sup>1</sup> <img src="APLimg/circletimes.bmp">
<b><i>x</i></b><sup>2</sup> <img src="APLimg/circletimes.bmp">
&#133; <img src="APLimg/circletimes.bmp"> <b><i>x</i></b><sup><i>s</i></sup>
&nbsp;&harr;&nbsp; <b><i>A</i></b><sup>1 + <b><i>d</i></b> <tt>⊥</tt> (<b><i>k</i></b> &ndash; <tt><b>∊</b></tt>)</sup>
= (<b><i>x</i></b><sup>1</sup><sub><b><i>k</i></b><sub>1</sub></sub>,
<b><i>x</i></b><sup>2</sup><sub><b><i>k</i></b><sub>2</sub></sub>, &#133;,
<b><i>x</i></b><sup><i>s</i></sup><sub><b><i>k</i></b><sub><i>s</i></sub></sub>),
</p>

<p>for all vectors <b><i>k</i></b> such that 
1 &le; <b><i>k</i></b><sub><i>i</i></sub> &le; 
<b><i>d</i></b><sub><i>i</i></sub>.
Clearly, <i>&nu;</i>(<b><i>A</i></b>) = <i>s</i>,
and <i>&mu;</i>(<b><i>A</i></b>) = &times;/<b><i>d</i></b>.
As illustrated by Table 1.11,
the rows of the Cartesian product <b><i>A</i></b>
are not distinct if any one of the vectors 
<b><i>x</i></b><sup><i>i</i></sup>
is not a set.</p>

<table>
<tr><td>&nbsp; &nbsp; &nbsp;</td><td><table>
<tr><td><b><i>x</i></b><sup>1</sup></td><td> = (a, b, a)</td></tr>
<tr><td><b><i>x</i></b><sup>2</sup></td><td> = (#, *)</td></tr>
<tr><td><b><i>x</i></b><sup>3</sup></td><td> = (0, 1)</td></tr>
<tr><td><b><i>d</i></b></td><td> = (3, 2, 2)</td></tr>
</table></td><td>&nbsp; &nbsp; &nbsp; &nbsp;</td><td><table>
<tr>
 <td rowspan=12><b><i>A</i></b> &nbsp;=&nbsp;</td>
 <td rowspan=12><img src="APLimg/matrixl1x15.bmp">
 <td>a &nbsp; # &nbsp; 0</td>
 <td rowspan=12><img src="APLimg/matrixr1x15.bmp"></tr>
<tr><td>a &nbsp; # &nbsp; 1</td></tr>
<tr><td>a &nbsp; * &nbsp; 0</td></tr>
<tr><td>a &nbsp; * &nbsp; 1</td></tr>
<tr><td>b &nbsp; # &nbsp; 0</td></tr>
<tr><td>b &nbsp; # &nbsp; 1</td></tr>
<tr><td>b &nbsp; * &nbsp; 0</td></tr>
<tr><td>b &nbsp; * &nbsp; 1</td></tr>
<tr><td>a &nbsp; # &nbsp; 0</td></tr>
<tr><td>a &nbsp; # &nbsp; 1</td></tr>
<tr><td>a &nbsp; * &nbsp; 0</td></tr>
<tr><td>a &nbsp; * &nbsp; 1</td></tr>
</table></td></tr>
</table>

<p>&nbsp; &nbsp; &nbsp; <b>Table 1.11&nbsp;</b> The Cartesian product
<b><i>A</i></b> = <b><i>x</i></b><sup>1</sup> 
<img src="APLimg/circletimes.bmp"> <b><i>x</i></b><sup>2</sup> 
<img src="APLimg/circletimes.bmp"> <b><i>x</i></b><sup>3</sup></p>

<a name="cp_reduce"></a>
<p>If the vectors <b><i>x</i></b><sup><i>i</i></sup>
are all of the the same dimension, 
they may be considered as the columns of a matrix <b><i>X</i></b>,
that is, <b><i>X</i></b><sub><i>i</i></sub> = <b><i>x</i></b><sup><i>i</i></sup>.
The product <b><i>x</i></b><sup>1</sup> 
<img src="APLimg/circletimes.bmp"> <b><i>x</i></b><sup>2</sup>
<img src="APLimg/circletimes.bmp"> &#133; 
<img src="APLimg/circletimes.bmp"> <b><i>x</i></b><sup><i>s</i></sup> =
<b><i>X</i></b><sub>1</sub> 
<img src="APLimg/circletimes.bmp"> <b><i>X</i></b><sub>2</sub>
<img src="APLimg/circletimes.bmp"> &#133; 
<img src="APLimg/circletimes.bmp"> <b><i>X</i></b><sub><i>s</i></sub>
may then be defined by <img src="APLimg/circletimes.bmp">/<b><i>X</i></b>,
or alternatively by <img src="APLimg/circletimes.bmp">//<b><i>Y</i></b>,
where <b><i>Y</i></b> is the transpose of <b><i>X</i></b>.
For example, if</p>

<table><tr><td rowspan=2>&nbsp; &nbsp; &nbsp; <b><i>X</i></b> = 
<tt><b>⍳</b></tt><sup>0</sup>(2) 
<img src="APLimg/jotand.bmp"> <tt><b>∊</b></tt>(3) = </td>
<td rowspan=2><img src="APLimg/matrixl2.bmp"></td>
<td><sup>&nbsp;</sup>0&nbsp; 0&nbsp; 0<sub>&nbsp;</sub></td>
<td rowspan=2><img src="APLimg/matrixr2.bmp"></td>
<td rowspan=2>,</td>
</tr>
<tr><td><sup>&nbsp;</sup>1&nbsp; 1&nbsp; 1<sub>&nbsp;</sub></td></tr>
</table>

<p>then <img src="APLimg/circletimes.bmp">/<b><i>X</i></b>
is the matrix of arguments of the truth table for three variables.
<br>&nbsp;</p>



<a name="1.16"></a>
<p><b>1.16 Ranking</b></p>

<p>The <i>rank</i> or <i>index</i> of an element
<i>c</i> &epsilon; <b><i>b</i></b>
is called the <b><i>b</i></b> <i>index of c</i>
and is defined as the smallest value of <i>i</i>
such that <i>c</i> = <b><i>b</i></b><sub><i>i</i></sub>.
To establish a closed system, the <b><i>b</i></b>
index of any element 
<b><i>a</i></b> <img src="APLimg/noteps.bmp"> <b><i>b</i></b>
will be defined as the null characer <tt>∘</tt>.
The <b><i>b</i></b> index of any element <i>c</i>
will be denoted by <b><i>b</i></b> <tt>⍳</tt> <i>c</i>;
if necessary, the index origin in use will be indicated
by a subscript appended to the operator <tt>⍳</tt>.
Thus, if <b><i>b</i></b> = (a,&nbsp;p,&nbsp;e),
<b><i>b</i></b> <tt>⍳</tt><sub>0</sub> p = 1, and 
<b><i>b</i></b> <tt>⍳</tt><sub>1</sub> p = 2.</p>

<p>The <b><i>b</i></b> index 
of a vector <b><i>c</i></b> is defined as follows:</p>

<p>&nbsp; &nbsp; &nbsp; <b><i>k</i></b> &larr;
<b><i>b</i></b> <tt>⍳</tt> <b><i>c</i></b> &nbsp;&harr;&nbsp;
<b><i>k</i></b><sub><i>&nbsp;i</i></sub> = 
<b><i>b</i></b> <tt>⍳</tt> <b><i>c</i></b><sub><i>&nbsp;i</i></sub>.<p>

<a name="iota_row"></a>
<a name="iota_col"></a>
<p>The extension to matrices may be either row by row or 
(as indicated by a doubled operator symbol <tt>⍳⍳</tt>)
column by column, as follows:</p>

<table>
<tr><td>&nbsp; &nbsp; &nbsp;</td>
 <td><b><i>J</i></b> &larr; <b><i>B</i></b> <tt>⍳</tt> <b><i>C</i></b></td>
 <td>&nbsp;&harr;&nbsp;</td>
 <td><b><i>J</i></b><sup><i>&nbsp;i</i></sup> &larr; <b><i>B</i></b><sup><i>&nbsp;i</i></sup> <tt>⍳</tt> <b><i>C</i></b><sup><i>&nbsp;i</i></sup>,</td></tr>
<tr><td>&nbsp;</td>
 <td><b><i>K</i></b> &larr; <b><i>B</i></b> <tt>⍳⍳</tt> <b><i>C</i></b></td>
 <td>&nbsp;&harr;&nbsp;</td>
 <td><b><i>K</i></b><sub><i>j</i></sub> &larr; <b><i>B</i></b><sub><i>j</i></sub> <tt>⍳</tt> <b><i>C</i></b><sub><i>j</i></sub>.</td></tr>
</table>

<p>Use of the ranking operator in a matrix product requires 
no secondary scan and is therefore indicated 
by a superior null symbol.
Moreover, since the result must be limited 
to a two-dimensional array (matrix),
either the pre- or post-operand is required
to be a vector.  Hence

<table>
<tr><td>&nbsp; &nbsp; &nbsp;</td>
 <td><b><i>J</i></b> &larr; <b><i>B</i></b> <img src="APLimg/jotiota.bmp"> <b><i>c</i></b></td>
 <td>&nbsp;&harr;&nbsp;</td>
 <td><b><i>J</i></b><sup><i>&nbsp;i</i></sup> &larr; <b><i>B</i></b><sup><i>&nbsp;i</i></sup> <tt>⍳</tt> <b><i>c</i></b><sup><i>&nbsp;i</i></sup>,</td></tr>
<tr><td>&nbsp;</td>
 <td><b><i>K</i></b> &larr; <b><i>b</i></b> <img src="APLimg/jotiota.bmp"> <b><i>C</i></b></td>
 <td>&nbsp;&harr;&nbsp;</td>
 <td><b><i>K</i></b><sub><i>j</i></sub> &larr; <b><i>b</i></b><sub><i>j</i></sub> <tt>⍳</tt> <b><i>C</i></b><sub><i>j</i></sub>.</td></tr>
</table>

<p>The first of these ranks the components
of <b><i>c</i></b> with respect to each 
of a set of vectors 
<b><i>B</i></b><sup>1</sup>, <b><i>B</i></b><sup>2</sup>, &#133;,
<b><i>B</i></b><sup><i>&mu;</i></sup>,
whereas the second ranks each of the vectors
<b><i>C</i></b><sub>1</sub>, <b><i>C</i></b><sub>2</sub>, &#133;,
<b><i>C</i></b><sub><i>&nu;</i></sub>
with respect to the fixed vector <b><i>b</i></b>.</p> 

<p>The use of the ranking operation can be illustrated
as follows.  Consider the vector <b><i>b</i></b> =
(a,&nbsp;b,&nbsp;c,&nbsp;d,&nbsp;e) and the set of all 3<sup>5</sup>
three-letter sequences (vectors) formed from its components.
If the set is ordered lexically,
and if <b><i>x</i></b> is the <i>j</i>th member
of the set (counting from zero), then</p>

<p>&nbsp; &nbsp; &nbsp; <i>j</i> = (<i>&nu;</i>(<b><i>b</i></b>)<tt><b>∊</b></tt>)
<tt>⊥</tt> (<b><i>b</i></b> <tt>⍳</tt><sub>0</sub> <b><i>x</i></b>).</p>

<p>For example, if <b><i>x</i></b> = (c,&nbsp;a,&nbsp;b), then
(<b><i>b</i></b> <tt>⍳</tt><sub>0</sub> <b><i>x</i></b>) =
(2,&nbsp;0,&nbsp;1), and <i>j</i> = 51.
<br>&nbsp;</p>



<a name="1.17"></a>
<p><b>1.17 Mapping and permutation</b></p>

<a name="1.17.1"></a>
<p><b>Reordering operations</b></p>

<p>The selection operations employed thus far 
do not permit convenient reorderings of the components.
This is provided by the <i>mapping</i> operation
defined as follows:<sup><a href="APL1.htm#note1e">[e]</a></sup></p>

<p>&nbsp; &nbsp; &nbsp; <b><i>c</i></b> &larr;
<b><i>a</i></b><sub>&nbsp;<b><i>k</i></b></sub> &nbsp;&harr;&nbsp;
 <b><i>c</i></b><sub><i>&nbsp;i</i></sub> = 
 <b><i>a</i></b><sub>&nbsp;<b><i>k</i></b><sub><i>i</i></sub></sub></p>

<p>For example, if <b><i>a</i></b> = (a, b, &#133;, z)
and <b><i>k</i></b> = (6, 5, 4),
then <b><i>c</i></b> = (f, e, d).</p>

<p>The foregoing definition is meaningful 
only if the components of <b><i>k</i></b>
each lie in the range of the indices of <b><i>a</i></b>,
and it will be extended by defining 
<b><i>a</i></b><sub><i>&nbsp;j</i></sub>
as the null element <tt>∘</tt> if <i>j</i>
does not belong to the index set of <b><i>a</i></b>.
Formally,</p>

<table>
<tr><td rowspan=2>&nbsp; &nbsp; &nbsp;</td>
 <td rowspan=2><b><i>c</i></b> &larr; <b><i>a</i></b><sub>&nbsp;<b><i>m</i></b></sub>
 &nbsp;&harr;&nbsp; <b><i>c</i></b><sub><i>&nbsp;i</i></sub> =</td>
 <td rowspan=2>&nbsp;</td>
 <td rowspan=2><img src="APLimg/bracket1x17.bmp"></td>
 <td><b><i>a</i></b><sub>&nbsp;<b><i>m</i></b><sub><i>i</i></sub></sub></td>
 <td rowspan=2>&nbsp;</td>
 <td>if <b><i>m</i></b><sub><i>&nbsp;i</i></sub> &epsilon;
 <tt><b>⍳</b></tt><sup>1</sup>(<i>&nu;</i>(<b><i>a</i></b>))</td>
<tr><td><tt>∘</tt></td>
 <td>if <b><i>m</i></b><sub><i>&nbsp;i</i></sub> <img src="APLimg/noteps.bmp">
 <tt><b>⍳</b></tt><sup>1</sup>(<i>&nu;</i>(<b><i>a</i></b>)).</td>
</table>

<p>The ability to specify an arbitrary index origin
for the vector <b><i>a</i></b> being mapped
is provided by the following alternative notation
for mapping:</p>

<table>
<tr><td rowspan=2>&nbsp; &nbsp; &nbsp;</td>
 <td rowspan=2><b><i>c</i></b> &larr; <b><i>m</i></b> 
 &int;<sub><i>j</i></sub> <b><i>a</i></b>
 &nbsp;&harr;&nbsp; <b><i>c</i></b><sub><i>&nbsp;i</i></sub> =</td>
 <td rowspan=2>&nbsp;</td>
 <td rowspan=2><img src="APLimg/bracket1x17.bmp"></td>
 <td><b><i>a</i></b><sub>&nbsp;<b><i>m</i></b><sub><i>i</i></sub></sub></td>
 <td rowspan=2>&nbsp;</td>
 <td>if <b><i>m</i></b><sub><i>&nbsp;i</i></sub> &epsilon;
 <tt><b>⍳</b></tt><sup><i>j</i></sup>(<i>&nu;</i>(<b><i>a</i></b>))</td>
<tr><td><tt>∘</tt></td>
 <td>if <b><i>m</i></b><sub><i>&nbsp;i</i></sub> <img src="APLimg/noteps.bmp">
 <tt><b>⍳</b></tt><sup><i>j</i></sup>(<i>&nu;</i>(<b><i>a</i></b>)),</td>
</table>

<p>where <i>j</i>-origin indexing is assumed 
for the vector <b><i>a</i></b>.
For example, if <b><i>a</i></b> is the alphabet
and <b><i>m</i></b> = (5, <tt>∘</tt>, <tt>∘</tt>, 4, 27, <tt>∘</tt>, 3),
then <b><i>c</i></b> = <b><i>m</i></b> &int;<sub>0</sub> <b><i>a</i></b>
= (f, <tt>∘</tt>, <tt>∘</tt>, e, <tt>∘</tt>, <tt>∘</tt>, d),
and (<b><i>c</i></b> &ne; <tt>∘</tt><tt><b>∊</b></tt>)/<b><i>c</i></b>
= (f, e, d).  Moreover, <b><i>m</i></b> &int;<sub>2</sub> <b><i>a</i></b>
= (d, <tt>∘</tt>, <tt>∘</tt>, c, z, <tt>∘</tt>, b).
Elision of <i>j</i> is permitted.</p>

<p>If <b><i>a</i></b> <tt>⊆</tt> <b><i>b</i></b>,
and <b><i>m</i></b> = <b><i>b</i></b> 
<tt>⍳</tt><sub><i>j</i></sub> <b><i>a</i></b>,
then clearly <b><i>m</i></b> &int;<sub><i>j</i></sub> 
<b><i>b</i></b> = <b><i>a</i></b>.
If  <b><i>a</i></b> <img src="APLimg/notsube.bmp"> <b><i>b</i></b>,
then <b><i>m</i></b> &int;<sub><i>j</i></sub> <b><i>b</i></b>
contains (in addition to certain nulls)
those components common to <b><i>b</i></b> and <b><i>a</i></b>,
arranged in the order in which they occur in <b><i>a</i></b>.
In other words,</p>

<p>&nbsp; &nbsp; &nbsp; (<b><i>m</i></b> &ne; <tt>∘</tt><tt><b>∊</b></tt>)/(<b><i>m</i></b> 
&int;<sub><i>j</i></sub> <b><i>b</i></b>) 
= <b><i>a</i></b> <tt>∩</tt> <b><i>b</i></b>.</p>

<p>Consequently, if <b><i>p</i></b>, <b><i>q</i></b>, &#133;,
<b><i>t</i></b> are vectors,
each contained in <b><i>b</i></b>,
then each can be represented jointly by the vector
<b><i>b</i></b> and a mapping vector.
If, for example, <b><i>b</i></b> is a glossary
and <b><i>p</i></b>, <b><i>q</i></b>, etc. are texts,
the total storage required for <b><i>b</i></b>
and the mapping vectors might be considerably 
less than for the entire set of texts.</p>

<p>Mapping may be shown to be associative,
that is, <b><i>m</i></b><sup>1</sup> &int;<sub><i>i</i></sub> 
(<b><i>m</i></b><sup>2</sup> &int;<sub><i>j</i></sub> <b><i>a</i></b>) =
(<b><i>m</i></b><sup>1</sup> &int;<sub><i>i</i></sub> 
<b><i>m</i></b><sup>2</sup>) &int;<sub><i>j</i></sub> <b><i>a</i></b>.
Mapping is not, in general, commutative.</p>

<a name="index_row"></a>
<a name="index_col"></a>
<p>Mapping is extended to matrices as follows:</p>

<table>
<tr><td>&nbsp; &nbsp; &nbsp;</td>
 <td><sup>&nbsp;</sup><b><i>A</i></b> &larr; <b><i>M</i></b> &int;<sub><i>h</i></sub> <b><i>B</i></b></td>
 <td>&nbsp; &harr; &nbsp;</td>
 <td><b><i>A</i></b><sup><i>i</i></sup> = 
 <b><i>M</i></b><sup><i>&nbsp;i</i></sup> &int;<sub><i>h</i></sub> <b><i>B</i></b><sup><i>i</i></sup>,</td></tr>
<tr><td>&nbsp;</td>
 <td><sub>&nbsp;</sub><b><i>C</i></b> &larr; <b><i>M</i></b> &int;&int;<sub><i>h</i></sub> <b><i>B</i></b></td>
 <td>&nbsp; &harr; &nbsp;</td>
 <td><b><i>C</i></b><sub><i>j</i></sub> = 
 <b><i>M</i></b><sub><i>j</i></sub> &int;<sub><i>h</i></sub> <b><i>B</i></b><sub><i>j</i></sub>.</td></tr>
</table>

<p>Row and column mappings are associative.
A row mapping <sup>1</sup><b><i>M</i></b>
and a column mapping <sup>2</sup><b><i>M</i></b>
do not, in general, commute, but do if all rows
of <sup>1</sup><b><i>M</i></b> agree
(that is, <sup>1</sup><b><i>M</i></b> = <tt><b>∊</b></tt> 
<img src="APLimg/jottimes.bmp"> <b><i>p</i></b>),
and if all columns of <sup>2</sup><b><i>M</i></b> agree
(that is, <sup>2</sup><b><i>M</i></b> = <b><i>q</i></b> 
<img src="APLimg/jottimes.bmp"> <tt><b>∊</b></tt>).
The generalized matrix product is defined for the cases  
<b><i>M</i></b> <img src="APLimg/jotindex.bmp"> <b><i>A</i></b>, and
<b><i>M</i></b> <img src="APLimg/jotindex.bmp"> <b><i>a</i></b>.</p>

<a name="sub_row"></a>
<a name="sub_col"></a>
<p>The alternative notation (that is, <b><i>c</i></b>
= <b><i>a</i></b><sub><b><i>m</i></b></sub>),
which does not incorporate specification 
of the index origin, is particularly convenient
for matrices and is extended as follows:</p>

<table>
<td>&nbsp; &nbsp; &nbsp;</td>
 <td><b><i>A</i></b> &larr; <b><i>B</i></b><sup><b><i>m</i></b></sup></td>
 <td>&nbsp; &harr; &nbsp;</td>
 <td><b><i>A</i></b><sup><i>i</i></sup> =
 <b><i>B</i></b><sup><b><i>m</i></b><sub><i>i</i></sub></sup>,</td></tr>
<td>&nbsp;</td>
 <td><b><i>A</i></b> &larr; <b><i>B</i></b><sub><b><i>m</i></b></sub></td>
 <td>&nbsp; &harr; &nbsp;</td>
 <td><b><i>A</i></b><sub><i>i</i></sub> =
 <b><i>B</i></b><sub><b><i>m</i></b><sub><i>i</i></sub></sub>.</td></tr>
</table>



<a name="1.17.2"></a>
<p><b>Permutations</b></p>

<p>A vector <b><i>k</i></b> of dimension <i>n</i>
is called a <i>j</i>-origin <i>permutation vector</i>
if <b><i>k</i></b> <tt>≡</tt> 
<tt><b>⍳</b></tt><sup><i>j</i></sup>(<i>n</i>).
A permutation vector used to map any set
of the same dimension produces a reordering
of the set without either repetition or
suppression of elements, that is,
<b><i>k</i></b> &int;<sub>j</sub> <b><i>a</i></b>
<tt>≡</tt> <b><i>a</i></b> for any set
<b><i>a</i></b> of dimension <i>&nu;</i>(<b><i>k</i></b>).
For example, if <b><i>a</i></b> = (f,&nbsp;4,&nbsp;*,&nbsp;6,&nbsp;z), 
and <b><i>k</i></b> = (4,&nbsp;2,&nbsp;5,&nbsp;1,&nbsp;3),
then <b><i>k</i></b> &int;<sub>1</sub> <b><i>a</i></b>
= (6,&nbsp;4,&nbsp;z,&nbsp;f,&nbsp;*).</p>

<p>If <b><i>p</i></b> is an <i>h</i>-origin 
permutation vector and <b><i>q</i></b> is any
<i>j</i>-origin permutation vector of the same dimension,
then <b><i>q</i></b> &int;<sub><i>j</i></sub> <b><i>p</i></b>
is an <i>h</i>-origin permutation vector.</p>

<a name="identity_permutation"></a>
<p>Since</p>

<p>&nbsp; &nbsp; &nbsp; <tt><b>⍳</b></tt><sup><i>j</i></sup>(<i>&nu;</i>(<b><i>a</i></b>))
&int;<sub><i>j</i></sub> <b><i>a</i></b> = <b><i>a</i></b>,</p>

<p>the interval vector 
<tt><b>⍳</b></tt><sup><i>j</i></sup>(<i>n</i>)
will also be called the <i>j-origin identity 
permutation vector</i>.
If <b><i>p</i></b> and <b><i>q</i></b> are two
<i>j</i>-origin permutation vectors 
of the same dimension <i>n</i> and if
<b><i>q</i></b> &int;<sub><i>j</i></sub> <b><i>p</i></b>
= <tt><b>⍳</b></tt><sup><i>j</i></sup>(<i>n</i>),
then <b><i>p</i></b> &int;<sub><i>j</i></sub> <b><i>q</i></b>
= <tt><b>⍳</b></tt><sup><i>j</i></sup>(<i>n</i>) also
and <b><i>p</i></b> and <b><i>q</i></b> are said
to be <i>inverse</i> permutations.
If <b><i>p</i></b> is any <i>j</i>-origin permutation vector,
then <b><i>q</i></b> = <b><i>p</i></b> <tt>⍳</tt><sub><i>j</i></sub> 
<tt><b>⍳</b></tt><sup><i>j</i></sup> 
is inverse to <b><i>p</i></b>.</p>

<p>The rotation operation <i>k</i> &uarr; <b><i>x</i></b>
is a special case of permutation.</p>

<a name="1.17.3"></a>
<p><b>Function mapping</b></p>

<p>A function <i>f</i> which defines for each element
<b><i>b</i></b><sub><i>i</i></sub> of a set
<b><i>b</i></b> a unique correspondent 
<b><i>a</i></b><sub><i>k</i></sub> in a set
<b><i>a</i></b> is called a <i>mapping from</i>
<b><i>b</i></b> <i>to</i> <b><i>a</i></b>.
If <i>f</i>(<b><i>b</i></b><sub><i>i</i></sub>)
= <b><i>a</i></b><sub><i>k</i></sub>,
the element <b><i>b</i></b><sub><i>i</i></sub>
is said to <i>map into</i> the element <b><i>a</i></b><sub><i>k</i></sub>.
If the elements <i>f</i>(<b><i>b</i></b><sub><i>i</i></sub>)
exhaust the set <b><i>a</i></b>,
the function <i>f</i> is set to map <b><i>b</i></b>
onto <b><i>a</i></b>.
If <b><i>b</i></b> maps onto <b><i>a</i></b>
and the elements <i>f</i>(<b><i>b</i></b><sub><i>i</i></sub>)
are all distinct, the mapping is said to be
one-to-one or <i>biunique</i>.
In this case, <i>&nu;</i>(<b><i>a</i></b>) = <i>&nu;</i>(<b><i>b</i></b>),
and there exists an inverse mapping 
from <b><i>a</i></b> to <b><i>b</i></b>
with the same correspondences.</p>

<p>A program for performing the mapping <i>f</i>
from <b><i>b</i></b> to <b><i>a</i></b>
must therefore determine for any given element
<i>b</i> &epsilon; <b><i>b</i></b>, the correspondent
<i>a</i> &epsilon; <b><i>a</i></b>,
such that <i>a</i> = <i>f</i>(<i>b</i>).
Because of the convenience of operating upon integers
(e.g., upon register addresses or other numeric symbols)
in the automatic execution of programs,
the mapping is frequently performed 
in three successive phases,
determining in turn the following quantities:</p>

<table>
<tr><td valign=top>1.</td><td>&nbsp;</td>
 <td>the index <i>i</i> = <b><i>b</i></b> <tt>⍳</tt> <i>b</i>,</td></tr>
<tr><td valign=top>2.</td><td>&nbsp;</td>
 <td>the index <i>k</i> such that 
<b><i>a</i></b><sub><i>k</i></sub> = <i>f</i>(<b><i>b</i></b><sub><i>i</i></sub>),</td></tr>
<tr><td valign=top>3.</td><td>&nbsp;</td>
 <td>the element <b><i>a</i></b><sub><i>k</i></sub>.</td></tr>
</table>

<p>The three phases are shown in detail in Program 1.12a.
The ranking is performed (steps 1-3) by scanning 
the set <b><i>b</i></b> in order
and comparing each element with the argument <i>b</i>.
The second phase is a permutation of the integers
1, 2, &#133;, <i>&nu;</i>(<b><i>b</i></b>),
which may be described by a permutation vector <b><i>j</i></b>,
such that <b><i>j</i></b><sub><i>i</i></sub> = <i>k</i>.
The selection of <b><i>j</i></b><sub><i>i</i></sub>
(step 4) then defines <i>k</i>, which, 
in turn, determines the selection of 
<b><i>a</i></b><sub><i>k</i></sub> on step 5.</p>

<table><tr><td>&nbsp;</td><td>
<p><b>Example 1.2</b>. If</p>

<table>
<tr><td>&nbsp; &nbsp; &nbsp;</td><td><b><i>b</i></b> = (apple, booty, dust, eye, night),</td></tr>
<tr><td>&nbsp;</td><td><b><i>a</i></b> = (Apfel, Auge, Beute, Nacht, Staub)</td></tr>
</table>

<p>are, respectively, a set of English words
and a set of German correspondents
(both in alphabetical order), and if the function
required is the mapping of a given English word
<i>b</i> into its German equivalent <i>a</i>
according to the dictionary correspondences:</p>

<table>
<tr><td>&nbsp; &nbsp; &nbsp;</td><td>English:</td><td>&nbsp;</td>
 <td>apple &nbsp;</td><td>booty &nbsp;</td><td>dust &nbsp;</td><td>eye &nbsp;</td><td>night &nbsp;</td></tr>
<tr><td>&nbsp;</td><td>English:</td><td>&nbsp;</td>
 <td>Apfel &nbsp;</td><td>Beute &nbsp;</td><td>Staub &nbsp;</td><td>Auge &nbsp;</td><td>Nacht &nbsp;</td></tr>
</table>

<p>then <b><i>j</i></b> = (1, 3, 5, 2, 4).
If <i>b</i> = &ldquo;night&rdquo;, then
<i>i</i> = 5, <b><i>j</i></b><sub><i>i</i></sub> = 4,
and <i>a</i> = <b><i>a</i></b><sub>4</sub> = Nacht.</p>
</td><td>&nbsp;</td></table>

<p>If <b><i>k</i></b> is a permutation vector
inverse to <b><i>j</i></b>, then Program 1.12b
describes a mapping inverse to that of Program 1.12a.
If <b><i>j</i></b> = (1, 3, 5, 2, 4),
then <b><i>k</i></b> = (1, 4, 2, 5, 3).
The inverse mapping can also be described
in terms of <b><i>j</i></b>,
as is done in Program 1.12c.
The selection of the <i>i</i>th component
of the permutation vector is then necessarily
replaced by a scan of its components.
Programs 1.12d and 1.12e show alternative formulations
of Program 1.12a.</p>

<table align=center><tr><td><table>
<tr><td><img src="APLimg/prog1x12a.bmp"></td></tr>
<tr><td align=center>(a) <b><i>b</i></b><sub><i>i</i></sub> &harr; 
 <b><i>a</i></b><sub><b><i>j</i></b><sub><i>i</i></sub></sub></td></tr>
</table></td><td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td><td><table>
<tr><td><img src="APLimg/prog1x12b.bmp"></td></tr>
<tr><td align=center>(b) <b><i>a</i></b><sub><i>i</i></sub> &harr; 
<b><i>b</i></b><sub><b><i>k</i></b><sub><i>i</i></sub></sub></td></tr>
</table></td></tr>
<tr><td>&nbsp;</td></tr>
<tr><td rowspan=2><table>
<tr><td><img src="APLimg/prog1x12c.bmp"></td></tr>
<tr><td align=center>(c) <b><i>a</i></b><sub><i>i</i></sub> &harr; 
<b><i>b</i></b><sub><b><i>k</i></b><sub><i>i</i></sub></sub></td></tr>
</table></td><td>&nbsp;</td><td><table>
<tr><td><img src="APLimg/prog1x12d.bmp"></td></tr>
<tr><td align=center>(d) <b><i>b</i></b><sub><i>i</i></sub> &harr; 
 <b><i>a</i></b><sub><b><i>j</i></b><sub><i>i</i></sub></sub> <br>&nbsp;</td></tr>
</table></td></tr>
<tr><td>&nbsp;</td><td><table>
<tr><td><img src="APLimg/prog1x12e.bmp"></td></tr>
<tr><td align=center>(e) <b><i>b</i></b><sub><i>i</i></sub> &harr; 
 <b><i>a</i></b><sub><b><i>j</i></b><sub><i>i</i></sub></sub></td></tr>
</table></td></tr>
</table>
<br>

<table border=1 cellspacing=0 cellpadding=5 align=center width=65%><tr><td><table>
<tr><td valign=top><b><i>a</i></b></td><td nowrap>&nbsp; &nbsp; &nbsp;</td><td>
Set of correspondents in Programs (a, d, e) and set
of arguments in Programs (b, c).
</td></tr>
<tr><td valign=top><b><i>b</i></b></td><td>&nbsp;</td><td>
Set of arguments in Programs (a, d, e) and set
of correspondents in Programs (b, c).
</td></tr>
<tr><td valign=top nowrap><b><i>j</i></b>, <b><i>k</i></b></td><td>&nbsp;</td><td>
Mutually inverse permutation vectors.
</td></tr>
</table></td></tr>
</table>
<p align=center> <b>Legend</b></p>


<p align=center><b>Program 1.12&nbsp;</b>
Mapping defined by a permutation vector <i>j</i></p>



<a name="1.17.4"></a>
<p><b>Ordering vector</b></p>

<p>If <b><i>x</i></b> is a numeric vector and
<b><i>k</i></b> is a <i>j</i>-origin permutation vector
such that the components of <b><i>y</i></b> = 
<b><i>k</i></b> &int;<sub>j</sub> <b><i>x</i></b>
are in ascending order, then <b><i>k</i></b>
is said to <i>order</i> <b><i>x</i></b>.
The vector <b><i>k</i></b> can be determined
by an ordering operation defined as follows:</p>

<p>&nbsp; &nbsp; &nbsp; <b><i>k</i></b> &larr; 
<i>&theta;</i><sub><i>j</i></sub>/<b><i>x</i></b></p>

<p>implies that <b><i>k</i></b> is a <i>j</i>-origin
permutation vector, and that if 
<b><i>y</i></b> = <b><i>k</i></b> &int;<sub><i>j</i></sub>
<b><i>x</i></b>, then either
<b><i>y</i></b><sub><i>i</i></sub>&nbsp;&lt;&nbsp;<b><i>y</i></b><sub><i>i</i>+1</sub> or 
<b><i>y</i></b><sub><i>i</i></sub>&nbsp;=&nbsp;<b><i>y</i></b><sub><i>i</i>+1</sub> and
<b><i>k</i></b><sub><i>i</i></sub>&nbsp;&lt;&nbsp;<b><i>k</i></b><sub><i>i</i>+1</sub>.
The resulting vector <b><i>k</i></b> is unique
and preserves the original relative order
among equal components.  For example, if
<b><i>x</i></b> = (7,&nbsp;3,&nbsp;5,&nbsp;3),
then <i>&theta;</i><sub>1</sub>/<b><i>x</i></b> =
(2,&nbsp;4,&nbsp;3,&nbsp;1).</p>

<p>The ordering operation is extended to arbitrary vectors
by treating all nonnumeric quantities as equal
and as greater than any numeric quantity.
For example, if <b><i>a</i></b> = 
<nobr>(7, <tt>∘</tt>, 3,<tt>∘</tt>, 5, 3),</nobr>
then <i>&theta;</i><sub>1</sub>/<b><i>a</i></b> =
<nobr>(3, 6, 5, 1, 2, 4),</nobr>
and if <b><i>b</i></b> is any vector 
with no numerical components, then 
<i>&theta;</i><sub><i>j</i></sub>/<b><i>b</i></b> = 
<tt><b>⍳</b></tt><sup><i>j</i></sup>(<i>&nu;</i>(<b><i>b</i></b>)).</p>

<p>Ordering of a vector <b><i>a</i></b> with respect
to a vector <b><i>b</i></b> is achieved by ordering
the <b><i>b</i></b>-index of <b><i>a</i></b>.
For example, if <b><i>a</i></b> =
(e,&nbsp;a,&nbsp;s,&nbsp;t,&nbsp;4,&nbsp;7,&nbsp;t,&nbsp;h), and <b><i>b</i></b>
is the alphabet, then 
<b><i>m</i></b> = <b><i>b</i></b> <tt>⍳</tt><sub>1</sub>
<b><i>a</i></b> = (5,&nbsp;1,&nbsp;19,&nbsp;20,&nbsp;<tt>∘</tt>,&nbsp;<tt>∘</tt>,&nbsp;20,&nbsp;8)
and <i>&theta;</i><sub>1</sub>/<b><i>m</i></b> =
(2,&nbsp;1,&nbsp;8,&nbsp;3,&nbsp;4,&nbsp;7,&nbsp;5,&nbsp;6).</p>

<a name="theta_col"></a>
<p>The ordering operation is extended to matrices
by the usual convention.
If <b><i>K</i></b> = 
<i>&theta;</i><sub><i>j</i></sub>//<b><i>A</i></b>,
then each column of the matrix 
<b><i>B</i></b> = <b><i>K</i></b> &int;&int;<sub><i>j</i></sub> <b><i>A</i></b>
is in ascending order.
<br>&nbsp;</p>



<a name="1.18"></a>
<p><b>1.18 Maximization</b></p>

<p>In determining the maximum <i>m</i> over components
of a numerical vector <i>x</i>, 
it is often necessary to determine the indices
of the maximum components as well.
The maximization operator is therefore defined
so as to determine a logical vector <b><i>v</i></b>
such that <b><i>v</i></b>/<b><i>x</i></b> =
<i>m</i><tt><b>∊</b></tt>.</p>

<p>Maximization over the entire vector <b><i>x</i></b>
is denoted by <tt><b>∊</b></tt><tt>⌈</tt><b><i>x</i></b>,
and is defined as follows:
if <b><i>v</i></b> = <tt><b>∊</b></tt><tt>⌈</tt><b><i>x</i></b>,
then there exists a quantity <i>m</i> such that
<b><i>v</i></b>/<b><i>x</i></b> = <i>m</i><tt><b>∊</b></tt>
and such that all components of 
<img src="APLimg/vboscore.bmp">/<b><i>x</i></b>
are strictly less than <i>m</i>.
The maximization is assumed by a single component
of <b><i>x</i></b> if and only if +/<b><i>v</i></b> = 1.
The actual value of the maximum is given by the first
(or any) component of <b><i>v</i></b>/<b><i>x</i></b>.
Moreover, the <i>j</i>-origin indices of the maximum components
are the components of the vector 
<b><i>v</i></b>/<tt><b>⍳</b></tt><sup><i>j</i></sup>.</p>

<a name="maximum_selector"></a>
<p>More generally, the maximization operation
<b><i>v</i></b> &larr; <b><i>u</i></b><tt>⌈</tt><b><i>x</i></b>
will be defined so as to determine the maximum
over the subvector <b><i>u</i></b>/<b><i>x</i></b> only,
but to express the result <b><i>v</i></b>
with respect to the entire vector <b><i>x</i></b>.
More precisely,</p>

<p>&nbsp; &nbsp; &nbsp; <b><i>v</i></b> &larr; 
<b><i>u</i></b><tt>⌈</tt><b><i>x</i></b>
&nbsp;&harr;&nbsp; <b><i>v</i></b> = 
<b><i>u</i></b>\(<tt><b>∊</b></tt><tt>⌈</tt>(<b><i>u</i></b>/<b><i>x</i></b>)).</p>

<p>The operation may be visualized as follows &mdash;
a horizontal plane punched at points corresponding
to the zeros of <b><i>u</i></b> is lowered
over a plot of the components of <b><i>x</i></b>,
and the positions at which the plane first touches them
are the positions of the unit components of <b><i>v</i></b>.
For example, maximization over the negative components
of <b><i>x</i></b> is denoted by</p>

<p>&nbsp; &nbsp; &nbsp; <b><i>v</i></b> &larr; 
(<b><i>x</i></b> &lt; 0)<tt>⌈</tt><b><i>x</i></b></p>

<p>and if <b><i>x</i></b> = 
(2,&nbsp;&ndash;3,&nbsp;7,&nbsp;&ndash;5,&nbsp;4,&nbsp;&ndash;3,&nbsp;6),
then (<b><i>x</i></b> &lt; 0) = (0,&nbsp;1,&nbsp;0,&nbsp;1,&nbsp;0,&nbsp;1,&nbsp;0),
<b><i>v</i></b> = (0,&nbsp;1,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;1,&nbsp;0),
<b><i>v</i></b>/<b><i>x</i></b> = (&ndash;3,&nbsp;&ndash;3),
(<b><i>v</i></b>/<b><i>x</i></b>)<sub>1</sub> = &ndash;3,
and <b><i>v</i></b>/<tt><b>⍳</b></tt><sup>1</sup> = (2,&nbsp;6).
<a name="minimum_selector"></a>
Minimization is defined analogously 
and is denoted by <b><i>u</i></b><tt>⌊</tt><b><i>x</i></b>.</p>

<p>The extension of maximization and minimization
to arbitrary vectors is the same as
for the ordering operation, i.e., all nonnumeric
quantities are treated as equal and as exceeding
all numeric quantities.
<a name="max_row"></a>
<a name="max_col"></a>
The extensions to matrices are denoted
and defined as follows:</p>

<table>
<tr><td>&nbsp; &nbsp; &nbsp;</td>
 <td><b><i>V</i></b> &larr; <b><i>U</i></b> <tt>⌈</tt> <b><i>X</i></b></td>
 <td>&nbsp; &harr; &nbsp;</td>
 <td><b><i>V</i></b><sup><i>&nbsp;i</i></sup></td>
 <td>=</td><td><b><i>U</i></b><sup><i>&nbsp;i</i></sup> 
  <tt>⌈</tt> <b><i>X</i></b><sup><i>&nbsp;i</i></sup>,</td></tr>
<tr><td>&nbsp;</td>
 <td><b><i>V</i></b> &larr; <b><i>U</i></b> <tt>⌈⌈</tt> <b><i>X</i></b></td>
 <td>&nbsp; &harr; &nbsp;</td>
 <td><b><i>V</i></b><sub><i>j</i></sub></td>
 <td>=</td><td><b><i>U</i></b><sub><i>j</i></sub> 
  <tt>⌈</tt> <b><i>X</i></b><sub><i>j</i></sub>,</td></tr>
<tr><td>&nbsp; &nbsp; &nbsp;</td>
 <td><b><i>V</i></b> &larr; <b><i>U</i></b> <img src="APLimg/jotmax.bmp"> <b><i>x</i></b></td>
 <td>&nbsp; &harr; &nbsp;</td>
 <td><b><i>V</i></b><sup><i>&nbsp;i</i></sup></td>
 <td>=</td><td><b><i>U</i></b><sup><i>&nbsp;i</i></sup> 
  <tt>⌈</tt> <b><i>x</i></b>,</td></tr>
<tr><td>&nbsp;</td>
 <td><b><i>V</i></b> &larr; <b><i>u</i></b> <img src="APLimg/jotmax.bmp"> <b><i>X</i></b></td>
 <td>&nbsp; &harr; &nbsp;</td>
 <td><b><i>V</i></b><sub><i>j</i></sub></td>
 <td>=</td><td><b><i>u</i></b> 
  <tt>⌈</tt> <b><i>X</i></b><sub><i>j</i></sub>.</td></tr>
</table>

<p>As in the case of the ordering operation,
maximization in a vector <b><i>a</i></b>
with respect to order in a set <b><i>b</i></b>
is achieved by maximizing over the <b><i>b</i></b>-index
of <b><i>a</i></b>.  Thus if</p>

<table>
<tr><td rowspan=2>&nbsp; &nbsp; &nbsp; <b><i>H</i></b></td>
 <td rowspan=2>&nbsp; = &nbsp;</td>
 <td rowspan=2><img src="APLimg/matrixl2.bmp"></td>
 <td><sup>&nbsp;</sup><tt>d c h d h s h d c h c h d</tt><sub>&nbsp;</sub></td>
 <td rowspan=2><img src="APLimg/matrixr2.bmp"></td></tr>
<tr>
 <td><sup>&nbsp;</sup><tt>a 6 k q 4 3 5 k 8 2 j 9 2</tt><sub>&nbsp;</sub></td></tr>
</table>

<p>represents a hand of thirteen playing cards, and if</p>

<table>
<tr><td rowspan=2 align=right>&nbsp; &nbsp; &nbsp; <b><i>B</i></b></td>
 <td rowspan=2>&nbsp; = &nbsp;</td>
 <td rowspan=2><img src="APLimg/matrixl2.bmp"></td>
 <td><sup>&nbsp;</sup><tt>c d h s ∘ ∘ ∘ ∘ ∘ &nbsp;∘ ∘ ∘ ∘</tt><sub>&nbsp;</sub></td>
 <td rowspan=2><img src="APLimg/matrixr2.bmp"></td>
 <td rowspan=2>,</td></tr>
<tr>
 <td><sup>&nbsp;</sup><tt>2 3 4 5 6 7 8 9 10 j q k a</tt><sub>&nbsp;</sub></td></tr>
</table>

then

<table>
<tr><td rowspan=2 align=right>&nbsp; &nbsp; &nbsp; <b><i>B</i></b> <tt>⍳</tt><sub>0</sub> <b><i>H</i></b></td>
 <td rowspan=2>&nbsp; = &nbsp;</td>
 <td rowspan=2><img src="APLimg/matrixl2.bmp"></td>
 <td><sup>&nbsp;</sup><tt>&nbsp;1 0 &nbsp;2 &nbsp;1 2 3 2 &nbsp;1 0 2 0 2 1</tt><sub>&nbsp;</sub></td>
 <td rowspan=2><img src="APLimg/matrixr2.bmp"></td>
 <td rowspan=2>,</td></tr>
<tr>
 <td><sup>&nbsp;</sup><tt>12 4 11 10 2 1 3 11 6 0 9 7 0</tt><sub>&nbsp;</sub></td></tr>
</table>

<p>&nbsp; &nbsp; &nbsp; (4, 13) <img src="APLimg/jotbase.bmp">
 (<b><i>B</i></b> <tt>⍳</tt><sub>0</sub> <b><i>H</i></b>) &nbsp; = &nbsp;
 (25, 4, 37, 23, 28, 40, 29, 24, 6, 26, 9, 33, 13),</p>

and
<p>&nbsp; &nbsp; &nbsp; (<tt><b>∊</b></tt><tt>⌈</tt>((4, 13) <img src="APLimg/jotbase.bmp">
(<b><i>B</i></b> <tt>⍳</tt><sub>0</sub> <b><i>H</i></b>)))/<b><i>H</i></b>
&nbsp; = &nbsp; (s,&nbsp;3)</p>

<p>is the highest ranking card in the hand.
<br>&nbsp;</p>



<a name="1.19"></a>
<p><b>1.19 Inverse functions</b></p>

<p>To every biunique<sup><a href="APL1.htm#note1f">[f]</a></sup> function <i>f</i>
there corresponds an <i>inverse</i> function <i>g</i>
such that <i>g</i>(<i>f</i>(<i>x</i>)) = <i>x</i>
for each argument <i>x</i> in the domain 
of the function <i>f</i>.
It is common practice either to introduce
a distinct symbolism for the inverse function,
as for the inverse functions of logarithm
(log<sub>b</sub> <i>x</i>) and exponentiation
(<i>b</i>&sup3;), or to use a
superscript &ndash;1, as in sin<sup>&ndash;1</sup><i>x</i>
or <i>f</i><sup>&nbsp;&ndash;1</sup>(<i>x</i>).</p>

<p>The first alternative doubles the number
of distinct operator symbols required
and obscures the relation between pairs 
of inverse functions;
the second raises other difficulties.
The solution adopted here is that of
<i>implicit</i> specification; i.e. a statement
is permitted to specify not only a variable
but also any function of that variable.
Functions may therefore appear on both sides
of the specification arrow in a statement.
For example,</p>

<p>&nbsp; &nbsp; &nbsp; (2<tt><b>∊</b></tt>) <tt>⊥</tt> <i>x</i> &larr; <i>z</i></p>

<p>specifies the variable <i>x</i> as the vector
whose base two value is the number <i>z</i>.</p>

<p>Certain ambiguities remain in the foregoing statement.
First, the dimension of <i>x</i> is not specified.
For example, if <i>z</i> = 12, 
<i>x</i> = (1, 1, 0, 0) is an admissible solution,
but so are (0, 1, 1, 0, 0) and (0, 0, 0, 1, 1, 0, 0).
This could be clarified by compatibility 
with a specified dimension of <tt><b>∊</b></tt>.
Thus the statement</p>

<p>&nbsp; &nbsp; &nbsp; (2<tt><b>∊</b></tt>(5)) <tt>⊥</tt> <i>x</i> &larr; <i>z</i></p>

<p>specifies <i>x</i> unambiguously as (0, 1, 1, 0, 0).
More generally, however, any previously specified
auxiliary variables will be listed to the right
of the main statement, 
with a semicolon serving as a separation symbol.
The current example could therefore be written as</p>

<p>&nbsp; &nbsp; &nbsp; <i>&nu;</i>(<i>x</i>) &larr; 5<br>
&nbsp; &nbsp; &nbsp; (2<tt><b>∊</b></tt>) <tt>⊥</tt> <i>x</i> &larr; 
<i>z</i>; &nbsp; <i>&nu;</i>(<i>x</i>)</p>

<p>The second ambiguity concerns the permissible range
of the individual components of <i>x</i>.
For example, the base two value 
of <i>x</i> = (5, 2) is also twelve.
For certain functions it is therefore necessary
to adopt some obvious conventions concerning
the range of the result.
The assumption implicit in the preceding paragraph
is that each component of <i>x</i> is limited
to the range of the residues modulo 
the corresponding radix.
This convention will be adopted.
Hence the pair of statements</p>

<p>&nbsp; &nbsp; &nbsp; <i>y</i> &larr; (7, 24, 60, 60)<br>
&nbsp; &nbsp; &nbsp; <i>y</i> <tt>⊥</tt> <i>x</i> &larr; 7278; <i>y</i></p>

<p>determines <i>x</i> unambiguously 
as the vector (0, 2, 1, 18).</p>

<p>it is also convenient, though not essential,
to use selection operations on the left of a statement.
Thus the statement</p>

<p>&nbsp; &nbsp; &nbsp; <b><i>u</i></b>/<b><i>b</i></b> &larr; <b><i>a</i></b></p>

<p>is understood to respecify only the selected
components of <b><i>b</i></b> and to leave
all others unchanged.
It is therefore equivalent to the statement</p>

<p>&nbsp; &nbsp; &nbsp; <b><i>b</i></b> &larr; 
\<img src="APLimg/uboscore.bmp">/<b><i>b</i></b>, <b><i>u</i></b>, <b><i>a</i></b>\.</p>

<p>Similarly,</p>

<p>&nbsp; &nbsp; &nbsp; <b><i>u</i></b>/<b><i>b</i></b> &larr; 
<b><i>u</i></b>/<b><i>a</i></b></p>

<p>is equivalent to</p>

<p>&nbsp; &nbsp; &nbsp; <b><i>b</i></b> &larr; 
/<b><i>b</i></b>, <b><i>u</i></b>, <b><i>a</i></b>/.
<br>&nbsp;</p>



<a name="1.20"></a>
<p><b>1.20 Levels of structure</b></p>

<p>Vectors and matrices are arrays which exhibit
one level and two levels of structure, respectively.
Although in certain fields, such as tensor analysis,
it is convenient to define more general arrays
whose <i>rank</i> specifies the number of levels
of structure
(i.e., zero for a scalar, 
one for a vector of scalars,
two for a vector of vectors (matrix),
three for a vector of matrices, etc.),
the notation will here be limited 
to the two levels provided 
by the matrix.<sup><a href="APL1.htm#note1g">[g]</a></sup> 
The present section will, however, indicate
methods for removing this limitation.</p>

<p>The only essential particularization
to two levels occurs in the provision
of single and double symbols
(e.g. &ldquo;/&rdquo; and &ldquo;//&rdquo;,
&ldquo;<tt>⊥</tt>&rdquo; and &ldquo;<img src="APLimg/decode2.bmp">&rdquo;)
for row and column operations, respectively,
and in the use of superscripts and subscripts
for denoting rows and columns,  respectively.
In applications requiring multiple levels,
the former can be generalized 
by adjoining to the single symbol
an index which specifies the coordinate
(e.g. &ldquo;/<sub>1</sub>&rdquo; and 
&ldquo;/<sub>2</sub>&rdquo;,
for row and for column compression, and,
in general, &ldquo;/<sub><i>j</i></sub>&rdquo;.)
The latter can be generalized 
by using a vector index subscript 
possessing one component index 
for each coordinate.</p>

<p>The generalized notation can be made
compatible with the present notation 
for vectors and matrices by adopting the name
<i>tensor</i> and a symbol class
(such as capital letters) 
for the general array of arbitrary rank.
<br>&nbsp;</p>



<a name="1.21"></a>
<p><b>1.21 Subroutines</b></p>

<p>Detail can be subordinated in a more general manner
by the use of subroutines.
The name of one program appearing as a single statement
in a second program implies execution 
of the named program at that point;
the named program is called a <i>subroutine</i>
of the second program.
If, for example, &ldquo;Cos&rdquo; is the name
of a program which specifies <i>z</i> as the cosine
of the angle between the vectors <b><i>x</i></b>
and <b><i>y</i></b>, then Program 1.13a
uses the program &ldquo;Cos&rdquo;
as a subroutine to determine <i>r</i>
as the cosine of the angle between
the vectors <b><i>p</i></b> and <b><i>q</i></b>.</p>

<table align=center>
<tr><td valign=top><img src="APLimg/prog1x13a.bmp"></td><td>&nbsp;</td>
 <td valign=top><img src="APLimg/prog1x13b.bmp"></td><td>&nbsp;</td>
 <td valign=top><img src="APLimg/prog1x13c.bmp"></td></tr>
<tr><td align=center>(a)</td><td>&nbsp; &nbsp; &nbsp;</td>
 <td align=center>(b)</td><td>&nbsp; &nbsp; &nbsp;</td>
 <td align=center>(c)</td></tr>
</table>

<p align=center><b>Program 1.13&nbsp;</b>
Modes of subroutine reference</p>

<p>It is sometimes convenient to include
the names of the arguments or results or both
in the name of the subroutine as dummy variables.
Thus if &ldquo;Cos(<b><i>x</i></b>,&nbsp;<b><i>y</i></b>)&rdquo;
is the name of a subroutine which determines <i>z</i>
as the cosine of the angle 
between <b><i>x</i></b> and <b><i>y</i></b>,
then Program 1.13b uses Cos(<i>x</i>,&nbsp;<i>y</i>)
as a subroutine to determine <i>r</i> as the
cosine of the angle 
between <b><i>p</i></b> and <b><i>q</i></b>.
Similarly, the program &ldquo;<i>z</i> &larr; Cos(<i>x</i>,&nbsp;<i>y</i>)&rdquo;
can be used as in Program 1.13c 
to produce the same result.
<br>&nbsp;</p>



<a name="1.22"></a>
<p><b>1.22 Files</b></p>

<p>Many devices used for the storage of information
impose certain restrictions 
upon its insertion or withdrawal.
The items recorded on a magnetic tape,
for example, may be read from the tape much more
quickly in the order in which they appear
physically on the tape than 
in some other prescribed order.</p>

<p>Certain storage devices are also self-indexing
in the sense that the item selected in the next read
from the device will be determined 
by the current state or position of the device.
The next item read from a magnetic tape,
for example, is determined by the position
in which the tape was left
by the last preceding read operation.</p>

<p>To allow the convenient description 
of algorithms constrained by the characteristics
of storage devices,
the following notation will be adopted.
<a name="file_defn"></a>
A <i>file</i> is a representation 
of a vector <b><i>x</i></b> arranged as follows:</p>

<p>&nbsp; &nbsp; &nbsp; 
<b><i>p</i></b><sub>1</sub>, <b><i>x</i></b><sub>1</sub>,
<b><i>p</i></b><sub>2</sub>, <b><i>x</i></b><sub>2</sub>, &#133;,
<b><i>x</i></b><sub><i>&nu;</i>(<b><i>x</i></b>)</sub>, 
<b><i>p</i></b><sub><i>&nu;</i>(<b><i>x</i></b>) + 1</sub>, <tt>∘</tt>, 
<b><i>p</i></b><sub><i>&nu;</i>(<b><i>x</i></b>) + 2</sub>, 
<tt>∘</tt>, &#133;, <b><i>p</i></b><sub><i>&nu;</i>(<b><i>p</i></b>)</sub>.</p>

<p>The null elements denote 
&ldquo;unused&rdquo; portion of the file
not employed in representing <b><i>x</i></b>.
Each <i>partition</i> <b><i>p</i></b><sub><i>j</i></sub>
determines a <i>position</i> (position <i>j</i>)
in the file.
<a name="forward_read"></a>
If a file <b>&Phi;</b> is in position <i>j</i>,
then a <i>forward read</i>, denoted by</p>

<p>&nbsp; &nbsp; &nbsp; 
<i>x</i>, <i>p</i> &larr; <sub>0</sub><b>&Phi;</b>,</p>

<p>specifies <i>x</i> by the component 
<b><i>x</i></b><sub><i>j</i></sub>,
the auxiliary variable <i>p</i> by the succeeding partition
<b><i>p</i></b><sub><i>j</i>+1</sub>,
and stops the file 
in the position <i>j</i>&nbsp;+&nbsp;1.</p>

<a name="file_position"></a>
<p>The position of a file <b>&Phi;</b>
will be denoted by <i>&pi;</i>(<b>&Phi;</b>).
Thus the statement 
<nobr><i>j</i> &larr; <i>&pi;</i>(<b>&Phi;</b>)</nobr>
specifies <i>j</i> as the position of <b>&Phi;</b>,
whereas 
<nobr><i>&pi;</i>(<b>&Phi;</b>) &larr; <i>j</i></nobr>
<i>positions</i> the file to <i>j</i>.
In particular, <nobr><i>&pi;</i>(<b>&Phi;</b>) &larr; 1</nobr>
denotes the <i>rewinding</i> of the file and
<nobr><i>&pi;</i>(<b>&Phi;</b>) &larr; <i>&nu;</i></nobr>
denotes <i>winding</i>, i.e. positioning 
to the extreme end of the file.
Any file for which the general positioning operation
<nobr><i>&pi;</i>(<b>&Phi;</b>) &larr; <i>j</i></nobr>
is to be avoided as impossible or inefficient
is called a <i>serial</i> 
or <i>serial-access</i> file.</p>

<p>Each terminal partition (that is,
<b><i>p</i></b><sub>1</sub> and
<b><i>p</i></b><sub><i>&nu;</i>(<b><i>p</i></b>)</sub>)
assumes a single fixed value denoted by <i>&lambda;</i>.
Each nonterminal partition 
<b><i>p</i></b><sub><i>j</i></sub>
may assume one of several values denoted by
<nobr><b>&lambda;</b><sub>1</sub>,
<b>&lambda;</b><sub>2</sub>, &#133;,
<b>&lambda;</b><sub><i>&nu;</i>(<b>&lambda;</b>)</sub>,</nobr>
the partitions with larger indices normally
demarking larger subgroups of components
within the file.
Thus if <b><i>x</i></b> were the row list of a matrix,
the last component might be followed by
the partition <b>&lambda;</b><sub>3</sub>,
the last component of each of the preceding
rows by <b>&lambda;</b><sub>2</sub>,
and the remaining components by <b>&lambda;</b><sub>1</sub>.
The auxiliary variable <i>p</i> specified
by the partition symbol
during the read of a file is normally used
to control a subsequent branch.</p>

<a name="forward_record"></a>
<p>A file may be produced by a sequence
of <i>forward record</i> statements:</p>

<p>&nbsp; &nbsp; &nbsp;
<sub>0</sub><b>&Phi;</b> &larr; 
<b><i>x</i></b><sub><i>i</i></sub>, <i>p</i>
&nbsp; &nbsp; &nbsp; for <i>i</i> &epsilon; 
<tt><b>⍳</b></tt><sup>1</sup>(<i>&nu;</i>(<b><i>x</i></b>)),</p>

<p>where <i>p</i> is the partition symbol recorded 
after the component <b><i>x</i></b><sub><i>i</i></sub>.
As in reading, each forward record operation
increments the position of the file by one.
A file which is only recorded during a process
is called an <i>output file</i>
of the process;
a file which is only read is called 
an <i>input file</i>.</p>

<p>Different files occurring in a process
will be distinguished 
by righthand subscripts and superscripts,
the latter being usually employed
to denote major classes of files,
such as input and output.</p>

<table><tr><td>&nbsp;</td><td>
<p><b>Example 1.3</b>. A set of <i>m</i> input files
<b>&Phi;</b><sub><i>i</i></sub><sup>1</sup>,
<i>i</i> &epsilon; <tt><b>⍳</b></tt><sup>1</sup>(<i>m</i>),
each terminated by a partition <i>&lambda;</i><sub>2</sub>,
is to be copied to a single output file
<b>&Phi;</b><sub>1</sub><sup>2</sup>
as follows.
Successive items (components) are chosen
in turn from files
<nobr><b>&Phi;</b><sub>1</sub><sup>1</sup>,
<b>&Phi;</b><sub>2</sub><sup>1</sup>, &#133;,
<b>&Phi;</b><sub><i>m</i></sub><sup>1</sup>,
<b>&Phi;</b><sub>1</sub><sup>1</sup>,
<b>&Phi;</b><sub>2</sub><sup>1</sup>, &#133;,</nobr>
always omitting from the sequence any exhausted file.
A partition <i>&lambda;</i><sub>2</sub>
is to be recorded with the last item
recorded on <b>&Phi;</b><sub>1</sub><sup>2</sup>,
and all files are to be rewound.
The process is described by Program 1.14.</p>
</td><td>&nbsp;</td></tr></table>
<br>

<table align=center>
<tr><td><img src="APLimg/prog1x14.bmp"></td>
 <td>&nbsp; &nbsp; &nbsp;</td>
 <td valign=top><table border=1 cellspacing=0 cellpadding=4><tr><td>
  <table>
  <tr><td valign=top><b>&Phi;</b><sub><i>i</i></sub><sup>1</sup></td>
   <td>&nbsp; &nbsp;</td>
   <td>Input files for <i>i</i> &epsilon; <tt><b>⍳</b></tt><sup>1</sup>(<i>m</i>).</td>
   </tr>
  <tr><td valign=top><b>&Phi;</b><sub>1</sub><sup>2</sup></td>
   <td>&nbsp;</td><td>Output file.</td>
   </tr>
  <tr><td valign=top><b><i>u</i></b></td>
   <td>&nbsp;</td>
   <td>File <b>&Phi;</b><sub><i>i</i></sub><sup>1</sup> is exhausted<br>
    if and only if <b><i>u</i></b><sub><i>i</i></sub> = 1.</td>
  <tr><td valign=top><i>b</i></td>
   <td>&nbsp;</td><td>Item to be recorded.</td>
   </tr>
  </table>
 </td></tr></table> <p align=center><b>Legend</p></td></tr>
<tr><td colspan=3 align=center><b>Program 1.14</b> &nbsp; Program for Example 1.3</td></tr> 
</table>
<br>

<table><tr><td>&nbsp;</td><td>
<p><b>Program 1.14</b>. Step 8 cycles <i>k</i> 
through the values 1 to <i>m</i>, 
and step 9 allows the read on steps 10 to occur only if 
<b><i>u</i></b><sub><i>k</i></sub> = 0.
The logical vector <b><i>u</i></b> is
of dimension <i>m</i> and designates 
the set of exhausted files.
Its <i>k</i>th component is set to unity
by step 11 when file <i>k</i> is exhausted,
as indicated by the occurrence 
of the partition <b>&lambda;</b><sub>2</sub>.
Each read is normally followed by step 13,
which records on the output file the item read.
However, when the last file becomes exhausted,
step 14 is executed instead to record
the last item, together with the final 
partition <b>&lambda;</b><sub>2</sub>.</p>

<p>Steps 1-6 initialize the parameters
<b><i>u</i></b> and <i>k</i> and rewind all files.
After the last item is recorded by step 14,
the file rewinds are repeated 
before the final termination on step 7.</p>
</td><td>&nbsp;</td></tr></table>

<p>It is sometimes convenient to suppress
explicit reference to the partition symbol
read from a file by using a statement of the form<br>

<table>
<tr><td>&nbsp; &nbsp; &nbsp;</td><td><img src="APLimg/filebranch.bmp">
 </td><td valign=middle>,</td></tr>
</table>

where the indicated branches depend on the value
of the partition <b><i>p</i></b><sub><i>j</i>+1</sub>
which terminates the read.
Thus the left or the right branch is taken
according to whether 
<b><i>p</i></b><sub><i>j</i>+1</sub> = <b><i>&lambda;</i></b><sub>1</sub> or
<b><i>p</i></b><sub><i>j</i>+1</sub> = <b><i>&lambda;</i></b><sub>2</sub>.
Certain files (such as the IBM 7090 tape files)
permit only such &ldquo;immediate&rdquo; branching
and do not permit the partition symbol 
to be stored for use in later operations,
as was done in Program 1.14.</p>

<p>In recording, the lowest level partition 
<b><i>&lambda;</i></b><sub>1</sub> may be elided.
Thus statement 13 of Program 1.14 may be written as</p>

<p>&nbsp; &nbsp; &nbsp;
<b>&Phi;</b><sub>1</sub><sup>2</sup> &larr; <i>b</i>.</p>

<a name="backward_read"></a>
<a name="backward_record"></a>
<p>A file may be read or recorded backward as well as forward.
A backward read is denoted by</p>

<p>&nbsp; &nbsp; &nbsp;
<i>x</i>, <i>p</i> &larr; <sub>1</sub><b>&Phi;</b>,</p>

<p>and if <b>&Phi;</b> is initially in position 
<nobr><i>j</i> + 1</nobr>, then
<i>x</i> = <b><i>x</i></b><sub><i>&nbsp;j</i></sub>, 
<i>p</i> = <b><i>p</i></b><sub><i>&nbsp;j</i></sub>, 
and the final position becomes <i>j</i>.
Backward recording is defined analogously.
The zero prescript may be omitted from
the symbol <sub>0</sub><b>&Phi;</b>
for both forward reading and recording.</p>

<a name="file_array"></a>
<p>The conventions used for matrices can be applied
in an obvious way to an array of files
<b>&Phi;</b><sub><i>&nbsp;j</i></sub><sup><i>i</i></sup>.
For example, the statement</p>

<p>&nbsp; &nbsp; &nbsp;
<i>&pi;</i>(<b>&Phi;</b><sup><i>&nbsp;i</i></sup>) 
&larr; <tt><b>∊</b></tt></p>

<p>denotes the rewinding of the <i>row of files</i>
<b>&Phi;</b><sub><i>&nbsp;j</i></sub><sup><i>&nbsp;i</i></sup>,&nbsp;
<i>j</i> &epsilon; 
<tt><b>⍳</b></tt><sup>1</sup>(<i>&nu;</i>(<b>&Phi;</b>));
the statement</p>

<p>&nbsp; &nbsp; &nbsp;
<i>&pi;</i>(<b>&Phi;</b><sub><i>&nbsp;j</i></sub>) 
&larr; <tt><b>∊</b></tt></p>

<p>denotes the rewinding of the <i>column of files</i>
<b>&Phi;</b><sub><i>&nbsp;j</i></sub><sup><i>&nbsp;i</i></sup>,&nbsp;
<i>i</i> &epsilon; 
<tt><b>⍳</b></tt><sup>1</sup>(<i>&mu;</i>(<b>&Phi;</b>));
and the statement</p>

<p>&nbsp; &nbsp; &nbsp;
<b><i>u</i></b>/<b>&Phi;</b><sup><i>&nbsp;i</i></sup> 
&larr; <b><i>u</i></b>/<b><i>x</i></b>, 
<b><i>u</i></b>/<b><i>p</i></b></p>

<p>denotes the recording of the vector components
<b><i>x</i></b><sub><i>&nbsp;j</i></sub>
on the file 
<b>&Phi;</b><sub><i>&nbsp;j</i></sub><sup><i>&nbsp;i</i></sup>
together with partition 
<b><i>p</i></b><sub><i>&nbsp;j</i></sub>
for all <i>j</i> such that 
<b><i>u</i></b><sub><i>&nbsp;j</i></sub> = 1.</p>

<p>As for vectors and matrices,
<i>j</i>-origin indexing may be used
and will apply to the indexing of the file positions
and the partition vector <b>&lambda;</b>
as well as to the array indices.
However, the prescripts 
(denoting direction of read and record)
are independent of index origin.
0-origin indexing is used 
in the following example.</p>

<table><tr><td>&nbsp;</td><td>
<p><b>Example 1.4</b>.
Files <b>&Phi;</b><sub>0</sub><sup>0</sup> and
<b>&Phi;</b><sub>1</sub><sup>0</sup> contain
the vectors <b><i>x</i></b> and <b><i>y</i></b>,
respectively, each of dimension <i>n</i>.
In the first phase, the components are to be merged
in the order
<nobr><b><i>x</i></b><sub>0</sub>, <b><i>y</i></b><sub>0</sub>,
<b><i>x</i></b><sub>1</sub>, <b><i>y</i></b><sub>1</sub>, &#133;
<b><i>x</i></b><sub><i>&nbsp;&nu;</i>&ndash;1</sub>, 
<b><i>y</i></b><sub><i>&nbsp;&nu;</i>&ndash;1</sub>,</nobr>
and the first <i>n</i> components of the resulting vector
are to be recorded on file <b>&Phi;</b><sub>0</sub><sup>1</sup>,
and the last <i>n</i> on file
<b>&Phi;</b><sub>1</sub><sup>1</sup>.
In other words, the vectors
<nobr><b><i>x</i></b><sup>1</sup> = 
<tt><b>⍺</b></tt><sup><i>n</i></sup>/<b><i>z</i></b></nobr> and
<nobr><b><i>y</i></b><sup>1</sup> = 
<tt><b>⍵</b></tt><sup><i>n</i></sup>/<b><i>z</i></b></nobr>
are to be recorded on 
<b>&Phi;</b><sub>0</sub><sup>1</sup> and
<b>&Phi;</b><sub>1</sub><sup>1</sup>, respectively,
where <nobr><b><i>z</i></b> = \<b><i>x</i></b>, <b><i>u</i></b>,
<b><i>y</i></b>\,</nobr> and
<nobr><b><i>u</i></b> = (0, 1, 0, 1, &#133;, 0, 1).</nobr>
In the next phase, the roles of input and output files
are reversed, and the same process is performed
on <b><i>x</i></b><sup>1</sup> and <b><i>y</i></b><sup>1</sup>,
that is, 
<nobr><b><i>x</i></b><sup>2</sup> = 
<tt><b>⍺</b></tt><sup><i>n</i></sup>/(\<b><i>x</i></b><sup>1</sup>, 
<b><i>u</i></b>,
<b><i>y</i></b><sup>1</sup>\)</nobr> and
<nobr><b><i>y</i></b><sup>2</sup> = 
<tt><b>⍵</b></tt><sup><i>n</i></sup>/(\<b><i>x</i></b><sup>1</sup>, 
<b><i>u</i></b>,
<b><i>y</i></b><sup>1</sup>\)</nobr> 
are recorded on
<b>&Phi;</b><sub>0</sub><sup>0</sup> and
<b>&Phi;</b><sub>1</sub><sup>0</sup>, respectively.
The process is to be continued through
<i>m</i> phases.</p>
</td><td>&nbsp;</td></tr></table>
<br>

<table align=center>
<tr><td valign=top><img src="APLimg/prog1x15.bmp"></td>
 <td nowrap>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
 <td valign=top><table border=1 cellspacing=0 cellpadding=4>
  <tr><td align=center>0-origin indexing</td></tr>
  <tr><td><table>
  <tr><td valign=top><b>&Phi;</b><sup>&nbsp;</sup></td>
   <td>&nbsp; &nbsp;</td>
   <td>File array of dimension 2 &times; 2; 
   original input <b>&Phi;</b><sup>0</sup>;
   original output <b>&Phi;</b><sup>1</sup>.</td>
   </tr>
  <tr><td valign=top><b><i>u</i></b></td>
   <td>&nbsp;</td><td>Control vector.</td>
   </tr>
  <tr><td valign=top><b><i>u</i></b><sub>0</sub></td>
   <td>&nbsp;</td><td>Column index of input file.</td>
   </tr>
  <tr><td valign=top><b><i>u</i></b><sub>1</sub></td>
   <td>&nbsp;</td><td>Column index of output file.</td>
   </tr>
  <tr><td valign=top><b><i>u</i></b><sub>2</sub></td>
   <td>&nbsp;</td><td>Row index of current input file,
   and direction of read and record.</td>
   </tr>
  <tr><td valign=top><i>n</i></td>
   <td>&nbsp;</td><td>Number of items per file.</td>
   </tr>
  <tr><td valign=top><i>m</i></td>
   <td>&nbsp;</td><td>Required number of merges.</td>
   </tr>
  </table>
 </td></tr></table> <p align=center><b>Legend</p></td></tr>
<tr><td colspan=3 align=center><b>Program 1.15</b> &nbsp; Program for Example 1.4</td></tr> 
</table>
<br>

<table><tr><td>&nbsp;</td><td>
<p><b>Program 1.15</b>.
The program for Example 1.4 begins with the rewind
of the entire <nobr>2 &times; 2</nobr> array of files.
To obviate further rewinding,
the second (and each subsequent even-numbered)
execution is performed by reading and recording
all files in the backward direction.
Step 6 performs the essential read and record
operation under control of the logical vector
<b><i>u</i></b>,
whose components <b><i>u</i></b><sub>0</sub>,
<b><i>u</i></b><sub>1</sub>, <b><i>u</i></b><sub>2</sub>
determine, respectively, 
the subscript of the file to be read,
the subscript of the file to be recorded,
and the direction of read and record.
The file superscripts (determining which classes
serve as input and output
in the current repetition)
are also determined by <b><i>u</i></b><sub>2</sub>,
the input being <b><i>u</i></b><sub>2</sub>
and the output 
<nobr><img src="APLimg/uboscore.bmp"></b><sub>2</sub>.</nobr>
The loop 6-8 copies <i>n</i> items,
alternating the input files 
through the negation of <b><i>u</i></b><sub>0</sub>
on step 7.
When the loop terminates, <b><i>u</i></b><sub>1</sub>
is negated to interchange the outputs,
and the loop is repeated unless 
<nobr><b><i>u</i></b><sub>1</sub> = 
<b><i>u</i></b><sub>2</sub></nobr>.
Equality occurs and causes a branch to step 3
if and only if all 2<i>n</i> items 
of the current phase have already been copied.</p>

<p>Step 3 decrements <i>m</i> and is followed
by the negation of <b><i>u</i></b> on step 4.
The component <b><i>u</i></b><sub>2</sub>
must, of course, be negated to reverse direction,
but the need to negate <b><i>u</i></b><sub>0</sub> and
<b><i>u</i></b><sub>1</sub> is not so evident.
It arises because the copying order was prescribed
for the forward direction, beginning always
with the operation</p>

<p>&nbsp; &nbsp; &nbsp; <img src="APLimg/fcopyinit0.bmp">.</p>

<p>An equivalent backward copy must therefore begin 
with the operation</p>

<p>&nbsp; &nbsp; &nbsp; <img src="APLimg/fcopyinit1.bmp">.</p>
</td><td>&nbsp;</td></tr></table>

<p>Not all computer files have the very general capabilities
indicated by the present notation.
Some files, for example, can be read and recorded
in the forward direction only and,
except for rewind, cannot be positioned directly.
Positioning to an arbitrary position <i>k</i>
must then be performed by a rewind and a succession
of <nobr>(<i>k</i> &ndash; 1)</nobr> reads.
In some files, recording can be performed 
in the forward direction only,
and the positions are defined 
only by the recorded data.
Consequently, recording in position <i>k</i>
makes unreliable the data
in all subsequent positions, 
and recording must always proceed
through all successive positions until terminated.
<br>&nbsp;</p>



<a name="1.23"></a>
<p><b>1.23 Ordered trees</b></p>

<a name="1.23.1"></a>
<p><b>Directed graphs</b></p>

<p>For many processes it is convenient to use
a structured operand with the treelike structure
suggested by Fig. 1.16.
It is helpful to begin with a more general structure
(such as Fig. 1.17) 
in which a unidirectional
association may be specified
between any pair of its components.</p>

<table>
<tr><td align=center><img src="APLimg/fig1x16.bmp"></td></tr>
<tr><td>&nbsp;</td></tr>
<tr><td align=center><b>Figure 1.16&nbsp;</b> A general triply
root tree with <i>&lambda;</i>(<b>T</b>) = 16,
<b>&nu;</b>(<b>T</b>) = (3,&nbsp;3,&nbsp;4,&nbsp;3,&nbsp;2),<br>
<i>&nu;</i>(<b>T</b>) = 5,
<b>&mu;</b>(<b>T</b>) = (3,&nbsp;7,&nbsp;8,&nbsp;5,&nbsp;3),
and <i>&mu;</i>(<b>T</b>) = 26</td></tr>
</table>

<p>A <i>directed graph</i> comprises a vector
<b><i>n</i></b> and an arbitrary set of unilateral associations
specified between pairs of its components.
The vector <b><i>n</i></b> is called a <i>node vector</i>
and its components are also called <i>nodes</i>.
The associations are conveniently specified
by a (logical) <i>connection matrix</i> <b><i>U</i></b>
of dimensions 
<i>&nu;</i>(<b><i>n</i></b>) &times <i>&mu;</i>(<b><i>n</i></b>)
with the following convention:
there is an association, called a <i>branch</i>,
from node <i>i</i> to node <i>j</i> if and only if
<b><i>U</i></b><sub><i>&nbsp;j</i></sub><sup><i>&nbsp;i</i></sup> = 1.</p>

<p>A directed graph admits of a simple graphical interpretation,
as illustrated by Fig. 1.17.
The nodes might, for example, 
represent places, and the lines, connecting streets.
A two-way street is then represented 
by a pair of oppositely directed lines,
as shown between nodes 3 and 4.</p>

<table align=center>
<tr><td><img src="APLimg/fig1x17.bmp"></td>
<td>&nbsp; &nbsp; &nbsp;</td>
<td><table>
<tr><td rowspan=7><b><i>U</i></b> &nbsp;=&nbsp;</td>
<td rowspan=7><img src="APLimg/matrixl7.bmp"></td>
<td><sup>&nbsp;</sup>0 &nbsp; 0 &nbsp; 0 &nbsp; 0 &nbsp; 1 &nbsp; 0 &nbsp; 1<sub>&nbsp;</sub></td>
<td rowspan=7><img src="APLimg/matrixr7.bmp"></td>
</tr>
<tr><td><sup>&nbsp;</sup>0 &nbsp; 0 &nbsp; 0 &nbsp; 0 &nbsp; 0 &nbsp; 1 &nbsp; 0<sub>&nbsp;</sub></td></tr>
<tr><td><sup>&nbsp;</sup>0 &nbsp; 0 &nbsp; 0 &nbsp; 1 &nbsp; 1 &nbsp; 1 &nbsp; 0<sub>&nbsp;</sub></td></tr>
<tr><td><sup>&nbsp;</sup>0 &nbsp; 0 &nbsp; 1 &nbsp; 0 &nbsp; 0 &nbsp; 0 &nbsp; 0<sub>&nbsp;</sub></td></tr>
<tr><td><sup>&nbsp;</sup>0 &nbsp; 0 &nbsp; 0 &nbsp; 0 &nbsp; 0 &nbsp; 1 &nbsp; 1<sub>&nbsp;</sub></td></tr>
<tr><td><sup>&nbsp;</sup>1 &nbsp; 0 &nbsp; 0 &nbsp; 0 &nbsp; 0 &nbsp; 0 &nbsp; 0<sub>&nbsp;</sub></td></tr>
<tr><td><sup>&nbsp;</sup>0 &nbsp; 1 &nbsp; 0 &nbsp; 0 &nbsp; 0 &nbsp; 0 &nbsp; 1<sub>&nbsp;</sub></td></tr>
</table></td></tr>
<tr><td align=center colspan=3><br><b>Figure 1.17&nbsp;</b>
A graphical representation of the graph (<b><i>n</i></b>, <b><i>U</i></b>).
</td></tr>
</table>

<p>If <b><i>k</i></b> is any mapping vector such that</p>

<table>
<tr><td>&nbsp; &nbsp; &nbsp; <img src="APLimg/ukk.bmp"></td>
<td>&nbsp;= 1 &nbsp; &nbsp; for <i>i</i> = 2, 3, &#133;, <i>&nu;</i>(<b><i>k</i></b>),</td></tr>
</table>

<p>then the vector 
<nobr><b><i>p</i></b> = <b><i>k</i></b> &int; 
<b><i>n</i></b></nobr>
is called <i>a path vector</i> of the graph 
(<b><i>n</i></b>,&nbsp;<b><i>U</i></b>). 
The dimension of a path vector 
is also called its <i>length</i>. 
Nodes <b><i>k</i></b><sub>1</sub> and 
<b><i>k</i></b><sub><i>&nu;</i></sub> 
are called the <i>initial</i> 
and <i>final</i> nodes, respectively; 
both are also called <i>terminal</i> nodes. 
If <b><i>j</i></b> is any infix of <b><i>k</i></b>, 
then <b><i>q</i></b> = <b><i>j</i></b> &int; <b><i>n</i></b> 
is also a path. 
It is called a subpath of <b><i>p</i></b> 
and is said to be <i>contained</i> in <b><i>p</i></b>. 
If 
<nobr><i>&nu;</i>(<b><i>q</i></b>) &lt; 
<i>&nu;</i>(<b><i>p</i></b>),</nobr> 
then <b><i>q</i></b> is a <i>proper</i> 
subpath of <b><i>p</i></b>. 
If <nobr><b><i>k</i></b><sub>1</sub> = 
<b><i>k</i></b><sub><i>&nu;</i></sub></nobr>
and <b><i>p</i></b> = <nobr><b><i>k</i></b> &int; <b><i>n</i></b></nobr> 
is a path of a length exceeding one, 
<b><i>p</i></b> is called a <i>circuit</i>. 
For example, if <b><i>k</i></b> =
<nobr>(6, 1, 7, 7, 2, 6, 1, 5),</nobr>
then <b><i>p</i></b> = 
<nobr>(<b><i>n</i></b><sub>6</sub>, 
<b><i>n</i></b><sub>1</sub>, 
<b><i>n</i></b><sub>7</sub>, 
<b><i>n</i></b><sub>7</sub>, 
<b><i>n</i></b><sub>2</sub>, 
<b><i>n</i></b><sub>6</sub>, 
<b><i>n</i></b><sub>1</sub>, 
<b><i>n</i></b><sub>5</sub>)</nobr> 
is a path vector of the graph of Fig. 1.17, 
which contains the proper subpaths 
<nobr>(<b><i>n</i></b><sub>7</sub>, 
<b><i>n</i></b><sub>2</sub>, 
<b><i>n</i></b><sub>6</sub>),</nobr> 
<nobr>(<b><i>n</i></b><sub>1</sub>, 
<b><i>n</i></b><sub>7</sub>, 
<b><i>n</i></b><sub>7</sub>, 
<b><i>n</i></b><sub>2</sub>, 
<b><i>n</i></b><sub>6</sub>, 
<b><i>n</i></b><sub>1</sub>)</nobr>, 
and 
<nobr>(<b><i>n</i></b><sub>7</sub>, 
<b><i>n</i></b><sub>7</sub>)</nobr>, 
the last two of which are circuits. 
Node <i>j</i> is said to be reachable 
from node <i>i</i> 
if there exists a path 
from node <i>i</i> to node <i>j</i>.</p>



<a name="1.23.2"></a>
<p><b>Ordered trees</b></p>

<p>A graph (such as Fig. 1.16) 
which contains no circuits and 
which has at most one branch 
entering each node is called a <i>tree</i>. 
Since each node
is entered by at most one branch, 
a path existing between any two nodes in a tree is unique, 
and the length of path is also unique. 
Moreover, if any two paths have the same final node, 
one is a subpath of the other.</p>

<p>Since a tree contains no circuits, 
the length of path in a finite tree is bounded. 
There therefore exist <i>maximal paths</i>
which are proper subpaths of no longer paths. 
The initial and final nodes of a maximal path are
called a <i>root</i> and <i>leaf</i> 
of the tree, respectively. 
A root is said to lie on the
<i>first level</i> of the tree, 
and, in general, a node which lies at the end of a path
of length <i>j</i> from a root, 
lies in the <i>j</i>th <i>level</i> of the tree.</p>

<p>A tree which contains <i>n</i> roots 
is said to be <i>n-tuply rooted</i>. 
The sets of nodes reachable 
from each of the several roots are disjoint, 
for if any node is reachable by paths 
from each of two disjoint roots, 
one is a proper subpath of the other 
and is therefore not maximal. 
Similarly, any node of a tree 
defines a <i>subtree</i> 
of which it is the root, 
consisting of itself and
all nodes reachable from it, 
with the same associations 
as the parent tree.</p>

<a name="nu_tree"></a>
<a name="mu_tree"></a>
<a name="lambda_tree"></a>
<p>If for each level <i>j</i>, 
a simple ordering is assigned to each of the disjoint
sets of nodes reachable 
from each node of the preceding level, 
and if the roots are also simply ordered, 
the tree is said to be <i>ordered</i>. 
Attention will henceforth be restricted 
to ordered trees, which will be denoted 
by uppercase boldface roman characters.
The <i>height</i> of a tree <b>T</b> 
is defined as the length of the longest path in <b>T</b> 
and is denoted by <i>&nu;</i>(<b>T</b>). 
The number of nodes on level <i>j</i> 
is called the <i>moment of level j</i> and is denoted 
by <b>&mu;</b><sub><i>j</i></sub>(<b>T</b>). 
The vector <b>&mu;</b>(<b>T</b>) 
is called the <i>moment vector</i>. 
The total number of nodes in <b>T</b> is
called the moment of <b>T</b> 
and is denoted by <i>&mu;</i>(<b>T</b>). 
Clearly, <i>&nu;</i>(<b>&mu;</b>(<b>T</b>)) = <i>&nu;</i>(<b>T</b>),
and +/<b>&mu;</b>(<b>T</b>) = <i>&mu;</i>(<b>T</b>) 
= <i>&nu;</i>(<b><i>n</i></b>). 
The number of roots is equal to 
<b>&mu;</b><sub>1</sub>(<b>T</b>), and
the number of leaves will be denoted 
by <i>&lambda;</i>(<b>T</b>).</p>

<a name="delta_tree"></a>
<a name="dispersion_vector"></a>
<p>The number of branches leaving a node 
is called its <i>branching ratio</i> or <i>degree</i>, 
and the maximum degree occurring 
in a tree <b>T</b> is denoted 
by <i>&delta;</i>(<b>T</b>).
The <i>dispersion vector</i> of a tree <b>T</b> 
is denoted by <b>&nu;</b>(<b>T</b>) 
and is defined as follows: 
<b>&nu;</b><sub>1</sub>(<b>T</b>) = <b>&mu;</b><sub>1</sub>(<b>T</b>), 
and for <i>j</i> = <nobr>2, 3, &#133;, <i>&nu;</i>(<b>T</b>),</nobr> 
<b>&nu;</b><sub><i>j</i></sub>(<b>T</b>) is equal to the
maximum over the branching ratios of the nodes on level 
<nobr><i>j</i> &ndash; 1</nobr>. 
For the tree of Fig. 1.16, 
<b>&nu;</b>(<b>T</b>) = <nobr>(3, 3, 4, 3, 2)</nobr>. 
The number of roots possessed by a tree <b>T</b> 
(that is, <b>&nu;</b><sub>1</sub>(<b>T</b>)) 
is called its <i>dispersion</i>. 
A tree possessing unity dispersion is called 
<i>rooted</i> or <i>singular</i>.</p>

<p>Each node <b><i>n</i></b><sub><i>i</i></sub> 
of a graph (and hence of a tree) may be identified 
by its index <i>i</i>. 
Since a tree admits of more convenient index vectors, 
the underlying index <i>i</i> will henceforth be referred to 
as the <i>graph index</i>.</p>

<a name="node"></a>
<a name="delta2"></a>
<p>In an ordered tree, 
any path of length <i>k</i> 
from a root can be uniquely
specified by an <i>index vector</i> <b><i>i</i></b> 
of dimension <i>k</i>, 
where <b><i>i</i></b><sub>1</sub> 
specifies the particular root, 
and the remaining components 
specify the (unique) path as follows: 
the path node on level <i>j</i> is 
the <b><i>i</i></b><sub><i>j&nbsp;</i></sub>th element 
of the set of nodes on level <i>j</i> reachable 
from the path node on level <nobr><i>j</i> &ndash; 1</nobr>. 
The node at the end of
the path can therefore be designated uniquely 
by the index vector <b><i>i</i></b>. 
The degree of node <b><i>i</i></b> will be denoted 
by <nobr><i>&delta;</i>(<b><i>i</i></b>, <b>T</b>)</nobr>. 
The index vectors are shown to the left 
of each node in Fig. 1.16.</p>

<a name="path"></a>
<p>The path from a root whose terminal node 
is <b><i>i</i></b> will be denoted 
by <b>T</b><sup><b><i>i</i></b></sup>.
In Fig. 1.16, for example, 
<b>T</b><sup><b><i>i</i></b></sup> = 
<nobr>(<b><i>n</i></b><sub>2</sub>, 
<b><i>n</i></b><sub>8</sub>, 
<b><i>n</i></b><sub>13</sub>, 
<b><i>n</i></b><sub>24</sub>)</nobr> 
if <b><i>i</i></b> = <nobr>(2, 2, 2, 3).</nobr>
A vector <b><i>i</i></b> is said to be an index 
of <b>T</b> if it is the index 
of some node in <b>T</b>.</p>

<a name="subtree"></a>
<p>The subtree of <b>T</b> rooted 
in node <b><i>i</i></b> will be denoted 
by <b>T</b><sub><b><i>i</i></b></sub>. 
Thus in Fig. 1.16, 
<nobr><b>P</b> = <b>T</b><sub>(2,2,2)</sub></nobr>
is a rooted subtree with <b>&nu;</b>(<b>P</b>) = 
<nobr>(1, 3, 2),</nobr> and 
<b>&mu;</b>(<b>P</b>) = <nobr>(1, 3, 3).</nobr> 
A path in <b>T</b><sub><b><i>i</i></b></sub> 
is denoted by (<b>T</b><sub><b><i>i</i></b></sub>)<sup><b><i>&nbsp;j</i></b></sup>. 
For example, if <b>G</b> is an
ascending genealogical tree<sup><a href="APL1.htm#note1h">[h]</a></sup> 
with the sword and distaff sides denoted by
the indices 1 and 2, respectively, 
then any individual <i>x</i> 
and the nearest <nobr>(<i>n</i> &ndash; 1)</nobr>
paternal male ancestors are represented 
by the path vector (<b>G</b><sub><b><i>i</i></b></sub>)<sup><tt><b>∊</b></tt>(<i>n</i>)</sup>,
where <b><i>i</i></b> is the index of <i>x</i> in <b>G</b>.</p>

<table><tr><td>&nbsp;</td><td>
<p><b>Example 1.5</b>. Determine the index <b><i>i</i></b> 
such that the path <b>T</b><sup>&nbsp;<b><i>i</i></b></sup> 
is equal to a given argument <b><i>x</i></b> 
and is the &ldquo;first&rdquo; such path in <b>T</b>; 
that is, the function</p>

<p>&nbsp; &nbsp; &nbsp;
(<tt><b>⍺</b></tt><sup><i>&nu;</i>(<b><i>x</i></b>)</sup>/<b>&nu;</b>(<b><i>T</i></b>))
<tt>⊥</tt> <b><i>i</i></b>
</p>

<p>is a minimum.</p>
</td><td>&nbsp;</td></tr></table>
<br>

<table align=center>
<tr><td valign=top><img src="APLimg/prog1x18.bmp"></td>
 <td nowrap>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
 <td valign=top><table border=1 cellspacing=0 cellpadding=4>
  <tr><td align=center>1-origin indexing</td></tr>
  <tr><td><table>
  <tr><td><b>T</b></td>
   <td nowrap>&nbsp; &nbsp;</td><td>Given tree.</td>
   </tr>
  <tr><td valign=top><b><i>x</i></b></td>
   <td>&nbsp;</td><td>Given path vector.</td>
   </tr>
  <tr><td valign=top><b><i>i</i></b></td>
   <td>&nbsp;</td><td>Path index vector to be determined.</td>
   </tr>
  <tr><td valign=top><b>&mu;</b><sub>1</sub>(<b>T</b>)</td>
   <td>&nbsp;</td><td>Number of roots of <b>T</b>.</td>
   </tr>
  <tr><td valign=top><i>&delta;</i>(<b><i>i</i></b>,<b>T</b>)</td>
   <td>&nbsp;</td><td>Degree of node <b><i>i</i></b>.</td>
   </tr>
  </table>
 </td></tr></table> <p align=center><b>Legend</b></p></td></tr>
<tr><td colspan=3 align=center><b>Program 1.18</b> &nbsp; 
Determination of <b><i>i</i></b> such that 
<b>T</b><sup><b><i>i</i></b></sup> = <b><i>x</i></b></td></tr> 
</table>
<br>

<table><tr><td>&nbsp;</td><td>
<p><b>Program 1.18</b>. 
The index vector <b><i>i</i></b> specifies 
the path currently under test. 
Its last component is incremented repeatedly 
by step 7 until the loop 6-8 is terminated.
If the path <b>T</b><sup><b><i>i</i></b></sup> agrees 
with the corresponding prefix 
of the argument <b><i>x</i></b>, 
termination occurs through the branch to step 9, 
which tests for completion before step 10
augments <b><i>i</i></b> by a final zero component. 
Step 5 then respecifies <i>d</i> as the degree of
the penultimate node of the set of <i>d</i> paths 
next to be tested by the loop. 
Termination by a branch from step 6 to step 2 
occurs if all <i>d</i> possible paths are exhausted
without finding agreement on step 8. 
In this event, retraction 
by one level occurs on step 2, 
and <i>d</i> is again respecified. 
If <i>&nu;</i>(<b><i>i</i></b>) = 1, 
the paths to be searched comprise
the roots of the tree 
and <i>d</i> must therefore be specified 
as the number of roots. 
This is achieved by executing step 3 
and skipping step 5. 
Retraction to a vector <b><i>i</i></b> 
of dimension zero occurs only if 
all roots have been exhausted, 
and final termination from step 4 
indicates that the tree possesses 
no path equal to the argument <b><i>x</i></b>.</p>
</td><td>&nbsp;</td></tr></table>

<p>If <b><i>d</i></b> is a vector of dimension 
<i>&nu;</i>(<b><i>n</i></b>) 
such that <b><i>d</i></b><sub><i>&nbsp;i</i></sub> 
is the degree of node <b><i>n</i></b><sub><i>&nbsp;i</i></sub> 
of a tree <b>T</b>, 
then <b><i>d</i></b> is called 
the <i>degree vector associated with</i> <b><i>n</i></b>. 
In Fig. 1.16, for example,</p>

<p>&nbsp; &nbsp; &nbsp;
<b><i>d</i></b> = (3, 2, 4, 0, 0, 0, 2, &#133;, 1, 0, 0).</p>

<p>Moreover, if <b><i>n</i></b> is itself the alphabet 
(that is, <nobr><b><i>n</i></b> = (a, b, c, ... , z)),</nobr> 
then the vector <b><i>n</i></b>&prime; 
of Table 1.19a is a permutation of <b><i>n</i></b>, 
and <b><i>d</i></b>&prime; is the associated degree vector. 
Table 1.19b shows another such pair, 
<b><i>n</i></b>&prime;&prime; and <b><i>d</i></b>&prime;&prime;.</p>

<p>The degree vector provides certain useful information most directly.
For example, since each leaf is of degree zero, 
<nobr><i>&lambda;</i>(<b>T</b>) = +/(<b><i>d</i></b> = 0).</nobr>
Moreover, the number of roots is equal to the number 
of nodes less the total of the degrees, that is, 
<nobr><b>&mu;</b><sub>1</sub>(<b>T</b>) = 
<i>&nu;</i>(<b><i>d</i></b>) &ndash; +/<b><i>d</i></b>,</nobr>
and the maximal degree occurring in <b>T</b> is given by 
<nobr><i>&delta;</i>(<b>T</b>) = 
((<tt><b>∊</b></tt><tt>⌈</tt><b><i>d</i></b>)/<b><i>d</i></b>)<sub>1</sub>.</nobr>
Finally, the degree vector
and the node vector together can, in certain permutations 
(those of Table 1.19), provide a complete 
and compact description of the tree.</p>

<table align=center><tr>
<td><table border=1 cellspacing=0 cellpadding=0>
<tr>
 <td align=center><b><i>d</i></b> &prime;</td>
 <td align=center><b><i>n</i></b>&prime;</td>
 <td align=center><b><i>I</i></b> &prime;</td></tr>
<tr><td><table>
 <tr><td>&nbsp; 3 &nbsp;</td></tr><tr><td>&nbsp; 4 &nbsp;</td></tr><tr><td>&nbsp; 0 &nbsp;</td></tr><tr><td>&nbsp; 0 &nbsp;</td></tr><tr><td>&nbsp; 0 &nbsp;</td></tr>
 <tr><td>&nbsp; 0 &nbsp;</td></tr><tr><td>&nbsp; 0 &nbsp;</td></tr><tr><td>&nbsp; 1 &nbsp;</td></tr><tr><td>&nbsp; 2 &nbsp;</td></tr><tr><td>&nbsp; 0 &nbsp;</td></tr>
 <tr><td>&nbsp; 0 &nbsp;</td></tr><tr><td>&nbsp; 2 &nbsp;</td></tr><tr><td>&nbsp; 0 &nbsp;</td></tr><tr><td>&nbsp; 3 &nbsp;</td></tr><tr><td>&nbsp; 0 &nbsp;</td></tr>
 <tr><td>&nbsp; 3 &nbsp;</td></tr><tr><td>&nbsp; 0 &nbsp;</td></tr><tr><td>&nbsp; 2 &nbsp;</td></tr><tr><td>&nbsp; 0 &nbsp;</td></tr><tr><td>&nbsp; 0 &nbsp;</td></tr>
 <tr><td>&nbsp; 1 &nbsp;</td></tr><tr><td>&nbsp; 0 &nbsp;</td></tr><tr><td>&nbsp; 0 &nbsp;</td></tr><tr><td>&nbsp; 2 &nbsp;</td></tr><tr><td>&nbsp; 0 &nbsp;</td></tr>
 <tr><td>&nbsp; 0 &nbsp;</td></tr>
 </table></td>
 <td><table>
 <tr><td>&nbsp; a &nbsp;</td></tr><tr><td>&nbsp; c &nbsp;</td></tr><tr><td>&nbsp; f &nbsp;</td></tr><tr><td>&nbsp; d &nbsp;</td></tr><tr><td>&nbsp; r &nbsp;</td></tr>
 <tr><td>&nbsp; e &nbsp;</td></tr><tr><td>&nbsp; z &nbsp;</td></tr><tr><td>&nbsp; n &nbsp;</td></tr><tr><td>&nbsp; i &nbsp;</td></tr><tr><td>&nbsp; p &nbsp;</td></tr>
 <tr><td>&nbsp; q &nbsp;</td></tr><tr><td>&nbsp; b &nbsp;</td></tr><tr><td>&nbsp; k &nbsp;</td></tr><tr><td>&nbsp; h &nbsp;</td></tr><tr><td>&nbsp; o &nbsp;</td></tr>
 <tr><td>&nbsp; m &nbsp;</td></tr><tr><td>&nbsp; u &nbsp;</td></tr><tr><td>&nbsp; s &nbsp;</td></tr><tr><td>&nbsp; t &nbsp;</td></tr><tr><td>&nbsp; w &nbsp;</td></tr>
 <tr><td>&nbsp; x &nbsp;</td></tr><tr><td>&nbsp; y &nbsp;</td></tr><tr><td>&nbsp; v &nbsp;</td></tr><tr><td>&nbsp; g &nbsp;</td></tr><tr><td>&nbsp; j &nbsp;</td></tr>
 <tr><td>&nbsp; l &nbsp;</td></tr>
 </table></td>
 <td><table>
<tr><td>&nbsp;</td><td>1</td><td><tt>∘</tt></td><td><tt>∘</tt></td><td><tt>∘</tt></td><td><tt>∘</tt></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>1</td><td>1         </td><td><tt>∘</tt></td><td><tt>∘</tt></td><td><tt>∘</tt></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>1</td><td>1         </td><td>1         </td><td><tt>∘</tt></td><td><tt>∘</tt></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>1</td><td>1         </td><td>2         </td><td><tt>∘</tt></td><td><tt>∘</tt></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>1</td><td>1         </td><td>3         </td><td><tt>∘</tt></td><td><tt>∘</tt></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>1</td><td>1         </td><td>4         </td><td><tt>∘</tt></td><td><tt>∘</tt></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>1</td><td>2         </td><td><tt>∘</tt></td><td><tt>∘</tt></td><td><tt>∘</tt></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>1</td><td>3         </td><td><tt>∘</tt></td><td><tt>∘</tt></td><td><tt>∘</tt></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>1</td><td>3         </td><td>1         </td><td><tt>∘</tt></td><td><tt>∘</tt></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>1</td><td>3         </td><td>1         </td><td>1         </td><td><tt>∘</tt></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>1</td><td>3         </td><td>1         </td><td>2         </td><td><tt>∘</tt></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>2</td><td><tt>∘</tt></td><td><tt>∘</tt></td><td><tt>∘</tt></td><td><tt>∘</tt></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>2</td><td>1         </td><td><tt>∘</tt></td><td><tt>∘</tt></td><td><tt>∘</tt></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>2</td><td>2         </td><td><tt>∘</tt></td><td><tt>∘</tt></td><td><tt>∘</tt></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>2</td><td>2         </td><td>1         </td><td><tt>∘</tt></td><td><tt>∘</tt></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>2</td><td>2         </td><td>2         </td><td><tt>∘</tt></td><td><tt>∘</tt></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>2</td><td>2         </td><td>2         </td><td>1         </td><td><tt>∘</tt></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>2</td><td>2         </td><td>2         </td><td>2         </td><td><tt>∘</tt></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>2</td><td>2         </td><td>2         </td><td>2         </td><td>1         </td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>2</td><td>2         </td><td>2         </td><td>2         </td><td>2         </td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>2</td><td>2         </td><td>2         </td><td>3         </td><td><tt>∘</tt></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>2</td><td>2         </td><td>2         </td><td>3         </td><td>1         </td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>2</td><td>2         </td><td>3         </td><td><tt>∘</tt></td><td><tt>∘</tt></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>3</td><td><tt>∘</tt></td><td><tt>∘</tt></td><td><tt>∘</tt></td><td><tt>∘</tt></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>3</td><td>1         </td><td><tt>∘</tt></td><td><tt>∘</tt></td><td><tt>∘</tt></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>3</td><td>2         </td><td><tt>∘</tt></td><td><tt>∘</tt></td><td><tt>∘</tt></td><td>&nbsp;</td></tr>
 </table></td>
</tr>
</table>
<p align=center>Full left list matrix [<b>T</b><br>(<i>a</i>)</p>
</td>

<td>&nbsp; &nbsp; &nbsp;</td>

<td valign=top><table>
<tr><td>&nbsp;</td></tr>
<tr align=center><td>1</td></tr>
<tr align=center><td>2</td></tr>
<tr align=center><td>3</td></tr>
<tr align=center><td>4</td></tr>
<tr align=center><td>5</td></tr>
<tr align=center><td>6</td></tr>
<tr align=center><td>7</td></tr>
<tr align=center><td>8</td></tr>
<tr align=center><td>9</td></tr>
<tr><td>10</td></tr>
<tr><td>11</td></tr>
<tr><td>12</td></tr>
<tr><td>13</td></tr>
<tr><td>14</td></tr>
<tr><td>15</td></tr>
<tr><td>16</td></tr>
<tr><td>17</td></tr>
<tr><td>18</td></tr>
<tr><td>19</td></tr>
<tr><td>20</td></tr>
<tr><td>21</td></tr>
<tr><td>22</td></tr>
<tr><td>23</td></tr>
<tr><td>24</td></tr>
<tr><td>25</td></tr>
<tr><td>26</td></tr>
</table></td>

<td>&nbsp; &nbsp; &nbsp;</td>

<td><table border=1 cellspacing=0 cellpadding=0>
<tr>
 <td align=center><b><i>d</i></b> &prime;&prime;</td>
 <td align=center><b><i>n</i></b>&prime;&prime;</td>
 <td align=center><b><i>I</i></b> &prime;&prime;</td></tr>
<tr><td><table>
 <tr><td>&nbsp; 3 &nbsp;</td></tr><tr><td>&nbsp; 2 &nbsp;</td></tr><tr><td>&nbsp; 2 &nbsp;</td></tr><tr><td>&nbsp; 4 &nbsp;</td></tr><tr><td>&nbsp; 0 &nbsp;</td></tr>
 <tr><td>&nbsp; 1 &nbsp;</td></tr><tr><td>&nbsp; 0 &nbsp;</td></tr><tr><td>&nbsp; 3 &nbsp;</td></tr><tr><td>&nbsp; 0 &nbsp;</td></tr><tr><td>&nbsp; 0 &nbsp;</td></tr>
 <tr><td>&nbsp; 0 &nbsp;</td></tr><tr><td>&nbsp; 0 &nbsp;</td></tr><tr><td>&nbsp; 0 &nbsp;</td></tr><tr><td>&nbsp; 0 &nbsp;</td></tr><tr><td>&nbsp; 2 &nbsp;</td></tr>
 <tr><td>&nbsp; 0 &nbsp;</td></tr><tr><td>&nbsp; 3 &nbsp;</td></tr><tr><td>&nbsp; 0 &nbsp;</td></tr><tr><td>&nbsp; 0 &nbsp;</td></tr><tr><td>&nbsp; 0 &nbsp;</td></tr>
 <tr><td>&nbsp; 0 &nbsp;</td></tr><tr><td>&nbsp; 2 &nbsp;</td></tr><tr><td>&nbsp; 1 &nbsp;</td></tr><tr><td>&nbsp; 0 &nbsp;</td></tr><tr><td>&nbsp; 0 &nbsp;</td></tr>
 <tr><td>&nbsp; 0 &nbsp;</td></tr>
 </table></td>
 <td><table>
 <tr><td>&nbsp; a &nbsp;</td></tr><tr><td>&nbsp; b &nbsp;</td></tr><tr><td>&nbsp; g &nbsp;</td></tr><tr><td>&nbsp; c &nbsp;</td></tr><tr><td>&nbsp; z &nbsp;</td></tr>
 <tr><td>&nbsp; n &nbsp;</td></tr><tr><td>&nbsp; k &nbsp;</td></tr><tr><td>&nbsp; h &nbsp;</td></tr><tr><td>&nbsp; j &nbsp;</td></tr><tr><td>&nbsp; l &nbsp;</td></tr>
 <tr><td>&nbsp; f &nbsp;</td></tr><tr><td>&nbsp; d &nbsp;</td></tr><tr><td>&nbsp; r &nbsp;</td></tr><tr><td>&nbsp; e &nbsp;</td></tr><tr><td>&nbsp; i &nbsp;</td></tr>
 <tr><td>&nbsp; o &nbsp;</td></tr><tr><td>&nbsp; m &nbsp;</td></tr><tr><td>&nbsp; v &nbsp;</td></tr><tr><td>&nbsp; p &nbsp;</td></tr><tr><td>&nbsp; q &nbsp;</td></tr>
 <tr><td>&nbsp; u &nbsp;</td></tr><tr><td>&nbsp; s &nbsp;</td></tr><tr><td>&nbsp; x &nbsp;</td></tr><tr><td>&nbsp; t &nbsp;</td></tr><tr><td>&nbsp; w &nbsp;</td></tr>
 <tr><td>&nbsp; y &nbsp;</td></tr>
 </table></td>
 <td><table>
<tr><td>&nbsp;</td><td><tt>∘</tt></td><td><tt>∘</tt></td><td><tt>∘</tt></td><td><tt>∘</tt></td><td>1</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><tt>∘</tt></td><td><tt>∘</tt></td><td><tt>∘</tt></td><td><tt>∘</tt></td><td>2</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><tt>∘</tt></td><td><tt>∘</tt></td><td><tt>∘</tt></td><td><tt>∘</tt></td><td>3</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><tt>∘</tt></td><td><tt>∘</tt></td><td><tt>∘</tt></td><td>1         </td><td>1</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><tt>∘</tt></td><td><tt>∘</tt></td><td><tt>∘</tt></td><td>1         </td><td>2</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><tt>∘</tt></td><td><tt>∘</tt></td><td><tt>∘</tt></td><td>1         </td><td>3</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><tt>∘</tt></td><td><tt>∘</tt></td><td><tt>∘</tt></td><td>2         </td><td>1</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><tt>∘</tt></td><td><tt>∘</tt></td><td><tt>∘</tt></td><td>2         </td><td>2</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><tt>∘</tt></td><td><tt>∘</tt></td><td><tt>∘</tt></td><td>3         </td><td>1</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><tt>∘</tt></td><td><tt>∘</tt></td><td><tt>∘</tt></td><td>3         </td><td>2</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><tt>∘</tt></td><td><tt>∘</tt></td><td>1         </td><td>1         </td><td>1</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><tt>∘</tt></td><td><tt>∘</tt></td><td>1         </td><td>1         </td><td>2</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><tt>∘</tt></td><td><tt>∘</tt></td><td>1         </td><td>1         </td><td>3</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><tt>∘</tt></td><td><tt>∘</tt></td><td>1         </td><td>1         </td><td>4</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><tt>∘</tt></td><td><tt>∘</tt></td><td>1         </td><td>3         </td><td>1</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><tt>∘</tt></td><td><tt>∘</tt></td><td>2         </td><td>2         </td><td>1</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><tt>∘</tt></td><td><tt>∘</tt></td><td>2         </td><td>2         </td><td>2</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><tt>∘</tt></td><td><tt>∘</tt></td><td>2         </td><td>2         </td><td>3</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><tt>∘</tt></td><td>1         </td><td>3         </td><td>1         </td><td>1</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><tt>∘</tt></td><td>1         </td><td>3         </td><td>1         </td><td>2</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><tt>∘</tt></td><td>2         </td><td>2         </td><td>2         </td><td>1</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><tt>∘</tt></td><td>2         </td><td>2         </td><td>2         </td><td>2</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><tt>∘</tt></td><td>2         </td><td>2         </td><td>2         </td><td>3</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>2         </td><td>2         </td><td>2         </td><td>2         </td><td>1</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>2         </td><td>2         </td><td>2         </td><td>2         </td><td>2</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>2         </td><td>2         </td><td>2         </td><td>3         </td><td>1</td><td>&nbsp;</td></tr>
 </table></td>
</tr>
</table>
<p align=center>Full right list matrix ]<b>T</b><br>(<i>b</i>)</p>
</td>
</table>
<p align=center><b>Table 1.19</b>. 
Full list matrices of the tree of Fig. 1.16</p>



<a name="1.23.3"></a>
<p><b>Right and left list matrices</b></p>

<p>If each one of the <i>&mu;</i>(<b>T</b>) 
index vectors <b><i>i</i></b> 
of a tree <b>T</b> is listed together with
its associated node 
(<b>T</b><sup><b><i>i</i></b></sup>)<sub><i>&nu;</i>(<b><i>i</i></b>)</sub>,
the list determines the tree completely. 
Since the index vectors are, in general, 
of different dimensions, it is convenient
to append null components<sup><a href="APL1.htm#note1i">[i]</a></sup> 
to extend each to the common maximum
dimension <i>&nu;</i>(<b>T</b>). 
They may then be combined in an <i>index matrix</i> 
of dimension 
<nobr><i>&mu;</i>(<b>T</b>) &times; <i>&nu;</i>(<b>T</b>),</nobr> 
which, together with the associated node vector,
completely describes the tree.
If, for example, the node vector <b><i>n</i></b> 
is the alphabet, the tree of Fig. 1.16
is described by the node vector <b><i>n</i></b>&prime; 
and index matrix <b><i>I</i></b>&nbsp;&prime; 
of Table 1.19a or, alternatively, 
by <b><i>n</i></b>&prime;&prime; 
and <b><i>I</i></b>&nbsp;&prime;&prime; of Table 1.19b.</p>

<p>Because of the utility of the degree vector, 
it will be annexed to the array
of node vector and index matrix, 
as shown in Table 1.19a to form 
a <i>full list matrix</i> of the tree. 
The degree vector and node vector together will be
called a <i>list matrix</i>. 
As remarked, the list matrix can in certain permutations,
alone describe the tree.</p>

<p>Formally, the full list matrix <b><i>M</i></b> 
of a tree <b>T</b> is defined as follows: 
<nobr><img src="APLimg/alphaboscore.bmp"><sup>2</sup>/<b><i>M</i></b></nobr>
is an index matrix of the tree, 
<b><i>M</i></b><sub>1</sub> is the associated degree vector, 
and <b><i>M</i></b><sub>2</sub> is the associated node vector.
Thus for each 
<nobr><i>k</i> &epsilon; 
<tt><b>⍳</b></tt><sup>1</sup>(<i>&mu;</i>(<b>T</b>)),</nobr>
<nobr><b><i>M</i></b><sub>1</sub><sup><i>k</i></sup> 
= <i>&delta;</i>(<b><i>i</i></b>, <b>T</b>),</nobr>
and 
<nobr><b><i>M</i></b><sub>2</sub><sup><i>k</i></sup> = 
(<b>T</b><sup><b><i>i</i></b></sup>)<sub><i>&nu;</i>(<b><i>i</i></b>)</sub></nobr>,
where <b><i>i</i></b> is the nonnull portion of 
<nobr><img src="APLimg/alphaboscore.bmp"><sup>2</sup>/<b><i>M</i></b><sup><i>&nbsp;k</i></sup>,</nobr>
that is, 
<nobr><b><i>i</i></b> =
((<img src="APLimg/alphaboscore.bmp"><sup>2</sup>/<b><i>M</i></b><sup><i>k</i></sup>) 
&ne; <tt>∘</tt><tt><b>∊</b></tt>)/(<img src="APLimg/alphaboscore.bmp"><sup>2</sup>/<b><i>M</i></b><sup><i>k</i></sup>).</nobr>
The corresponding list matrix is 
<tt><b>⍺</b></tt><sup>2</sup>/<b><i>M</i></b>.</p>

<p>Since a full list matrix 
provides a complete description of a tree 
regardless of the order in which the nodes occur in the list, 
any column permutation
<b><i>M</i></b><sup>&nbsp;<b><i>p</i></b></sup> 
(that is, any reordering among the rows) 
is also a full list matrix.
Two particular arrangements 
of the full list matrix are of prime interest
because each possesses the following properties: 
(1) the nodes are grouped in useful ways, 
and (2) the list matrix (i.e., the degree vector 
and node vector) alone describes the tree 
without reference to the associated index matrix. 
They are called the full <i>left</i> list matrix 
and full <i>right</i> list matrix and
are denoted by [<b>T</b> and ]<b>T</b>, respectively. 
Table 1.19 shows the full left and full right lists 
of the tree of Fig. 1.16.</p>

<p>The left list index matrix <b><i>I</i></b> 
is left justified,<sup><a href="APL1.htm#note1j">[j]</a></sup>
that is, the null elements are
appended at the right of each index. 
The rows <b><i>I</i></b><sup>&nbsp;<i>j</i></sup> 
are arranged in increasing order 
on their values as decimal 
(or rather <nobr>(<i>&delta;</i>(<b>T</b>) + 1)-ary</nobr>) 
fractions with the radix point at the left 
and the nulls replaced by zeros. 
More precisely, the rows are arranged 
in increasing order on the function 
<nobr>(<i>&nu;</i>(<b><i>a</i></b>)<tt><b>∊</b></tt>) <tt>⊥</tt> 
(<b><i>a</i></b> <tt><b>⍳</b></tt><sub>0</sub> 
<b><i>I</i></b><sup>&nbsp;<i>j</i></sup>),</nobr>
where <nobr><b><i>a</i></b> = 
(<tt>∘</tt>, 1, 2, &#133;, <i>&delta;</i>(<b>T</b>)).<sup><a href="APL1.htm#note1k">[k]</a></sup></nobr>
</p>

<p>The right list matrix is right justified 
and is ordered on the same function,
namely <nobr>(<i>&nu;</i>(<b><i>a</i></b>)<tt><b>∊</b></tt>) <tt>⊥</tt> 
(<b><i>a</i></b> <tt><b>⍳</b></tt><sub>0</sub> 
<b><i>I</i></b><sup>&nbsp;<i>j</i></sup>).</nobr> 
The rows are therefore ordered 
on their values as integers, 
i.e., with the decimal point at the right. 
From the example of Table 1.19b 
it is clear that the right list 
groups the nodes by levels, 
i.e., level <i>j</i> is represented 
by the infix
<nobr>(<i>i</i> &darr; <tt><b>⍺</b></tt><sup><i>k</i></sup>)//(]<b>T</b>),</nobr>
where <nobr><i>k</i> = <b>&mu;</b><sub><i>j</i></sub>(<b>T</b>),</nobr> 
and  <nobr><i>i</i> = 
+/<tt><b>⍺</b></tt><sup><i>j</i>&ndash;1</sup>/<b>&mu;</b>(<b>T</b>).</nobr>
In Table 1.19b, 
for example, 
<nobr><b>&mu;</b>(<b>T</b>) = (3, 7, 8, 5, 3),</nobr> 
and if 
<nobr><i>j</i> = 3,</nobr> then 
<nobr><i>k</i> = 8,</nobr> 
<nobr><i>i</i> = 10,</nobr> 
and level <i>j</i> is represented 
by rows <nobr><i>i</i> + 1 = 11</nobr>
to <nobr><i>i</i> + <i>k</i> = 18.</nobr> 
The right list is therefore useful in executing processes
(such as the <i>p</i>th degree selection sort) 
which require a scan of successive levels of the tree.</p>

<p>The left list groups the nodes by subtrees, 
i.e., any node <b><i>i</i></b> is followed
immediately by the remaining nodes of its subtree 
<b>T</b><sub><b><i>i</i></b></sub>. 
Formally, if 
<nobr><b><i>I</i></b> = <img src="APLimg/alphaboscore.bmp"><sup>2</sup>/[<b>T</b>,</nobr> 
and if <nobr><b><i>i</i></b> = 
(<b><i>I</i></b><sup><i>&nbsp;k</i></b></sup> &ne; <tt>∘</tt><tt><b>∊</b></tt>)/<b><i>I</i></b><sup><i>&nbsp;k</i></b></sup>,</nobr> 
then the tree <b>T</b><sub><b><i>i</i></b></sub> 
is represented by the infix
<nobr>((<i>k</i> &ndash; 1) &darr; <tt><b>⍺</b></tt><sup><i>&nbsp;&mu;</i>(<b>T</b><sub><b><i>i</i></b></sub>)</sup>)//[<b>T</b>.</nobr> 
In Fig. 1.19a, 
for example, if 
<nobr><b><i>k</i></b> = 16,</nobr> then 
<nobr><b><i>i</i></b> = (2, 2, 2),</nobr>
<nobr><i>&mu;</i>(<b>T</b><sub><b><i>i</i></b></sub>) = 7,</nobr>
and <b>T</b><sub><b><i>i</i></b></sub> 
is represented by rows 16 to 22 of [<b>T</b>. 
The left list is therefore useful in processes 
(such as the construction of a Huffman code 
and the evaluation of a compound statement) 
which require a treatment of successive subtrees.</p>

<p>The row index of a node in a right (left) list matrix 
is a graph index of
the node and will be called the <i>right</i> 
(<i>left</i>) <i>list index</i>.</p>



<a name="1.23.4"></a>
<p><b>Well formation</b></p>

<p>A two-column matrix which forms the right list 
of some tree is said to
be a <i>well formed right list</i>. 
Since the ordering of the nodes in a right list 
of a given tree is unique, 
the right list of a given tree is unique. 
Conversely, any well formed right list 
specifies a unique tree according to the algorithm
of Program 1.20.</p>

<p>Identical remarks apply to the left list, 
except that Program 1.20 is
replaced by Program 1.21. 
Moreover, the necessary and sufficient conditions 
for the well formation of a left list are identical 
with those for a right list and are derived 
by virtually identical arguments. 
The case will be stated for the right list only.</p>

<p>If <b><i>R</i></b> is a well formed right list 
representing a tree <b>T</b>, 
then the dispersion (i.e., the number of roots) 
<nobr><b>&nu;</b><sub>1</sub>(<b>T</b>) = 
<i>&nu;</i>(<b><i>R</i></b><sub>1</sub>) &ndash; (+/<b><i>R</i></b><sub>1</sub>)</nobr> 
must be strictly positive. 
Moreover, if 
<nobr><b><i>S</i></b> = 
<img src="APLimg/alphaboscore.bmp"><sup><i>&nbsp;j</i></sup>//<b><i>R</i></b></nobr>
is any suffix of <b><i>R</i></b>, 
then <b><i>S</i></b> is a right list of the tree obtained 
by deleting from <b>T</b> the first <i>j</i> nodes 
of the original list.
For, such level-by-level deletion 
always leaves a legitimate tree 
with the degrees of the remaining nodes unchanged. 
Consequently, the number of roots determined 
by every suffix of <b><i>R</i></b><sub>1</sub> 
must also be strictly positive. 
In other words, all components 
of the <i>suffix dispersion vector</i> <b><i>s</i></b> 
defined by</p>

<p>&nbsp; &nbsp; &nbsp;
<b><i>s</i></b><sub><i>j</i></sub> = 
<i>&nu;</i>(<img src="APLimg/alphaboscore.bmp"><sup><i>&nbsp;j</i>&ndash;1</sup>/<b><i>R</i></b><sub>1</sub>),
&nbsp; &nbsp; <i>j</i> &epsilon; 
<b>⍳</b><sup>1</sup>(<i>&nu;</i>(<b><i>R</i></b><sub>1</sub>))</p>
<p>must be strictly positive. The condition is also sufficient.</p>

<p>Sufficiency is easily established 
by induction on the column dimension of <b><i>R</i></b>. 
The condition is clearly sufficient 
for <i>&nu;</i>(<b><i>R</i></b><sub>1</sub>) = 1. 
Assume it sufficient for dimension 
<nobr><i>&nu;</i>(<b><i>R</i></b><sub>1</sub>) &ndash; 1.</nobr> 
If <b><i>s</i></b>, the suffix dispersion vector of <b><i>R</i></b>, 
is strictly positive, 
then <img src="APLimg/alphaboscore.bmp"><sup>1</sup>/<b><i>s</i></b>, 
the suffix dispersion vector 
of <img src="APLimg/alphaboscore.bmp"><sup>1</sup>//<b><i>R</i></b>, 
is also positive, and by hypothesis 
<img src="APLimg/alphaboscore.bmp"><sup>1</sup>//<b><i>R</i></b>
represents a tree <b><i>G</i></b> 
possessing <b><i>s</i></b><sub>2</sub> roots. 
Moreover,</p>

<p>&nbsp; &nbsp; &nbsp;
0 &lt; <b><i>s</i></b><sub>1</sub> =
<b><i>s</i></b><sub>2</sub> + (1 &ndash; <b><i>R</i></b><sub>1</sub><sup>1</sup>)
</p>

<p>implies that 
<nobr><b><i>s</i></b><sub>2</sub> &ge; 
<b><i>R</i></b><sub>1</sub><sup>1</sup>,</nobr>
and the number of roots possessed by <b><i>G</i></b> therefore
fulfills the number of branches required 
by the added node <b><i>R</i></b><sub>2</sub><sup>1</sup>. 
A legitimate tree corresponding to <b><i>R</i></b> 
can therefore be formed by joining the
last <b><i>R</i></b><sub>1</sub><sup>1</sup> roots 
of <b><i>G</i></b> to the node 
<b><i>R</i></b><sub>2</sub><sup>1</sup>.</p>

<p>Tests for well formation can 
therefore be incorporated in any algorithm
defined on a right or left list matrix <b><i>M</i></b> 
by computing the components
of the suffix dispersion vector <b><i>s</i></b>. 
The recursion 
<nobr><b><i>s</i></b><sub><i>i</i>&ndash;1</sub> = 
<b><i>s</i></b><sub><i>i</i></sub> + 1 &ndash; 
<b><i>M</i></b><sub>1</sub><sup><i>i</i>&ndash;1</sup></nobr> 
is convenient in a backward scan of <b><i>M</i></b>, 
and the equivalent recursion
<nobr><b><i>s</i></b><sub><i>i</i></sub> = 
<b><i>s</i></b><sub><i>i</i>&ndash;1</sub> &ndash; 1 + 
<b><i>M</i></b><sub>1</sub><sup><i>i</i>&ndash;1</sup></nobr>
serves for a forward scan. 
The starting condition for a forward scan is 
<nobr><b><i>s</i></b><sub>1</sub> = 
<i>&nu;</i>(<b><i>M</i></b><sub>1</sub>) &ndash; 
(+/<b><i>M</i></b><sub>1</sub>),</nobr> 
and for a backward scan is
<nobr><b><i>s</i></b><sub><i>&nu;</i></sub> = 1 &ndash; 
<b><i>M</i></b><sub>1</sub><sup><i>&mu;</i></sup>.</nobr>
Since the criteria of well formation 
are identical for right and left lists, 
a matrix may be characterized simply 
as well or ill formed.
</p>

<p>The purpose served by the degree vector <b><i>d</i></b> 
in the description of a tree is
sometimes served instead 
[e.g., <acronym title="Burks, A.W., D.W. Warren, and J.B. Wright (1954), 
“An Analysis of a Logical Machine Using Parenthesis-free Notation”, 
Mathematical Tables and Other Aids to Computation, 
vol. VIII, pp. 53-57.">Burks et al. (1954)</acronym>] 
by the vector 
<nobr><b><i>g</i></b> = <tt><b>∊</b></tt> &ndash; <b><i>d</i></b>.</nobr> 
It is somewhat more convenient 
in the analysis of well formation,
since the expression for the suffix dispersion vector 
then simplifies to</p>

<p>&nbsp; &nbsp; &nbsp; 
<b><i>s</i></b><sub><i>j</i>+1</sub> = 
(+/<img src="APLimg/alphaboscore.bmp"><sup><i>&nbsp;j</i></sup>/<b><i>g</i></b>),
&nbsp; or &nbsp;
<b><i>s</i></b> = 
(<font face="Arial"><b><i>I</i></b></font> 
+ <img src="APLimg/quadne.bmp">)<img src="APLimg/minusslash.bmp">/<b><i>g</i></b>.</p>



<a name="1.23.5"></a>
<p><b>The index matrix as a function of the degree vector</b></p>

<p>The complete determination of the tree corresponding 
to a given list matrix <b><i>M</i></b> 
is best described as the determination 
of the associated index matrix <b><i>I</i></b>. 
For both left and right lists 
this can be achieved by a single
forward scan of the rows of <b><i>M</i></b> 
and of <b><i>I</i></b>.</p>

<p>For a right list <b><i>R</i></b> 
it is first necessary to determine <i>r</i>, the number of roots.
The first <i>r</i> components of <b><i>R</i></b> 
are then the roots of the tree in order, 
the next <b><i>R</i></b><sub>1</sub><sup>1</sup> 
components of <b><i>R</i></b> 
are the second-level nodes reachable 
from the first root, and so forth. 
Programs 1.20 and 1.21 describe the processes 
for a right list and a left list, respectively.</p>

<table align=center>
<tr><td valign=top><img src="APLimg/prog1x20.bmp"></td>
 <td nowrap>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
 <td valign=top><table border=1 cellspacing=0 cellpadding=4>
  <tr><td align=center>1-origin indexing</td></tr>
  <tr><td><table>
  <tr><td><b><i>R</i></b></td>
   <td nowrap>&nbsp; &nbsp;</td><td>Right list of <b>T</b>.</td>
   </tr>
  <tr><td valign=top><b><i>I</i></b></td>
   <td>&nbsp;</td><td>Right index matrix of <b>T</b>.</td>
   </tr>
  <tr><td valign=top><b><i>i</i></b></td>
   <td>&nbsp;</td><td>Index of row of <b><i>R</i></b> currently examined.</td>
   </tr>
  <tr><td valign=top><i>j</i></td>
   <td>&nbsp;</td><td>Right list index of node reachable from node <i>i</i>.</td>
   </tr>
  <tr><td valign=top><b><i>v</i></b></td>
   <td>&nbsp;</td><td>Current index vector.</td>
   </tr>
  <tr><td valign=top><i>&phi;</i></td>
   <td>&nbsp;</td><td>Origin with respect to which <b><i>I</i></b> 
   is finally expressed.</td>
   </tr>
  </table>
 </td></tr></table> <p align=center><b>Legend</b></p></td></tr>
<tr><td colspan=3 align=center><b>Program 1.20</b> &nbsp; 
Determination of the index matrix <b><i>I</i></b> <br>
associated with a right list matrix <b><i>R</i></b></td></tr> 
</table>
<br>

<table><tr><td>&nbsp;</td><td>
<p><b>Program 1.20</b>. In each execution of the main loop 13-16, 
the <i>i</i>th row of the right list <b><i>R</i></b> 
is examined to determine the index vector 
of each node on the succeeding
level which is directly reachable from it. 
The number of such nodes is controlled
by the parameter <i>d</i>, 
initialized to the degree 
of the <i>i</i>th node by step 12.
The (right list) index of the nodes reachable 
from node <i>i</i> is determined by <i>j</i>, 
which is incremented on step 14 
as the index vector of each node is determined. 
The index vectors of the successive nodes reachable 
from node <i>i</i> have the final components
<nobr>1, 2, 3, &#133;,</nobr> 
and each must be prefixed by the index vector 
of node <i>i</i>.
This assignment is effected by the vector <b><i>v</i></b>, 
which is initialized by the index vector
of node <i>i</i> rotated left by one (step 11), 
and which is incremented by step 15 before
each assignment occurring on step 16. 
At the outset, <b><i>v</i></b> is set to zero 
and <i>d</i> is set to the number 
of roots as determined by step 4.</p>

<p>Since <i>j</i> is, at step 10, 
equal to the current number of roots <i>r</i> augmented 
by the cumulative degrees 
of the first <nobr><i>i</i> &ndash; 1</nobr> nodes, 
then <nobr><i>r</i> = <i>j</i> &ndash; <i>i</i> + 1</nobr> 
and the exit on step 10 therefore occurs always 
and only in the event of ill formation. 
Alternatively, the test can be viewed 
as an assurance that each row 
of the matrix <b><i>I</i></b> is
specified before it is itself used in specification.</p>

<p>When step 5 is first reached, 
the index matrix <b><i>I</i></b> is complete 
but is expressed in 1-origin indexing 
with zeros representing the null elements. 
Steps 5-7 translate
the matrix to the origin <i>&phi;</i> 
and mask in the necessary null elements.</p>
</td><td>&nbsp;</td></tr></table>
<br>

<table align=center>
<tr><td valign=top><img src="APLimg/prog1x21.bmp"></td>
 <td nowrap>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
 <td valign=top><table border=1 cellspacing=0 cellpadding=4>
  <tr><td align=center>1-origin indexing</td></tr>
  <tr><td><table>
  <tr><td><b><i>L</i></b></td>
   <td nowrap>&nbsp; &nbsp;</td><td>Right list of <b>T</b>.</td>
   </tr>
  <tr><td valign=top><b><i>I</i></b></td>
   <td>&nbsp;</td><td>Left index matrix of <b>T</b>.</td>
   </tr>
  <tr><td valign=top><i>j</i></td>
   <td>&nbsp;</td><td>Index of row of <b><i>I</i></b> currently determined.</td>
   </tr>
  <tr><td valign=top><i>i</i></td>
   <td>&nbsp;</td><td>Left list index of path node <i>j</i> in current path (step 16),
   or index of last previous node whose branches remain unexhausted (step 22).</td>
   </tr>
  <tr><td valign=top><b><i>c</i></b><sub><i>i</i>+1</sub></td>
   <td>&nbsp;</td><td>Index of node following node <i>i</i> in the last path traced from <i>i</i>.</td>
   </tr>
  <tr><td valign=top><i>r</i></td>
   <td>&nbsp;</td><td>Pararmeter for testing well formation.</td>
   </tr>
  <tr><td valign=top><b><i>v</i></b></td>
   <td>&nbsp;</td><td>Current index vector.</td>
   </tr>
  <tr><td valign=top><i>&phi;</i></td>
   <td>&nbsp;</td><td>Origin with respect to which <b><i>I</i></b> 
   is expressed.</td>
   </tr>
  </table>
 </td></tr></table> <p align=center><b>Legend</b></p></td></tr>
<tr><td colspan=3 align=center><b>Program 1.21</b> &nbsp; 
Determination of the index matrix <b><i>I</i></b> <br>
associated with a left list matrix <b><i>L</i></b></td></tr> 
</table>
<br>

<table><tr><td>&nbsp;</td><td>
<p><b>Program 1.21</b>. 
The index vectors <b><i>I</i></b><sup><i>&nbsp;j</i></sup> 
are determined in order under control of the parameter. 
The loop 5-18 traces a continuous path through the tree, 
determining the index of each successive node 
of the path by rotating the index of the
preceding node (step 17) and adding one 
to the last component (step 13), 
and maintaining in the connection vector <b><i>c</i></b> 
a record <b><i>c</i></b><sub><i>i</i>+1</sub> 
of the index <i>j</i> of the successor
of node <i>i</i> in the path traced. 
The path is interrupted by the occurrence of a leaf
(that is, 
<nobr><b><i>L</i></b><sub>1</sub><sup><i>j</i></sup> = 0</nobr> 
on step 18), 
and the degree vector <b><i>L</i></b><sub>1</sub> 
is then scanned by the loop (19-20) 
to determine the index <i>i</i>
of the last preceding node 
whose branches remain incompleted. 
Steps 22-23 then respecify <b><i>v</i></b> 
as the index vector of the node following
node <i>i</i> in the path last traced, 
and step 21 decrements the component 
<b><i>L</i></b><sub>1</sub><sup><i>i</i></sup> 
of the degree vector. 
The branch from step 19 to step 22 
occurs at the completion of each rooted subtree. 
The test for well formation (step 12) 
is the same as that applied to the right list 
in Program 1.20, 
except that the notation for the relevant parameters differs. 
The concluding operations (6-9) include 
left justification on step 7.</p>
</td><td>&nbsp;</td></tr></table>



<a name="1.23.6"></a>
<p><b>Tree, path, and level compression</b></p>

<p>The <i>tree compression</i></p>

<p>&nbsp; &nbsp; &nbsp; <b>P</b> &larr; <b>U</b>/<b>T</b></p>

<p>specifies a tree <b>P</b> obtained from <b>T</b> 
by suppressing those nodes corresponding
to zeros of the logical tree <b>U</b>, 
and reconnecting so that for every
pair of nodes <i>x</i>,&nbsp;<i>y</i> of <b>P</b>, 
<i>x</i> belongs to the subtree 
of <b>P</b> rooted in <i>y</i> if and only if 
<i>x</i> belongs to the subtree of <b>T</b> rooted in <i>y</i>. 
If, for example, <b>T</b> is the tree 
of Fig. 1.16 
with <b><i>n</i></b> as the alphabet, 
and <b>U</b> is the tree of Fig. 1.22a, 
then <b>P</b> is the tree of Fig. 1.22b. 
The new indices are shown to the left 
of each node of <b>P</b>. 
The set of nodes <nobr>221, 222, &#133;, 226,</nobr> 
are all on the same level of <b>P</b>
although they have been shown 
with branches of different lengths to
permit easy identification with the nodes 
of the original tree <b>T</b>.</p>

<table align=center>
<tr>
 <td align=center><img src="APLimg/fig1x22a.bmp">
 <p align center><b>U</b><br>(<i>a</i>)</p></td>
 <td valign=top><img src="APLimg/fig1x22v.bmp"></td>
 <td align=center><img src="APLimg/fig1x22b.bmp">
 <p align center><b>U</b>/<b>T</b><br>(<i>b</i>)</p></td>
 </tr>
<tr><td align=center colspan=3><b>Figure 1.22</b>. Compression of tree
<b>T</b> of Fig. 1.16
(with <b><i>n</i></b> = alphabet)</td></tr>
</table>

<p>The compress operation is best executed 
on the left list 
because of the grouping by subtrees. 
Program 1.23 gives a suitable algorithm 
which also serves as a formal definition 
of the compress operation.</p>

<table align=center>
<tr><td valign=top><img src="APLimg/prog1x23.bmp"></td>
 <td nowrap>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
 <td valign=top><table border=1 cellspacing=0 cellpadding=4>
  <tr><td align=center>1-origin indexing</td></tr>
  <tr><td><table>
  <tr><td><b><i>u</i></b></td>
   <td nowrap>&nbsp; &nbsp;</td><td>Left node vector of <b>U</b>.</td>
   </tr>
  <tr><td valign=top><b><i>L</i></b></td>
   <td>&nbsp;</td><td>Left list of <b>T</b>.</td>
   </tr>
  <tr><td valign=top><i>j</i></td>
   <td>&nbsp;</td><td>Index of first zero of <b><i>u</i></b> (steps 4-8).
   Index of root of smallest subtree containing deleted node (step 12).</td>
   </tr>
  <tr><td valign=top><i>d</i></td>
   <td>&nbsp;</td><td>Change of degree caused by deletion of <i>j</i>.</td>
   </tr>
  <tr><td valign=top><i>r</i></td>
   <td>&nbsp;</td><td>Number of roots indicated by infix
   (<tt><b>⍺</b></tt><sup><i>&nbsp;j</i></sup> &and; 
   <img src="APLimg/alphaboscore.bmp"><sup><i>&nbsp;k</i></sup>)//<b><i>L</i></b>,
   where <i>j</i> is initial value and 
   <nobr><i>k</i> + 1</nobr> is current value of <i>j</i>.</td>
   </tr>
  </table>
 </td></tr></table> <p align=center><b>Legend</b></p></td></tr>
<tr><td colspan=3 align=center><b>Program 1.23</b> &nbsp; 
Determination of the left list <b><i>L</i></b> = 
<tt><b>⍺</b></tt><sup>2</sup>/[(<b>U</b>/<b>T</b>)</td></tr> 
</table>
<br>

<table><tr><td>&nbsp;</td><td>
<p><b>Program 1.23</b>. 
The vector <b><i>u</i></b> is specified 
as the node vector of the left list 
of the controlling logical tree <b>U</b> 
and controls the subsequent process. 
Step 4 determines <i>j</i> as the index 
of the first zero component of <b><i>u</i></b>. 
Steps 6 and 7 then delete the corresponding
nodes of <b><i>u</i></b> and 
of the left list of <b>T</b>, 
but only after step 5 has determined <i>d</i>
as the change in degree 
which this deletion  will occasion 
to the root of the smallest subtree 
containing the deleted node. 
Steps 9-11 perform a backward scan 
of the degree vector to determine <i>j</i>
as the index of the root of the subtree, 
and step 12 effects the requisite change 
in its degree. 
The exit on step 9 occurs only if the node
deleted is a root of the original tree, 
in which event no change is produced 
in the degree of any other node.</p>
</td><td>&nbsp;</td></tr></table>

<a name="path_compression"></a>
<p>Two further compress operations controlled 
by logical vectors are defined as follows. 
<i>Path compression</i> is denoted by</p>

<p>&nbsp; &nbsp; &nbsp; <b>P</b> &larr; 
<b><i>u</i></b>/<b>T</b>.</p>

<p><b>P</b> is obtained from <b>T</b> 
by suppressing every node on level <i>j</i> 
if <nobr><b><i>u</i></b><sub><i>&nbsp;j</i></sub> = 0,</nobr> and
reconnecting as in tree compression.
<a name="level_compression"></a>
<i>Level compression</i> is denoted by</p>

<p>&nbsp; &nbsp; &nbsp; <b>P</b> &larr; 
<b><i>u</i></b>//<b>T</b>,</p>

<p>and <b>P</b> is obtained from <b>T</b> 
by deleting each rooted subtree 
<b>T</b><sub><i>i</i></sub> for which
<nobr><b><i>u</i></b><sub><i>&nbsp;i</i></sub> = 0.</nobr></p>

<p>Path compression by a unit vector 
<tt><b>∊</b></tt><sup><i>&nbsp;j</i></sup> 
produces a tree of height one.
Such a tree is, in effect, 
a vector and will be treated as one.</p>

<a name="full_tree"></a>
<p>Two related special logical trees are defined: 
the <i>path tree</i>
<sup><b><i>u</i></b></sup><font face="Arial"><b>E</b></font> 
such that
<nobr><img src="APLimg/uboscore.bmp">/<sup><b><i>&nbsp;u</i></b></sup><font face="Arial"><b>E</b></font> 
= 0</nobr> and 
<b><i>u</i></b>/<sup><b><i>&nbsp;u</i></b></sup><font face="Arial"><b>E</b></font> 
is the full tree <font face="Arial"><b>E</b></font> 
whose nodes are all unity, 
and the <i>level tree</i> 
<sub><b><i>u</i></b></sub><font face="Arial"><b>E</b></font> 
such that 
<nobr><img src="APLimg/uboscore.bmp">//<sub><b><i>u</i></b></sub><font face="Arial"><b>E</b></font> 
= 0,</nobr> and 
<nobr><b><i>u</i></b>//<sub><b><i>u</i></b></sub><font face="Arial"><b>E</b></font> 
= <font face="Arial"><b>E</b></font>.</nobr></p>



<a name="1.23.7"></a>
<p><b>Extension of other operations to trees</b></p>

<p>Two trees are <i>compatible</i> 
if they have the same structure. 
Elementary binary operations 
are extended node by node to compatible trees. 
For example,</p>

<p>&nbsp; &nbsp; &nbsp; <b>Z</b> &larr; <b>X</b> &times; <b>Y</b></p>

<p>implies that node <b><i>i</i></b> of <b>Z</b> 
is the product of node <b><i>i</i></b> of <b>X</b> 
and node <b><i>i</i></b> of <b>Y</b> for all <b><i>i</i></b>.
<a name="tree_iota"></a>
Similarly,</p>

<p>&nbsp; &nbsp; &nbsp; <b>M</b> &larr; <b><i>b</i></b> 
<tt><b>⍳</b></tt><sub><i>&nbsp;j</i></sub> <b>T</b></p>

<p>specifies <b>M</b> as a tree 
(of the same structure as <b>T</b>) 
such that node <b><i>i</i></b> of <b>M</b> is
the <i>j</i>-origin <b><i>b</i></b>-index 
of node <b><i>i</i></b> of <b>T</b>.</p>

<a name="tree_map"></a>
<p>The mapping operation is extended to trees 
so as to permute the rooted subtrees of a tree. 
Formally</p>

<p>&nbsp; &nbsp; &nbsp; <b>P</b> &larr; <b><i>m</i></b> 
&int;<sub><i>j</i></sub> <b>T</b></p>

<p>implies that 
<nobr><b>&mu;</b><sub>1</sub>(<b>P</b>) = 
<i>&nu;</i>(<b><i>m</i></b>),</nobr>
that <b>P</b><sub><i>i</i></sub> 
is a single null character if 
<nobr><b><i>m</i></b><sub><i>i</i></sub> 
<tt>&notin;</tt> <tt><b>⍳</b></tt><sup><i>j</i></sup>(<b>&mu;</b><sub>1</sub>(<b>T</b>)),</nobr>
and otherwise 
<nobr><b>P</b><sub><i>i</i></sub> = 
<b>T</b><sub><b><i>m</i></b></sub>,</nobr>
where <i>j</i>-origin indexing is used for <b>T</b>.</p>

<p>Permutation of the subtrees rooted 
in node <b><i>i</i></b> of <b>T</b> 
can be effected as follows:</p>

<p>&nbsp; &nbsp; &nbsp; 
<img src="APLimg/alphaboscore.bmp"><sup>1</sup>/<b>T</b><sub><b><i>i</i></b></sub>
&larr; <b><i>m</i></b> &int; 
(<img src="APLimg/alphaboscore.bmp"><sup>1</sup>/<b>T</b><sub><b><i>i</i></b></sub>)</p>

<a name="tree_reduction"></a>
<p>The notation <img src="APLimg/circledot.bmp">//<b>T</b>
will denote the application of the binary operator 
or relation <img src="APLimg/circledot.bmp"> 
to the nodes of <b>T</b> in right list order 
(i.e., <i>down</i> successive levels)
and <img src="APLimg/circledot.bmp">/<b>T</b> 
will denote the same application in left list order 
(i.e., <i>across</i> paths). 
If the operator is symmetric 
(i.e., its operands commute), then 
<nobr><img src="APLimg/circledot.bmp">//<b>T</b> = 
<img src="APLimg/circledot.bmp">/<b>T</b></nobr>.</p>

<a name="tree_max"></a>
<p>Maximization (<b>U</b><tt>⌈</tt><b>T</b>) 
and minimization (<b>U</b><tt>⌊</tt><b>T</b>) 
are extended to trees in the obvious way.</p>

<a name="fig1.24"></a>
<table align=center><tr><td><table align=center border=1 cellspacing=0 cellpadding=10>
<tr><td colspan=2 align=center><b>U</b> &nbsp; &nbsp; <img align=middle src="APLimg/fig1x24a.bmp"></td></tr>
<tr><td><tt>⍺</tt>/<b>U</b> &nbsp; &nbsp; <img align=middle src="APLimg/fig1x24b.bmp"></td>
    <td><img align=middle src="APLimg/fig1x24c.bmp"> &nbsp; &nbsp; <tt>⍺</tt>//<b>U</b></td></tr>
<tr><td><tt>⍵</tt>/<b>U</b> &nbsp; &nbsp; <img align=middle src="APLimg/fig1x24d.bmp"></td>
    <td><img align=middle src="APLimg/fig1x24e.bmp"> &nbsp; &nbsp; <tt>⍵</tt>//<b>U</b></td></tr>
<tr><td><i>&sigma;</i>/<b>U</b> &nbsp; &nbsp; <img align=middle src="APLimg/fig1x24f.bmp"></td>
    <td><img align=middle src="APLimg/fig1x24g.bmp"> &nbsp; &nbsp; <i>&sigma;</i>//<b>U</b></td></tr>
<tr><td><i>&tau;</i>/<b>U</b> &nbsp; &nbsp; <img align=middle src="APLimg/fig1x24h.bmp"></td>
    <td><img align=middle src="APLimg/fig1x24i.bmp"> &nbsp; &nbsp; <i>&tau;</i>//<b>U</b></td></tr>
</table></td></tr>
<tr><td align=center><br><b>Figure 1.24</b>. Set selection and
maximum prefix and suffix operations</td></tr>
</table>

<p>The operations <tt>⍺</tt>/<b><i>u</i></b>, 
<tt>⍵</tt>/<b><i>u</i></b>, 
<i>&sigma;</i>/<b><i>u</i></b>, 
and <i>&tau;</i>/<b><i>u</i></b> 
are each extended in two ways:
across paths and down levels. 
Examples of each appear in Fig. 1.24.
Operations extending down levels are denoted by double virgules and
represent an application of the corresponding vector operation to each
level of the tree considered as a vector. For example, the statement</p>

<p>&nbsp; &nbsp; &nbsp; <b>V</b> &larr; <i>&sigma;</i>//<b>A</b></p>

<p>implies that each level of <b>V</b> 
is the forward set selection 
of the corresponding level of <b>A</b>, 
that is, 
<nobr><tt><b>∊</b></tt><sup><i>&nbsp;j</i></sup>/<b>V</b> =
<i>&sigma;</i>/<tt><b>∊</b></tt><sup><i>&nbsp;j</i></sup>/<b>A</b>.</nobr>
Operations extending across paths are
denoted by single virgules 
and are defined in terms of subtrees. Thus</p>

<p>&nbsp; &nbsp; &nbsp; <b>V</b> &larr; <tt>⍺</tt>/<b>U</b></p>

<p>implies that <b>V</b> is obtained 
from the logical tree <b>U</b> by setting to zero all
nodes of any subtree rooted in a zero node, and</p>

<p>&nbsp; &nbsp; &nbsp; <b>V</b> &larr; <tt>⍵</tt>/<b>U</b></p>

<p>implies that <b>V</b> is obtained 
from <b>U</b> by setting to zero every node 
whose subtree contains a zero node. 
The definitions of <i>&sigma;</i>/<b>U</b> 
and <i>&tau;</i>/<b>U</b> are analogous.</p>



<a name="1.23.8"></a>
<p><b>Homogeneous trees</b></p>

<p>If, for all <i>j</i>, 
every node on level <i>j</i> 
of a tree <b>T</b> is either of degree zero or of
degree <b>&nu;</b><sub><i>&nbsp;j</i>+1</sub>(<b>T</b>), 
then the tree <b>T</b> is said to be <i>uniform</i>. 
If all leaves of a uniform tree <b>T</b> lie 
in the same level (necessarily the top), 
then the tree is said to be <i>homogeneous</i>. 
The structure of a homogeneous tree 
is completely characterized 
by its dispersion vector <b>&nu;</b>(<b>T</b>)). 
All maximal paths in a homogeneous
tree are clearly of the same length, namely 
<nobr><i>&nu;</i>(<b>T</b>) = 
<i>&nu;</i>(<b>&nu;</b>(<b>T</b>)).</nobr> 
Figure 1.25 shows a homogeneous tree 
and its associated dispersion vector.</p>

<table align=center>
<tr><td align=center><img src="APLimg/fig1x25.bmp"></td></tr>
<tr><td align=center><table>
<tr><td><b>&nu;</b>(<b>H</b>)</td><td>=</td><td>(2, 3, 2)</td></tr>
<tr><td><b>&mu;</b>(<b>H</b>)</td><td>=</td><td>(2, 6, 12)</td></tr>
</table></td></tr>
<tr><td align=center><b>Figure 1.25</b>. Homogeneous tree
<b>H</b> and dispersion and moment vectors</td></tr>
</table>

<p>A tree <b>T</b> for which 
<nobr><b>&nu;</b>(<b>T</b>) = <i>m</i><tt><b>∊</b></tt></nobr>
is called an <i>m-way tree</i>, 
and a tree for which 
<nobr><b>&nu;</b><sub>1</sub>(<b>T</b>) = 1</nobr> and 
<nobr><img src="APLimg/alphaboscore.bmp"><sup>1</sup>/<b>&nu;</b>(<b>T</b>) 
= <i>m</i><tt><b>∊</b></tt></nobr> 
is called a <i>singular m-way tree</i>.</p>

<p>The <i>j</i>th component of the moment vector 
of a homogeneous tree is clearly equal to 
the product of the first j components 
of the dispersion vector, that is, 
<nobr><b>&mu;</b>(<b>T</b>) = 
(<img src="APLimg/quadsw.bmp"> + <font face="Arial"><b><i>I</i></b></font>) 
<img src="APLimg/timesslash.bmp"> <b>&nu;</b>(<b>T</b>)).</nobr> 
The dispersion vector is, in turn, 
uniquely determined by the moment vector. 
The total number of nodes is given by 
<nobr><i>&mu;</i>(<b>T</b>) = 
+/<b>&mu;</b>(<b>T</b>),</nobr>
and it can also be shown that 
<nobr><i>&mu;</i>(<b>T</b>) = 
<b><i>y</i></b> <tt>⊥</tt> <b><i>y</i></b>,</nobr>
where <b><i>y</i></b> is the dispersion vector 
in reverse order.</p>

<p>Tree compression of a homogeneous tree <b>H</b>
(that is, <b>U</b>/<b>H</b>) 
does not generally produce a homogeneous tree, 
and, in fact, any tree <b>P</b> of
arbitrary structure can be represented 
by a pair of homogeneous trees <b>U</b> and <b>H</b> 
such that <nobr><b>P</b> = <b>U</b>/<b>H</b>.</nobr> 
On the other hand, both path and level
compression of homogeneous trees produce
homogeneous trees. Moreover, 
if <nobr><b>P</b> = <b><i>u</i></b>/<b>H</b>,</nobr> then 
<nobr><b>&nu;</b>(<b>P</b>) = <b><i>u</i></b>/<b>&nu;</b>(<b>H</b>),</nobr> 
and if 
<nobr><b>P</b> = <b><i>u</i></b>//<b>H</b>,</nobr> 
then 
<nobr><b>&nu;</b>(<b>P</b>) = <b>&nu;</b>(<b>H</b>) &ndash; 
(+/<img src="APLimg/uboscore.bmp">)<tt><b>⍺</b></tt><sup>1</sup>.</nobr></p>

<a name="full_tree_k"></a>
<p>Since the structure of a homogeneous tree is
completely specified 
by its dispersion vector <b><i>k</i></b>,
the structure of the special logical trees can be
specified in the forms 
<font face="Arial"><b><i>E</i></b></font>(<b><i>k</i></b>), 
<sup><b><i>u</i></b></sup><font face="Arial"><b><i>E</i></b></font>(<b><i>k</i></b>), and 
<sub><b><i>u</i></b></sub><font face="Arial"><b><i>E</i></b></font>(<b><i>k</i></b>).</p>

<p>In a homogeneous tree, 
the right list or left list index 
of a node can be determined 
as an explicit function of its index vector. 
Conversely,
the index vector <b><i>i</i></b> 
can be determined directly
from the corresponding left list index, 
to be denoted by <i>l</i>(<b><i>i</i></b>), 
or from the right list index <i>r</i>(<b><i>i</i></b>).
In developing the relations between indices 
it will be convenient 
to use 0-origin indexing throughout.</p>

<p>The right list index is given by</p>

<p>&nbsp; &nbsp; &nbsp; <i>r</i>(<b><i>i</i></b>) 
= <i>f</i>(<b><i>i</i></b>) + <i>g</i>(<b><i>i</i></b>),</p>

<p>where<br>&nbsp; &nbsp; &nbsp; <i>f</i>(<b><i>i</i></b>) 
= +/<tt><b>⍺</b></tt><sup><i>&nu;</i>(<b><i>i</i></b>)&ndash;1</sup>/<b>&mu;</b>(<b>T</b>)</p>

<p>is the number of nodes in the first 
<nobr><i>&nu;</i>(<b><i>i</i></b>) &ndash; 1</nobr> 
levels, and</p>

<p>&nbsp; &nbsp; &nbsp; <i>g</i>(<b><i>i</i></b>) = 
(<tt><b>⍺</b></tt><sup><i>&nu;</i>(<b><i>i</i></b>)</sup>/<b>&nu;</b>(<b>T</b>)) 
<tt>⊥</tt> <b><i>i</i></b></p>

<p>is the rank of node <b><i>i</i></b> 
in the <i>&nu;</i>(<b><i>i</i></b>)th level. 
For example, if 
<nobr><b><i>i</i></b> = (1, 0, 1)</nobr> 
in the tree of Fig. 1.25, then 
<nobr><b>&mu;</b>(<b>H</b>) = (2, 6, 12),</nobr>
<nobr><i>f</i>(<b><i>i</i></b>) = +/(2, 6) = 8,</nobr> and
<nobr><i>g</i>(<b><i>i</i></b>) = (2, 3, 2) <tt>⊥</tt> (1, 0, 1) = 7.</nobr></p>

<p>Since <i>f</i>(<b><i>i</i></b>) depends only on <i>&nu;</i>(<b><i>i</i></b>), 
the index <b><i>i</i></b> may be determined 
from <i>r</i> by first determining <i>&nu;</i>(<b><i>i</i></b>) 
as the largest value for which 
<nobr><i>f</i>(<b><i>i</i></b>) &le; <i>r</i>,</nobr> 
and then determining <b><i>i</i></b> such that</p>

<p>&nbsp; &nbsp; &nbsp; (<tt><b>⍺</b></tt><sup><i>&nu;</i>(<b><i>i</i></b>)</sup>/<b>&nu;</b>(<b>T</b>)) <tt>⊥</tt> <b><i>i</i></b> 
= <i>r</i> &ndash; <i>f</i>(<b><i>i</i></b>).</p>

<p>In tracing a path through a tree, 
the <i>k</i>th node of the set reachable from
node <b><i>i</i></b> is the node 
<nobr><b><i>j</i></b> = <b><i>i</i></b> <img src="APLimg/circleplus.bmp"> (<i>k</i>).</nobr> 
It is therefore useful to express <i>r</i>(<b><i>j</i></b>) as a
function of <i>r</i>(<b><i>i</i></b>). Clearly</p>

<table>
<tr><td>&nbsp; &nbsp; &nbsp;</td><td><i>f</i>(<b><i>j</i></b>) = <i>f</i>(<b><i>i</i></b>) + 
(<b>&mu;</b>(<b>T</b>))<sub><i>&nu;</i>(<b><i>i</i></b>)&ndash;1</sub>,</td></tr>
<tr><td>&nbsp;</td><td><i>g</i>(<b><i>j</i></b>) = <i>g</i>(<b><i>i</i></b>) &times;
(<b>&nu;</b>(<b>T</b>))<sub><i>&nu;</i>(<b><i>i</i></b>)</sub> + 
<b><i>j</i></b><sub><i>&nu;</i>&ndash;1</sub>.</td></tr></table>

<p>In the special case of a singular homogeneous <i>m</i>-way tree,</p>

<table>
<tr><td>&nbsp; &nbsp; &nbsp;</td><td><i>f</i>(<b><i>i</i></b>)</td><td>= </td>
<td>1+ <i>m</i> + <i>m</i><sup>2</sup> + &#133; + <i>m</i><sup><i>&nu;</i>(<b><i>i</i></b>)&ndash;2</sup>
<tr><td colspan=2>&nbsp;</td><td valign=middle>=</td>
 <td>(<i>m</i><tt><b>∊</b></tt>) <tt>⊥</tt> <tt><b>∊</b></tt>(<i>&nu;</i>(<b><i>i</i></b>) &ndash; 1)</td></tr>
<tr><td colspan=2>&nbsp;</td><td valign=middle>=</td><td><table><tr><td>
<p align=center><i>m</i><sup><i>&nu;</i>(<b><i>i</i></b>)&ndash;1</sup> &ndash; 1<br>
<img src="APLimg/hline1x23x8.bmp"><br>
<i>m</i> &ndash; 1</p></td></tr>
</table></td></tr>
</table>

<p>Hence <nobr><i>f</i>(<b><i>j</i></b>) = 
1 + <i>m</i> &times; <i>f</i>(<b><i>i</i></b>),</nobr> and 
<i>g</i>(<b><i>j</i></b>) = m &times; <i>g</i>(<b><i>i</i></b>) + 
<b><i>j</i></b><sub><i>&nu;</i>&ndash;1</sub>.</nobr>
Recursion can therefore be performed simply 
upon the single function <i>r</i>(<b><i>i</i></b>) as follows:</p>

<p>&nbsp; &nbsp; &nbsp; 
<i>r</i>(<b><i>j</i></b>) = <i>m</i> &times; 
<i>r</i>(<b><i>i</i></b>) + 1 + <b><i>j</i></b><sub><i>&nu;</i>&ndash;1</sub>.</p>

<p>The left list index <i>l</i>(<b><i>i</i></b>) 
is most conveniently expressed as a function of
<i>&nu;</i>(<b><i>i</i></b>) and 
of the vector <b><i>z</i></b>(<b><i>i</i></b>) 
(zero extension of <b><i>i</i></b>), 
where <nobr><b><i>z</i></b> = 
<tt><b>⍺</b></tt><sup><i>&nu;</i>(<b><i>i</i></b>)</sup>(<i>&nu;</i>(<b>T</b>))\ <b><i>i</i></b>.</nobr>
Clearly 
<nobr><i>&nu;</i>(<b><i>z</i></b>) = <i>&nu;</i>(<b>T</b>)</nobr> 
and <b><i>z</i></b> is the index 
of the &ldquo;earliest&rdquo; leaf reachable from node <b><i>i</i></b>. 
In Fig. 1.25, for example, 
<nobr><b><i>z</i></b>((1, 2)) = (1,2,0).</nobr></p>

<p>The zero extension has the obvious property 
that every node above the
path <b>T</b><sup>&nbsp;<b><i>z</i></b>(<b><i>i</i></b>)</sup> 
precedes node <b><i>i</i></b> in the left list, 
and every node below the path follows it. 
The number of nodes in the path which precede node <b><i>i</i></b> 
is <nobr><i>&nu;</i>(<b><i>i</i></b>) &ndash; 1.</nobr></p>

<p>The number of leaves above the path 
<b>T</b><sup>&nbsp;<b><i>z</i></b>(<b><i>i</i></b>)</sup> is 
<nobr><b>&nu;</b>(<b>T</b>) <tt>⊥</tt> <b><i>z</i></b>(<b><i>i</i></b>),</nobr> 
and more generally, 
the number of (<i>j</i>&nbsp;&ndash;&nbsp;1)th level nodes 
above it is given by
<nobr>(<tt><b>⍺</b></tt><sup><i>j</i></sup>/<b>&nu;</b>(<b>T</b>)) 
<tt>⊥</tt> (<tt><b>⍺</b></tt><sup><i>&nbsp;j</i></sup>/<b><i>z</i></b>(<b><i>i</i></b>)).</nobr> 
Consequently,</p>

<p>&nbsp; &nbsp; &nbsp; <i>l</i>(<b><i>i</i></b>) =
<i>&nu;</i>(<b><i>i</i></b>) &ndash; 1 + <img align=middle src="APLimg/sigma1x23.bmp">
(<b>⍺</b></tt><sup><i>&nbsp;j</i></sup>/<b>&nu;</b>(<b>T</b>))
<tt>⊥</tt> (<b>⍺</b></tt><sup><i>&nbsp;j</i></sup>/<b><i>z</i></b>(<b><i>i</i></b>)).
</p>

<p>For example, if 
<nobr><b><i>i</i></b> = (1,0)</nobr> 
in Fig. 1.25, then 
<nobr><b><i>z</i></b>(<b><i>i</i></b>) = (1, 0, 0)</nobr> and
<i>l</i>(<b><i>i</i></b>) = <nobr><i>&nu;</i>(<b><i>i</i></b>) 
&ndash; 1 + (2) <tt>⊥</tt> (1) + (2, 3) <tt>⊥</tt> (1, 0) + (2, 3, 2) <tt>⊥</tt> (1, 0, 0) = 11.</nobr>
The foregoing result may be written alternatively as</p>

<p>&nbsp; &nbsp; &nbsp; <i>l</i>(<b><i>i</i></b>) = <nobr><i>&nu;</i>(<b><i>i</i></b>) 
&ndash; 1 + <b><i>w</i></b> <img src="APLimg/plustimes.bmp"> <b><i>z</i></b>(<b><i>i</i></b>),</p>

<p>where <nobr><b><i>w</i></b><sub><i>&nu;</i></sub> = 1,</nobr>
and <nobr><b><i>w</i></b><sub><i>i</i>&ndash;1</sub> = 1 + 
(<b><i>w</i></b><sub><i>i</i></sub> &times; 
<b>&nu;</b><sub><i>i</i></sub>(<b>T</b>)).</nobr>
In the foregoing example,
<nobr><b><i>w</i></b> = (10, 3, 1),</nobr> and 
<nobr><b><i>w</i></b> <img src="APLimg/plustimes.bmp"> 
<b><i>z</i></b>(<b><i>i</i></b>) = 10.</nobr> 
This form is most convenient for
determining <b><i>i</i></b> as a function of <i>l</i>, 
for since 
<nobr><b><i>w</i></b> <img src="APLimg/plustimes.bmp"> 
<b><i>z</i></b> = <i>l</i> + 1 &ndash; 
<i>&nu;</i>(<b><i>i</i></b>),</nobr> then 
<nobr><b><i>z</i></b><sub>&nbsp;0</sub>(<b><i>i</i></b>) = 
<tt>⌊</tt><i>l</i> <tt>÷</tt> 
<b><i>w</i></b><sub>0</sub><tt>&rfloor;</tt>,</nobr>
<nobr><b><i>z</i></b><sub>&nbsp;1</sub>(<b><i>i</i></b>) = 
<tt>⌊</tt>((<b><i>w</i></b><sub>0</sub> | <i>l</i>) &ndash; 1)
<tt>÷</tt> <b><i>w</i></b><sub>1</sub><tt>&rfloor;</tt>,</nobr>
etc. for all positive values of the quotient, 
and all components thereafter are zero. 
The dimension <i>&nu;</i>(<b><i>i</i></b>) is then determined 
from the relation 
<nobr><i>&nu;</i>(<b><i>i</i></b>) = <i>l</i> + 1 &ndash; 
<b><i>w</i></b> <img src="APLimg/plustimes.bmp"> 
<b><i>z</i></b>(<b><i>i</i></b>).</nobr>
<br>&nbsp;</p>



<a name="ref1"></a>
<p><b>References</b></p>

<table>
<tr><td valign=top nowrap>&#149; &nbsp;</td><td>
Birkhoff, G., and S. MacLane (1941),
<i>A Survey of Modern Algebra</i>,
Macmillian, New York.
 </td></tr>
<tr><td valign=top>&#149; &nbsp;</td><td>
Burks, A.W., D.W. Warren, and J.B. Wright (1954),
&ldquo;An Analysis of a Logical Machine Using
Parenthesis-free Notation&rdquo;,
<i>Mathematical Tables and Other Aids to Computation</i>,
vol. VIII, pp. 53-57.
 </td></tr>
<tr><td valign=top>&#149; &nbsp;</td><td>
Dickson, L.E. (1939), <i>New First Course in the Theory of Equations</i>,
Wiley, New York.
 </td></tr>
<tr><td valign=top>&#149; &nbsp;</td><td>
Garner, Harvey L. (1959), &ldquo;The Residue Number System&rdquo;,
<i>IRE Transactions</i>, vol. EC-8, pp. 140-147.
 </td></tr>
<tr><td valign=top>&#149; &nbsp;</td><td>
Goldstine, H.H., and J. von Neumann (1947),
&ldquo;Planning and Coding of Problems for an Electronic
Computing Instrument&rdquo;, 
<i>Report on the Mathematical and Logical Aspects
of an Electronic Computing Instrument</i>, Part II, vol. 1,
Institute for Advanced Study, Princeton.
 </td></tr>
<tr><td valign=top>&#149; &nbsp;</td><td>
Iverson, K.E. (1954), 
<a target=_parent href="http://www.jsoftware.com/papers/MSLDE.htm">&ldquo;Machine 
Solutions of Linear Differential Equations&rdquo;</a>, Doctoral Thesis, Harvard University.
 </td></tr>
<tr><td valign=top>&#149; &nbsp;</td><td>
Jacobson, N. (1951), <i>Lectures in Abstract Algebra</i>,
vol. 1, Van Nostrand, New York.
 </td></tr>
<tr><td valign=top>&#149; &nbsp;</td><td>
Kunz, K.S. (1957), <i>Numerical Analysis</i>,
McGraw-Hill, New York.
 </td></tr>
<tr><td valign=top>&#149; &nbsp;</td><td>
Margenau, H., and G.M. Murphy (1943), 
<i>The Mathematics of Physics and Chemistry</i>,
Van Nostrand, New York.
 </td></tr>
<tr><td valign=top>&#149; &nbsp;</td><td>
Phister, M. (1958), <i>Logical Design of Digital Computers</i>,
Wiley, New York.
 </td></tr>
<tr><td valign=top>&#149; &nbsp;</td><td>
Richards, R.K. (1955), <i>Arithmetic Operations in Digital Computers</i>,
Van Nostrand, New York.
 </td></tr>
<tr><td valign=top>&#149; &nbsp;</td><td>
Riordan, J. (1958), <i>An Introduction to Combinatorial Analysis</i>,
Wiley, New York.
 </td></tr>
<tr><td valign=top>&#149; &nbsp;</td><td>
Rutishauser, H. (1959), &ldquo;Zur Matrizeninversion 
nach Gauss-Jordan&rdquo;,
<i>Zeitschrift f&uuml;r Angewandte Mathematik und Physik</i>,
vol. X, pp. 281-291.
 </td></tr>
<tr><td valign=top>&#149; &nbsp;</td><td>
Wright, H.N. (1939), <i>First Course in Theory of Numbers</i>,
Wiley, New York.
 </td></tr>
</table>
<br>



<a name="notes1"></a>
<p><b>Notes</b></p>

<table>
<tr><td valign=top nowrap>a.<a name="note1a"></a> &nbsp;</td><td>
Restating the relation in terms 
of the 0-residue will illustrate the convenience
of the 1-residue used here.
 </td></tr>
<tr><td valign=top>b.<a name="note1b"></a> &nbsp;</td><td>
Since each &ldquo;vector&rdquo; 
<b><i>y</i></b><sub><i>i</i></sub>
<img src="APLimg/circledot.bmp"><sub>2</sub>
<b><i>x</i></b><sub><i>j</i></sub> 
is of dimension one, no scan operator
<img src="APLimg/circledot.bmp"><sub>1</sub>
is required, and the symbol <tt>∘</tt>
may be interpreted as a &ldquo;null&rdquo; scan.
 </td></tr>
<tr><td valign=top>c.<a name="note1c"></a> &nbsp;</td><td>
These transpositions generate
the rotation group of the square
[cf. <acronym title="Birkhoff, G., and S. MacLane (1941), 
A Survey of Modern Algebra, Macmillian, New York.">Birkhoff and MacLane (1941)</acronym>
Chap. VI].
A pair of transpositions commute if and only if
their axes are perpendicular.
Hence the pair &larr; and &uarr; may be written
unambiguously as <img src="APLimg/luarr.bmp">.
Moreover, <img src="APLimg/luarr.bmp"> = 
<img src="APLimg/xarr.bmp"> .
The remaining two transformations can be
denoted by <img src="APLimg/ltarr.bmp"> and
<img src="APLimg/gtarr.bmp"> ,
with the convention that the operator nearest
the operand (i.e., the horizontal)
is executed first.
 </td></tr>
<tr><td valign=top>d.<a name="note1d"></a> &nbsp;</td><td>
The symbols <tt>∪</tt> and <tt>∩</tt>
(and the operations they denote) are commonly
called <i>cup</i> and <i>cap</i>, respectively.
 </td></tr>
<tr><td valign=top>e.<a name="note1e"></a> &nbsp;</td><td>
For the purposes of describing algorithms,
this notation is superior to the classical
&ldquo;disjoint cycles&rdquo; notation for permutations
<acronym title="Birkhoff, G., and S. MacLane (1941), 
A Survey of Modern Algebra, Macmillian, New York.">
[cf. Birkhoff and MacLane, (1941)]</acronym>
because (1) the direction of the transformation
(from <b><i>a</i></b> to <b><i>c</i></b>)
is unequivocally indicated, and (2)
the notation directly indicates a straightforward
and efficient method for the actual execution,
namely, indirect addressing.
 </td></tr>
<tr><td valign=top>f.<a name="note1f"></a> &nbsp;</td><td>
If the function <i>f</i>
is many-to-one, the specification of a
unique inverse <i>g</i> is achieved
by restricting the range of <i>g</i>
to some set of &ldquo;principal&rdquo; values,
as is done, for example, 
for the inverse trigonometric functions.
 </td></tr>
<tr><td valign=top>g.<a name="note1g"></a> &nbsp;</td><td>
Further levels can,
of course, be handled by considering 
a family of matrices 
<sup>1</sup><b><i>M</i></b>,
<sup>2</sup><b><i>M</i></b>, &#133;,
<sup><i>n</i></sup><b><i>M</i></b>,
or families of families 
<sub><i>j</i></sub><sup><i>&nbsp;i</i></sup><b><i>M</i></b>.
 </td></tr>
<tr><td valign=top>h.<a name="note1h"></a> &nbsp;</td><td>
Although such a genealogical tree 
is not necessarily a tree in the mathematical sense, 
it will be assumed so for present purposes.
 </td></tr>
<tr><td valign=top>i.<a name="note1i"></a> &nbsp;</td><td>
In the 1-origin indexing system used here
it would be possible to use the numeric zero
to represent the null.
In 0-origin indexing, however, zeros occur
as components of index vectors 
and must be distinguishable
from the nulls used.
 </td></tr>
<tr><td valign=top>j.<a name="note1j"></a> &nbsp;</td><td>
The term <i>left list</i> and the notation [<b>T</b>
are both intended to suggest left justification.
 </td></tr>
<tr><td valign=top>k.<a name="note1k"></a> &nbsp;</td><td>
These statements hold only for 1-origin indexing.
In 0-origin indexing, <b><i>a</i></b> =
<nobr>(<tt>∘</tt>, 0, 1, &#133;, <i>&delta;</i>(<b>T</b>) &ndash; 1).</nobr>
 </td></tr>
</table>
<br>



<a name="ex1"></a>
<p><b>Exercises</b></p>

<p>Organize each of the programs according to the method
of leading decisions.
Except where otherwise indicated,
use 1-origin indexing.
The conventions of Sec. S.1
of the Summary of Notation will be used
in the statement of each of the exercises.</p>


<p><b>1.1&nbsp;</b> Let 
<nobr><b><i>d</i></b> = (a, 2, 3, 4, 5, 6, 7, 8, 9, 10, j, q, k),</nobr>
<nobr><b><i>s</i></b> = (c, d, h, s),</nobr>
<nobr><b><i>u</i></b> = (1, 0, 1, 0, 1),</nobr>
<nobr><b><i>v</i></b> = (0, 1, 1, 1, 0),</nobr>
<nobr><b><i>x</i></b> = (16, 8, 4, 2, 1),</nobr> and
<nobr><b><i>y</i></b> = (2, 3, 4, 5, 6).</nobr> 
Determine

<table>
<tr><td valign=top>(a)</td><td>&nbsp;</td><td>
the dimensions <i>&nu;</i>(<b><i>d</i></b>), <i>&nu;</i>(<b><i>s</i></b>),
and <i>&nu;</i>(<b><i>x</i></b>).
</td></tr>
<tr><td valign=top>(b)</td><td>&nbsp;</td><td>
the vectors 
<b><i>x</i></b> + <b><i>y</i></b>,
<b><i>x</i></b> &ndash; <b><i>y</i></b>,
<b><i>x</i></b> &times; <b><i>y</i></b>,
<b><i>x</i></b> <tt>÷</tt> <b><i>y</i></b>, and
<b><i>u</i></b> + <b><i>v</i></b>.
</td></tr>
<tr><td valign=top>(c)</td><td>&nbsp;</td><td>
the logical vectors
<b><i>u</i></b> &and; <b><i>v</i></b>,
<b><i>u</i></b> &or; <b><i>v</i></b>,
(<b><i>u</i></b> &ne; <b><i>v</i></b>), and
(<b><i>u</i></b> = <b><i>v</i></b>).
</td></tr>
<tr><td valign=top>(d)</td><td>&nbsp;</td><td>
the reductions
+/<b><i>x</i></b>,
&times;/<b><i>y</i></b>,
&and;/<b><i>u</i></b>, and
&or;/<b><i>v</i></b>.
</td></tr>
<tr><td valign=top>(e)</td><td>&nbsp;</td><td>
the base two values of <b><i>u</i></b>
and of <b><i>v</i></b>, that is,
+/(<b><i>x</i></b> &times; <b><i>u</i></b>), and
+/(<b><i>x</i></b> &times; <b><i>v</i></b>).
</td></tr>
<tr><td valign=top>(f)</td><td>&nbsp;</td><td>
the rotated vectors 
2 &darr; <b><i>d</i></b>,
4 &uarr; <b><i>s</i></b>, and
&uarr; <b><i>y</i></b>.
</td></tr>
<tr><td valign=top>(g)<sup> </sup></td><td>&nbsp;</td><td>
the unit vectors
<tt><b>∊</b></tt><sup>1</sup>(5) in a 1-origin system, and
<tt><b>∊</b></tt><sup>2</sup>(5) in a 0-origin system.
</td></tr>
<tr><td valign=top>(f)<sup> </sup></td><td>&nbsp;</td><td>
the infixes
(<tt><b>⍺</b></tt><sup>5</sup>(7) &and; <tt><b>⍵</b></tt><sup>5</sup>(7)) and
2 <tt>↓</tt> <tt><b>⍺</b></tt><sup>3</sup>(7).
</td></tr>
</table>
</p>


<p><b>1.2&nbsp;</b> Show that
<table>
<tr><td valign=top>(a)<sup> </sup></td><td>&nbsp;</td><td>
&times;/<b>⍳</b></tt><sup>1</sup>(<i>n</i>) = <i>n</i>! 
(Include the case <i>n</i> = 0.)
</td></tr>
<tr><td valign=top>(b)<sup> </sup></td><td>&nbsp;</td><td>
<tt>+/<b>⍳</b></tt><sup> <i>j</i></sup>(<i>n</i>) = <i>n</i>(<i>n</i> + 2<i>j</i> &ndash; 1) <tt>÷</tt> 2.
</td></tr>
<tr><td valign=top>(c)</td><td>&nbsp;</td><td>
&times;/(<i>k</i> <tt>↑</tt> <b><i>x</i></b>) = &times;/<b><i>x</i></b>. 
</td></tr>
<tr><td valign=top>(d)</td><td>&nbsp;</td><td>
(<i>k</i> &uarr; <b><i>x</i></b>) +
(<i>k</i> &uarr; <b><i>y</i></b>) = 
<i>k</i> &uarr; (<b><i>x</i></b> + <b><i>y</i></b>).
</td></tr>
</table>
</p>


<p><b>1.3&nbsp;</b> Write detailed (i.e., component-by-component)
programs for the following operations.
Include tests for compatibility of the operands.

<table><tr><td><table>
<tr><td>(a)</td><td>&nbsp;</td><td><b><i>w</i></b> &larr; <b><i>u</i></b> &and; <b><i>v</i></b>.</td></tr>
<tr><td>(b)</td><td>&nbsp;</td><td><b><i>W</i></b> &larr; <b><i>U</i></b> &or; <b><i>V</i></b>.</td></tr>
<tr><td>(c)</td><td>&nbsp;</td><td><b><i>b</i></b> &larr; <b><i>u</i></b>/<b><i>a</i></b>.</td></tr>
<tr><td>(d)</td><td>&nbsp;</td><td><b><i>B</i></b> &larr; <b><i>u</i></b>/<b><i>A</i></b>.</td></tr>
<tr><td>(e)</td><td>&nbsp;</td><td><b><i>B</i></b> &larr; <b><i>u</i></b>/<b><i>v</i></b>//<b><i>A</i></b>.</td></tr>
<tr><td>(f)</td><td>&nbsp;</td><td><b><i>x</i></b> &larr; (<b><i>x</i></b> &gt; 0)/<b><i>x</i></b>.</td></tr>
</table></td><td>&nbsp; &nbsp; &nbsp; &nbsp;</td><td valign=top><table>
<tr><td>(g)</td><td>&nbsp;</td><td><b><i>u</i></b> &larr; <tt><b>⍺</b></tt><sup><i>&nbsp;j</i></sup>(<i>k</i>).</td></tr>
<tr><td>(h)</td><td>&nbsp;</td><td><b><i>u</i></b> &larr; <i>i</i> <tt>↓</tt> <tt><b>⍺</b></tt><sup><i>&nbsp;j</i></sup>(<i>k</i>).</td></tr>
<tr><td>(i)</td><td>&nbsp;</td><td><b><i>c</i></b> &larr; \<b><i>a</i></b>, <b><i>u</i></b>, <b><i>b</i></b>\.</td></tr>
<tr><td>(j)</td><td>&nbsp;</td><td><b><i>c</i></b> &larr; /<b><i>a</i></b>, <b><i>u</i></b>, <b><i>b</i></b>/.</td></tr>
<tr><td>(k)</td><td>&nbsp;</td><td><b><i>c</i></b> &larr; <b><i>u</i></b>\<b><i>a</i></b>.</td></tr>
</table></td></tr></table>
</p>


<p><b>1.4&nbsp;</b> Established the identities
<table>
<tr><td>(a)</td><td>&nbsp;</td><td>/<b><i>a</i></b>, <b><i>u</i></b>, <b><i>b</i></b>/ 
= \<img src="APLimg/uboscore.bmp">/<b><i>a</i></b>, <b><i>u</i></b>, <b><i>u</i></b>/<b><i>b</i></b>\.</td></tr>
<tr><td>(b)</td><td>&nbsp;</td><td>\<b><i>a</i></b>, <b><i>u</i></b>, <b><i>b</i></b>\ 
= /<img src="APLimg/uboscore.bmp">\<b><i>a</i></b>, <b><i>u</i></b>, <b><i>u</i></b>\<b><i>b</i></b>/.</td></tr>
</table>
</p>


<p><b>1.5&nbsp;</b> The classic &ldquo;rings-<i>o</i>-seven&rdquo;
puzzle can be posed as follows:
an order collection of <i>n</i> rings is to be placed on
(removed from) a bar
under the following constraints:

<table>
<tr><td valign=top>(i)</td> <td>&nbsp;</td><td>
ring <i>n</i> may be placed on or removed at will.
 </td></tr>
<tr><td valign=top>(ii)</td><td>&nbsp;</td><td>
ring <i>k</i> may be placed on or removed
only if ring (<i>k</i> + 1) is on
and all succeeding rings are off.
 </td></tr>
</table>

The state of the rings can be described 
by a logical vector <b><i>u</i></b>,
with <b><i>u</i></b><sub><i>k</i></sub> = 1 
if ring <i>k</i> is on.
Write programs on <b><i>u</i></b>
which describe the removal of the rings
beginning with

<table>
<tr><td valign=top>(a)</td> <td>&nbsp;</td><td>
<b><i>u</i></b> = <tt><b>∊</b></tt>
[The successive values of <b><i>u</i></b> represent
a <i>reflected Gray code</i>; see
<acronym title="Phister, M. (1958), 
Logical Design of Digital Computers, 
Wiley, New York.">Phister (1958)</acronym>.]
 </td></tr>
<tr><td valign=top>(b)</td> <td>&nbsp;</td><td>
<b><i>u</i></b> arbitrary.
 </td></tr>
</table>
</p>


<p><b>1.6&nbsp;</b> The ordered array of variables
used to represent a variable <i>x</i>
in some coding system may be considered
as a <i>vector representation</i> of <i>x</i>,
denoted by <tt><b>⍴</b></tt>(<i>x</i>).
In the 8421 code for decimal digits,
for example, 
<tt><b>⍴</b></tt>(0) = (0,&nbsp;0,&nbsp;0,&nbsp;0),
<tt><b>⍴</b></tt>(1) = (0,&nbsp;0,&nbsp;0,&nbsp;1), and,
in general, <tt><b>⍴</b></tt>(<i>x</i>)
is defined by the relation 
+/[<b><i>w</i></b> &times; <tt><b>⍴</b></tt>(<i>x</i>)] = <i>x</i>,
where <b><i>w</i></b> = (8,&nbsp;4,&nbsp;2,&nbsp;1).
For each of the following coding systems, (see
<acronym title="Richards, R.K. (1955), 
Arithmetic Operations in Digital Computers, 
Van Nostrand, New York.">Richards</acronym>,
pp. 183-184 for definitions),
write a concise expression for <tt><b>⍴</b></tt>(<i>x</i>):

<table>
<tr><td valign=top>(a)</td><td>&nbsp;</td><td>
the excess-three code for decimal digits.
</td></tr>
<tr><td valign=top>(b)</td><td>&nbsp;</td><td>
any chosen two-out-of-five code.
</td></tr>
<tr><td valign=top>(c)</td><td>&nbsp;</td><td>
any chosen biquinary code.
</td></tr>
<tr><td valign=top>(d)</td><td>&nbsp;</td><td>
the semaphore code for the alphabet
(see any good dictionary).
Denote each code by a two-component vector
<tt><b>⍴</b></tt>(<i>x</i>) <tt>⊆</tt> <tt><b>⍳</b></tt><sup>0</sup>(8).
Use <b><i>a</i></b><tt>⍳</tt><i>x</i>,
where <b><i>a</i></b> = (a,&nbsp;b,&nbsp;c,&nbsp;&#133;,&nbsp;z).
</td></tr>
</table>
</p>


<p><b>1.7&nbsp;</b> Let <b><i>X</i></b> be a square sparse matrix
represented by the logical matrix <b><i>U</i></b> = (<b><i>X</i></b>&nbsp;&ne;&nbsp;0)
and either or both the vectors 
<b><i>r</i></b> = <b><i>U</i></b>/<b><i>X</i></b>, and 
<b><i>c</i></b> = <b><i>U</i></b>//<b><i>X</i></b>.
Write programs to determine the product
<b><i>Y</i></b> = <b><i>X</i></b> <img src="APLimg/plustimes.bmp"> <b><i>X</i></b>,
using the arguments

<table>
<tr><td valign=top>(a)</td><td>&nbsp;</td><td><b><i>r</i></b>, <b><i>c</i></b>, and <b><i>U</i></b>.</td></tr>
<tr><td valign=top>(b)</td><td>&nbsp;</td><td><b><i>r</i></b> and <b><i>U</i></b>.</td></tr>
<tr><td valign=top>(c)</td><td>&nbsp;</td><td><b><i>c</i></b> and <b><i>U</i></b>.</td></tr>
</table>
</p>


<p><b>1.8&nbsp;</b> Prove that
<table>
<tr><td valign=top>(a)</td><td>&nbsp;</td><td>
<tt>⌈</tt><i>x</i><tt>&rceil;</tt> = 
&ndash;<tt>⌊</tt>&ndash;<i>x</i><tt>&rfloor;</tt>
</td></tr>
<tr><td valign=top>(b)</td><td>&nbsp;</td><td>
<tt>⌊</tt><tt>⌊</tt> <i>a</i> <tt>÷</tt> <i>b</i><tt>&rfloor;</tt> <tt>÷</tt> <i>c</i><tt>&rfloor;</tt> =
<tt>⌊</tt> <i>a</i> <tt>÷</tt> <i>bc</i><tt>&rfloor;</tt>
for all positive integers <i>a</i>, <i>b</i>, and <i>c</i>.
</td></tr>
</table>
</p>


<p><b>1.9&nbsp;</b> Let 
<b><i>r</i></b> = <font face=Arial><b><i>E</i></b></font>/<b><i>A</i></b>, and
<b><i>c</i></b> = <font face=Arial><b><i>E</i></b></font>//<b><i>A</i></b>
be the row list and column list, respectively, 
of the matrix <b><i>A</i></b>,
and let <b><i>r</i></b><sub><i>&nbsp;h</i></sub>,
<b><i>A</i></b><sub><i>j</i></sub><sup><i>i</i></sup>,
and <b><i>c</i></b><sub><i>k</i></sub>
be the corresponding elements
of the three representations of <b><i>A</i></b>.
Determine:
<table>
<tr><td valign=top>(a)</td><td>&nbsp;</td><td>
<i>h</i> as a function of <i>k</i>, <i>&nu;</i>(<b><i>A</i></b>),
and <i>&mu;</i>(<b><i>A</i></b>).
</td></tr>
<tr><td valign=top>(b)</td><td>&nbsp;</td><td>
<i>k</i> as a function of <i>h</i>, <i>&nu;</i>(<b><i>A</i></b>),
and <i>&mu;</i>(<b><i>A</i></b>).
</td></tr>
<tr><td valign=top>(c)</td><td>&nbsp;</td><td>
the permutation vector <b><i>h</i></b> such that
<b><i>c</i></b> = <b><i>h</i></b> &int; <b><i>r</i></b>.
</td></tr>
</table>
</p>


<p><b>1.10&nbsp;</b> Show that
<table>
<tr><td valign=top>(a)</td><td>&nbsp;</td><td>
&and;/<b><i>u</i></b> = <img src="APLimg/ex1x10a.bmp">
(Use De Morgan&rsquo;s law for two variables and induction.)
</td></tr>
<tr><td valign=top>(b)</td><td>&nbsp;</td><td>
&ne;/<b><i>u</i></b> = 2|<sub>0</sub> +/<b><i>u</i></b> (Use induction.)
</td></tr>
<tr><td valign=top>(c)</td><td>&nbsp;</td><td>
=/<b><i>u</i></b> = <img align=top src="APLimg/ex1x10c.bmp">.
</td></tr>
<tr><td valign=top>(d)</td><td>&nbsp;</td><td>
&ne;/<b><i>u</i></b> = <img align=top src="APLimg/ex1x10d.bmp">.
</td></tr>
<tr><td valign=top>(e)</td><td>&nbsp;</td><td>
<b><i>U</i></b> <img src="APLimg/neand.bmp"> <b><i>v</i></b> =
(2<tt><b>∊</b></tt>) |<sub>0</sub>
(<b><i>U</i></b> <img src="APLimg/plustimes.bmp"> <b><i>v</i></b>).
</td></tr>
<tr><td valign=top>(f)</td><td>&nbsp;</td><td>
<b><i>U</i></b> <img src="APLimg/neand.bmp"> <b><i>V</i></b> =
<img align=bottom src="APLimg/ex1x10f.bmp">.
</td></tr>
<tr><td valign=top>(g)</td><td>&nbsp;</td><td>
(<b><i>t</i></b> <img src="APLimg/jotand.bmp"> <b><i>u</i></b>) &and; 
(<b><i>v</i></b> <img src="APLimg/jotand.bmp"> <b><i>w</i></b>) = 
(<b><i>t</i></b> <img src="APLimg/jotand.bmp"> <b><i>w</i></b>) &and; 
(<b><i>v</i></b> <img src="APLimg/jotand.bmp"> <b><i>u</i></b>).
</td></tr>
</table>
</p>


<p><b>1.11&nbsp;</b>
<table>
<tr><td valign=top>(a)</td><td>&nbsp;</td><td>
Show that +/<b><i>x</i></b> = 
+/(<img src="APLimg/uboscore.bmp">/<b><i>x</i></b>)
+(<b><i>u</i></b>/<b><i>x</i></b>).
(Include the case <b><i>u</i></b> = 0.)
</td></tr>
<tr><td valign=top>(b)</td><td>&nbsp;</td><td>
What properties are required of an operator
<img src="APLimg/circledot.bmp"> 
that it satisfy the relation
established for + in part (a)?
</td></tr>
</table>
</p>


<p><b>1.12&nbsp;</b> Show that
<table>
<tr><td valign=top>(a)</td><td>&nbsp;</td><td>
<b><i>X</i></b> <img src="APLimg/plustimes.bmp"> <b><i>Y</i></b> =
(<img src="APLimg/uboscore.bmp">/<b><i>X</i></b>)
<img src="APLimg/plustimes.bmp">
(<img src="APLimg/uboscore.bmp">//<b><i>Y</i></b>) +
(<b><i>u</i></b>/<b><i>X</i></b>)
<img src="APLimg/plustimes.bmp">
(<b><i>u</i></b>//<b><i>Y</i></b>).
</td></tr>
<tr><td valign=top>(b)</td><td>&nbsp;</td><td>
<b><i>u</i></b>/(<b><i>X</i></b> <img src="APLimg/plustimes.bmp"> <b><i>Y</i></b>)
= <b><i>X</i></b> <img src="APLimg/plustimes.bmp">
(<b><i>u</i></b>/<b><i>Y</i></b>).
</td></tr>
<tr><td valign=top>(c)</td><td>&nbsp;</td><td>
<b><i>u</i></b>//(<b><i>X</i></b> <img src="APLimg/plustimes.bmp"> <b><i>Y</i></b>)
= (<b><i>u</i></b>//<b><i>X</i></b>) 
<img src="APLimg/plustimes.bmp"> <b><i>Y</i></b>.
</td></tr>
<tr><td valign=top>(d)</td><td>&nbsp;</td><td>
(<b><i>u</i></b> &and; <b><i>v</i></b>)/<b><i>a</i></b>
= (<b><i>u</i></b>/<b><i>v</i></b>)/(<b><i>u</i></b>/<b><i>a</i></b>).
</td></tr>
</table>
</p>


<p><b>1.13&nbsp;</b> Use the result of Exercise 1.11 (b)
to extend the results of Exercise 1.12 (a-c)
to logical operators.
</p>


<p><b>1.14&nbsp;</b> Write programs to determine:
<table>
<tr><td valign=top>(a)</td><td>&nbsp;</td><td>
the value of the polynomial <b><i>x</i></b> at the point <i>a</i>,
that is, to evaluate 
(<i>y</i><tt><tt><b>∊</b></tt></tt>) <tt>⊥</tt> <b><i>x</i></b>
for <i>y</i> = <i>a</i>. 
Use no more than <i>&nu;</i>(<b><i>x</i></b>) multiplications.
</td></tr>
<tr><td valign=top>(b)</td><td>&nbsp;</td><td>
the derivative of the polynomial <b><i>x</i></b>,
that is, the vector <b><i>z</i></b> such that<br>
&nbsp; &nbsp; &nbsp; (<i>y</i><tt><tt><b>∊</b></tt></tt>) <tt>⊥</tt> <b><i>z</i></b> =
<img align=top src="APLimg/ddy.bmp">
((<i>y</i><tt><tt><b>∊</b></tt></tt>) <tt>⊥</tt> <b><i>x</i></b>),
and <i>&nu;</i>(<b><i>z</i></b>) = <i>&nu;</i>(<b><i>x</i></b>).
</td></tr>
<tr><td valign=top>(c)</td><td>&nbsp;</td><td>
the integral <b><i>z</i></b> of the polynomial <b><i>x</i></b>
satisfying the boundary condition<br>
&nbsp; &nbsp; &nbsp; (<i>a</i><tt><tt><b>∊</b></tt></tt>) <tt>⊥</tt> <b><i>z</i></b> = <i>b</i>.
</td></tr>
<tr><td valign=top>(d)</td><td>&nbsp;</td><td>
the quotient <b><i>q</i></b> and remainder <b><i>r</i></b> 
obtained in dividing the polynomial <b><i>n</i></b>
by the polynomial <b><i>d</i></b>,
for <i>&nu;</i>(<b><i>d</i></b>) &le; <i>&nu;</i>(<b><i>n</i></b>).
</td></tr>
<tr><td valign=top>(e)</td><td>&nbsp;</td><td>
the value of the polynomial <b><i>n</i></b>
at the point <i>a</i> by using part (d)
with <b><i>d</i></b> = (1, &ndash;<i>a</i>).
</td></tr>
<tr><td valign=top>(f)</td><td>&nbsp;</td><td>
the value of <img align=top src="APLimg/ddy.bmp">
((<i>y</i><tt><tt><b>∊</b></tt></tt>) <tt>⊥</tt> <b><i>n</i></b>)
at the point <i>a</i> by two applications of part (e).
</td></tr>
<tr><td valign=top>(g)</td><td>&nbsp;</td><td>
an approximate real root of the equation
(<i>y</i><tt><tt><b>∊</b></tt></tt>) <tt>⊥</tt> <b><i>x</i></b> = 0
using parts (e) and (f) and the
Newton-Raphson formula
<acronym title="Kunz, K.S. (1957),
Numerical Analysis, McGraw-Hill, New York.">[Kunz (1957)]</acronym>.
</td></tr>
</table>
</p>


<p><b>1.15&nbsp;</b> Let the components of the vector <b><i>r</i></b>
be the real roots of a polynomial <b><i>x</i></b>.
Write a program to
<table>
<tr><td valign=top>(a)</td><td>&nbsp;</td><td>
determine the symmetric functions of <b><i>r</i></b>.
[<acronym title="Dickson, L.E. (1939),
New First Course in the Theory of Equations,
Wiley, New York.">Dickson (1939)</acronym>, Ch. X.]
</td></tr>
<tr><td valign=top>(b)</td><td>&nbsp;</td><td>
determine <b><i>x</i></b> as a function of <b><i>r</i></b>.
</td></tr>
</table>
</p>


<p><b>1.16&nbsp;</b> Write a program 
to determine the polynomial <i>x</i>
consisting of the first <i>n</i> terms
of the exponential series
1 + <i>y</i> + <i>y</i>&sup2;/2!
+  &#133; .
</p>


<p><b>1.17&nbsp;</b> Write a program to determine
the moduli of all roots of the polynomial <i>x</i>,
using the Graeffe method 
<acronym title="Kunz, K.S. (1957), Numerical Analysis,
McGraw-Hill, New York.">[Kunz (1957)]</acronym>.
Assume that operations for the logarithm
and exponential functions 
are available as subroutines.
</p>


<p><b>1.18&nbsp;</b> List all the 1-origin permutation vectors
of dimension four which are self-inverse.
</p>


<p><b>1.19&nbsp;</b> Using 1-origin indexing, 
write programs to derive
<table>
<tr><td valign=top>(a)</td><td>&nbsp;</td><td>
the permutation <b><i>k</i></b> which is inverse
to the permutation <b><i>j</i></b>.
</td></tr>
<tr><td valign=top>(b)</td><td>&nbsp;</td><td>
a permutation <b><i>j</i></b> which transforms
a given logical vector <b><i>u</i></b> to a prefix vector.
</td></tr>
</table>
</p>


<p><b>1.20&nbsp;</b> A square logical matrix <b><i>U</i></b>
such that +/<b><i>U</i></b> =
+//<b><i>U</i></b> = <tt><b>∊</b></tt>
is sometimes called a <i>permutation matrix</i>,
since premultiplication of a numerical vector
<b><i>x</i></b> determines a permutation 
of <b><i>x</i></b>.
Write programs to determine
<table>
<tr><td valign=top>(a)</td><td>&nbsp;</td><td>
the permutation matrix <b><i>U</i></b> corresponding
to the 1-origin permutation vector <b><i>k</i></b>,
that is, determine <b><i>U</i></b> such that
<b><i>U</i></b> <img src="APLimg/plustimes.bmp"> <b><i>x</i></b> = 
<b><i>k</i></b> &int;<sub>1</sub> <b><i>x</i></b>.
</td></tr>
<tr><td valign=top>(b)</td><td>&nbsp;</td><td>
the permutation <b><i>k</i></b> corresponding
to a given permutation matrix <b><i>U</i></b>.
</td></tr>
<tr><td valign=top>(c)</td><td>&nbsp;</td><td>
the permutation <b><i>V</i></b> which is inverse
to the permutation <b><i>U</i></b>.
</td></tr>
</table>
</p>


<p><b>1.21&nbsp;</b> Let <b><i>p</i></b> be the vector representation
of a permutation and let <b><i>c</i></b> be the standard representation
in terms of disjoint cycles, including all cycles of one
[<acronym title="Jacobson, N. (1951), 
Lectures in Abstract Algebra, 
vol. 1, Van Nostrand, New York.">Jacobson (1951)</acronym>, p. 34].
Each cycle of <b><i>c</i></b> is enclosed in square brackets,
each half-bracket being considered as a component of <b><i>c</i></b>.
For example, <b><i>c</i></b> = 
<nobr>([, 1, 3, 5, ], [, 2, 4, ], [, 6, ]),</nobr>
then <b><i>p</i></b> = <nobr>(3, 4, 5, 2, 1, 6),</nobr>
<i>&nu;</i>(<b><i>p</i></b>) = 6, and, in general,
<i>&nu;</i>(<b><i>c</i></b>) = <i>&nu;</i>(<b><i>p</i></b>) + 2<i>k</i> 
where <i>k</i> is the number of disjoint cycles
in <b><i>p</i></b>.
The usual elision of cycles of one would give
<b><i>c</i></b> = <nobr>([, 1, 3, 5, ], [, 2, 4, ]),</nobr>
but this determines a unique correspondent <b><i>p</i></b>
only if the dimension of <b><i>p</i></b> is otherwise specified,
and inclusion of all cycles of one will therefore be assumed.
If each infix of numerical components in <b><i>c</i></b>
is preceded by a left bracket and followed
by a right bracket, and if <b><i>c</i></b> determines
a legitimate permutation vector <b><i>p</i></b>,
then <b><i>c</i></b> is said to be <i>well formed</i>.

<table>
<tr><td valign=top>(a)</td><td>&nbsp;</td><td>
Write a program to determine <b><i>p</i></b>
as a function of a well formed permutation <b><i>c</i></b>.
Include determination of the dimension of <b><i>p</i></b>.
 </td></tr>
<tr><td valign=top>(b)</td><td>&nbsp;</td><td>
Modify the program in part (a) to incorporate checks
on the well formation of <b><i>c</i></b>.
If <b><i>c</i></b> is ill formed, 
the vector <b><i>p</i></b> is to be defined as
the literal &ldquo;ill formed&rdquo;.
 </td></tr>
<tr><td valign=top>(c)</td><td>&nbsp;</td><td>
Modify part (b) to process a sequence of vectors
<b><i>c</i></b><sup>1</sup>, <b><i>c</i></b><sup>2</sup>, &#133;,
each pair being separated by a single null element,
and the end of the sequence being indicated by a pair
of successive null elements, i.e., to process
<b><i>z</i></b> = <b><i>c</i></b><sup>1</sup>
<img src="APLimg/circleplus.bmp"> (<tt>∘</tt>) 
<img src="APLimg/circleplus.bmp"> <b><i>c</i></b><sup>2</sup>
<img src="APLimg/circleplus.bmp"> &#133; <img src="APLimg/circleplus.bmp"> 
<b><i>c</i></b><sup><i>&nbsp;r</i></sup> <img src="APLimg/circleplus.bmp">
(<tt>∘</tt>,<tt>∘</tt>).
Include checks on the well formation
of each permutation.
 </td></tr>
<tr><td valign=top>(d)</td><td>&nbsp;</td><td>
Write a program to determine the parity
[<acronym title="Jacobson, N. (1951), 
Lectures in Abstract Algebra, 
vol. 1, Van Nostrand, New York.">Jacobson (1951)</acronym>, p. 36]
of a permutation vector <b><i>p</i></b>.
 </td></tr>
</table>
</p>


<p><b>1.22&nbsp;</b> Write detailed programs for the following processes:
<table>
<tr><td valign=top><table>
<tr><td valign=top>(a)</td><td>&nbsp;</td><td>
<b><i>k</i></b> &larr; &theta;<sub>1</sub>/<b><i>x</i></b>
 </td></tr>
<tr><td valign=top>(b)</td><td>&nbsp;</td><td>
<b><i>y</i></b> &larr; <b><i>m</i></b> &int;<sub>1</sub> <b><i>x</i></b>
 </td></tr>
<tr><td valign=top>(c)</td><td>&nbsp;</td><td>
<b><i>v</i></b> &larr; <b><i>u</i></b> <tt>⌈</tt> <b><i>x</i></b>
 </td></tr>
<tr><td valign=top>(d)</td><td>&nbsp;</td><td>
<b><i>V</i></b> &larr; <b><i>u</i></b> <img src="APLimg/jotmax.bmp"> <b><i>X</i></b>
 </td></tr>
<tr><td valign=top>(e)</td><td>&nbsp;</td><td>
<b><i>v</i></b> &larr; <tt>⍺</tt>/<b><i>u</i></b>
 </td></tr>
<tr><td valign=top>(f)</td><td>&nbsp;</td><td>
<b><i>V</i></b> &larr; <tt>⍵</tt>//<b><i>U</i></b>
 </td></tr>
<tr><td valign=top>(g)</td><td>&nbsp;</td><td>
<b><i>v</i></b> &larr; <i>&sigma;</i>/<b><i>b</i></b>
 </td></tr>
<tr><td valign=top>(h)</td><td>&nbsp;</td><td>
<b><i>V</i></b> &larr; <i>&tau;</i>//<b><i>B</i></b>
 </td></tr>
</table></td><td>&nbsp; &nbsp; &nbsp; &nbsp;</td><td valign=top><table>
<tr><td valign=top>(i)</td><td>&nbsp;</td><td>
<b><i>m</i></b> &larr; <b><i>b</i></b> <tt>⍳</tt><sub>0</sub> <b><i>a</i></b>
 </td></tr>
<tr><td valign=top>(j)</td><td>&nbsp;</td><td>
<b><i>M</i></b> &larr; <b><i>B</i></b> <img src="APLimg/jotiota.bmp"><sub>0</sub> <b><i>a</i></b>
 </td></tr>
<tr><td valign=top>(k)<sup>&nbsp;</sup></td><td>&nbsp;</td><td>
<b><i>u</i></b> &larr; <tt><b>∊</b></tt><sub><b><i>b</i></b></sub><sup><b><i>a</i></b></sup>
 </td></tr>
<tr><td valign=top>(l)</td><td>&nbsp;</td><td>
<b><i>c</i></b> &larr; <b><i>b</i></b> <tt>∩</tt> <b><i>a</i></b>
 </td></tr>
<tr><td valign=top>(m)</td><td>&nbsp;</td><td>
<b><i>c</i></b> &larr; <b><i>b</i></b> <tt>∆</tt> <b><i>a</i></b>
 </td></tr>
<tr><td valign=top>(n)</td><td>&nbsp;</td><td>
<b><i>c</i></b> &larr; <b><i>b</i></b> <tt>∪</tt> <b><i>a</i></b>
 </td></tr>
<tr><td valign=top>(o)</td><td>&nbsp;</td><td>
<b><i>C</i></b> &larr; <b><i>b</i></b> <img src="APLimg/circletimes.bmp"> <b><i>a</i></b>
 </td></tr></table></td></tr>
</table>
</p>


<p><b>1.23&nbsp;</b>
<table>
<tr><td valign=top>(a)</td><td>&nbsp;</td><td>
Copy onto file &Phi;<sub>1</sub><sup>2</sup> successive groups
of items from the row of files &Phi;<sup><tt>⍳</tt></sup>
in cyclic order, omitting any exhausted files.
The end of each group is demarked by a partition &lambda;<sub>2</sub>,
and the end of each file by a partition &lambda;<sub>3</sub>.
 </td></tr>
<tr><td valign=top>(b)</td><td>&nbsp;</td><td>
A file which is always recorded in the forward direction
and read in the backward direction functions as a <i>stack</i>.
Using file &Phi;<sub>2</sub><sup>2</sup>
as a stack, modify the program of part (a)
so as to reverse (in the output file 
&Phi;<sub>1</sub><sup>2</sup>)
the order of the items within each group.
 </td></tr>
</table>
</p>


<p><b>1.24&nbsp;</b> The accompanying node vector 
<b><i>n</i></b> and connecting matrix <b><i>C</i></b> 
together specify a directed graph 
(<b><i>C</i></b><sub><i>&nbsp;j</i></sub><sup><i>&nbsp;i</i></sup>
= 1 indicates a branch from node <i>i</i> to node <i>j</i>)
which is, in fact, a tree.</p>

<p>&nbsp; &nbsp; &nbsp; <b><i>n</i></b> = (a, b, c, d, e, f, g)</p>

<table>
<tr><td rowspan=7>&nbsp; &nbsp; &nbsp; <b><i>C</i></b> =&nbsp;</td>
<td rowspan=7><img src="APLimg/matrixl7.bmp"></td>
<td><sup>&nbsp;</sup>0 &nbsp; 0 &nbsp; 0 &nbsp; 0 &nbsp; 1 &nbsp; 1 &nbsp; 0<sub>&nbsp;</sub></td>
<td rowspan=7><img src="APLimg/matrixr7.bmp"></td>
 </tr>
<tr><td><sup>&nbsp;</sup>0 &nbsp; 0 &nbsp; 0 &nbsp; 0 &nbsp; 0 &nbsp; 0 &nbsp; 0<sub>&nbsp;</sub></td></tr>
<tr><td><sup>&nbsp;</sup>1 &nbsp; 0 &nbsp; 0 &nbsp; 1 &nbsp; 0 &nbsp; 0 &nbsp; 0<sub>&nbsp;</sub></td></tr>
<tr><td><sup>&nbsp;</sup>0 &nbsp; 0 &nbsp; 0 &nbsp; 0 &nbsp; 0 &nbsp; 0 &nbsp; 0<sub>&nbsp;</sub></td></tr>
<tr><td><sup>&nbsp;</sup>0 &nbsp; 0 &nbsp; 0 &nbsp; 0 &nbsp; 0 &nbsp; 0 &nbsp; 0<sub>&nbsp;</sub></td></tr>
<tr><td><sup>&nbsp;</sup>0 &nbsp; 0 &nbsp; 0 &nbsp; 0 &nbsp; 0 &nbsp; 0 &nbsp; 0<sub>&nbsp;</sub></td></tr>
<tr><td><sup>&nbsp;</sup>0 &nbsp; 1 &nbsp; 0 &nbsp; 0 &nbsp; 0 &nbsp; 0 &nbsp; 0<sub>&nbsp;</sub></td></tr>
</table>

<table>
<tr><td valign=top>(a)</td><td>&nbsp;</td><td>
Draw one of the possible ordered trees represented 
by <b><i>n</i></b> and <b><i>C</i></b>.
</td></tr>
<tr><td valign=top>(b)</td><td>&nbsp;</td><td>
For the tree <b>T</b> of part (a) 
show the full left list [<b>T</b>.
</td></tr>
<tr><td valign=top>(c)</td><td>&nbsp;</td><td>
Show the full right list ]<b>T</b>.
</td></tr>
</table>


<p><b>1.25&nbsp;</b> Write programs which includes tests
on compatibility and which determine
<table>
<tr><td valign=top>(a)</td><td>&nbsp;</td><td>
<b><i>L</i></b> = [<b>T</b> from <b><i>R</i></b> = ]<b>T</b>
</td></tr>
<tr><td valign=top>(b)</td><td>&nbsp;</td><td>
<b><i>S</i></b> = ](<b><i>u</i></b>/<b>T</b>) 
from <b>&mu;</b>(<b>T</b>), ]<b>T</b>, and <b><i>u</i></b>
</td></tr>
<tr><td valign=top>(c)</td><td>&nbsp;</td><td>
<b><i>M</i></b> = [(<b><i>u</i></b>//<b>T</b>) 
from <b><i>L</i></b> = [<b>T</b> and <b><i>u</i></b>
</td></tr>
<tr><td valign=top>(d)</td><td>&nbsp;</td><td>
<b><i>M</i></b> = [(<b><i>k</i></b> &int;<sub>1</sub> <b>T</b>)
from <b><i>L</i></b> = [<b>T</b> and <b><i>k</i></b>
</td></tr>
</table>
</p>


<p><b>1.26&nbsp;</b>
<table>
<tr><td valign=top>(a)</td><td>&nbsp;</td><td>
Give an example of a well formed right list
which demonstrates that a <i>prefix</i>
of a right list is not, in general, well formed.
</td></tr>
<tr><td valign=top>(b)</td><td>&nbsp;</td><td>
Show clearly where the argument used 
in establishing the well formation
of any suffix of a well formed list
breaks down when applied to a prefix.
</td></tr>
</table>
</p>


<p><b>1.27&nbsp;</b> Give formal proofs 
for the facts that
<table>
<tr><td valign=top>(a)</td><td>&nbsp;</td><td>
a left list groups nodes by subtrees.
</td></tr>
<tr><td valign=top>(b)</td><td>&nbsp;</td><td>
a right list groups nodes by levels.
</td></tr>
<tr><td valign=top>(c)</td><td>&nbsp;</td><td>
<b>&mu;</b><sub>1</sub>(<b>T</b>) = <i>&nu;</i>(<b><i>d</i></b>) &ndash; +/<b><i>d</i></b>,
where <b><i>d</i></b> is the degree vector of <b>T</b>.
</td></tr>
</table>
</p>


<p><b>1.28&nbsp;</b> Write programs to determine
<b>&mu;</b>(<b>T</b>) as a function of
<table>
<tr><td valign=top>(a)</td><td>&nbsp;</td><td>
the left list degree vector of <b>T</b>.
</td></tr>
<tr><td valign=top>(b)</td><td>&nbsp;</td><td>
the right list degree vector of <b>T</b>.
</td></tr>
</table>
</p>


<p><b>1.29&nbsp;</b> Trace Programs 1.20 and 1.21
for the tree of Exercise 1.24.
</p>


<p><b>1.30&nbsp;</b> Show that for a homogeneous tree <b>H</b>,
<i>&mu;</i>(<b>H</b>) = <b><i>y</i></b> <tt>⊥</tt> <b><i>y</i></b>,
where <img align=top src="APLimg/yrarr.bmp"> = <b>&nu;</b>(<b>H</b>).
</p>


<p><b>1.31&nbsp;</b> If <b>H</b> is homogeneous,
<b>&nu;</b>(<b>H</b>) = (3,&nbsp;2,&nbsp;3,&nbsp;4),
and <b><i>i</i></b> = (1,&nbsp;0,&nbsp;2), determine,
in a 0-origin system
<table>
<tr><td valign=top>(a)</td><td>&nbsp;</td><td>
the left list index <i>l</i>(<b><i>i</i></b>).
</td></tr>
<tr><td valign=top>(b)</td><td>&nbsp;</td><td>
the right list index <i>r</i>(<b><i>i</i></b>).
</td></tr>
<tr><td valign=top>(c)</td><td>&nbsp;</td><td>
the index <b><i>j</i></b> of the node
whose left list index is 27.
</td></tr>
</table>
</p>


<p><b>1.32&nbsp;</b>
<table>
<tr><td valign=top>(a)<sup>&nbsp;</sup></td><td>&nbsp;</td><td>
If <b><i>K</i></b> = <tt><b>⍳</b></tt><sup>0</sup>(<i>n</i>)
&darr; (<tt><b>∊</b></tt>(<i>n</i>) <img src="APLimg/jottimes.bmp"> 
<tt><b>⍳</b></tt><sup>0</sup>(<i>n</i>)), 
show that <b><i>K</i></b> + 
<img src="APLimg/ktilde.bmp"> =
<i>n</i>(<font face=Arial><b><i>E</i></b> &ndash;
<b><i>I</i></b>).
</td></tr>
<tr><td valign=top>(b)</td><td>&nbsp;</td><td>
If <b><i>y</i></b> is any permutation of <b><i>x</i></b>
and <i>&nu;</i>(<b><i>x</i></b>) = <i>n</i>, show that
<b><i>x</i></b> <img src="APLimg/plustimes.bmp"> <b><i>K</i></b>
<img src="APLimg/plustimes.bmp"> <b><i>x</i></b> =
<b><i>y</i></b> <img src="APLimg/plustimes.bmp"> <b><i>K</i></b>
<img src="APLimg/plustimes.bmp"> <b><i>y</i></b>.
</td></tr>
</table>
</p>


<p><b>1.33&nbsp;</b> Using the Euclidean algorithm,
write programs to determine:
<table>
<tr><td valign=top>(a)</td><td>&nbsp;</td><td>
<i>d</i> as the greatest common divisor of positive integers
<i>x</i> and <i>y</i>.
</td></tr>
<tr><td valign=top>(b)</td><td>&nbsp;</td><td>
<b><i>d</i></b> as the g.c.d. of <b><i>x</i></b> and <b><i>y</i></b>,
where <b><i>d</i></b>, <b><i>x</i></b>, and <b><i>y</i></b>
represent polynomials in <i>z</i>
(e.g., ((<i>z</i><tt><b>∊</b></tt>) <tt>⊥</tt> <b><i>x</i></b>).
</td></tr>
</table>
</p>


<p><b>1.34&nbsp;</b> To assure uniqueness, 
the number of different digits (symbols) used
in a base <i>b</i> number system 
must not exceed <i>b</i>.
The limitation to the particular range
0 &le; <b><i>a</i></b><sub><i>&nbsp;i</i></sub> &lt; <i>b</i>
is, however, not essential.
For example, a base three system can be
constructed using digits &ndash;1, 0, and 1,
for which it is convenient to adopt the symbols
&ndash;, 0, and +, respectively.
The positive numbers beginning at zero
are then represented by the sequence 0,
+, +&nbsp;&ndash;, +0, +&nbsp;+, +&nbsp;&ndash;&nbsp;&ndash;,
+&nbsp;&ndash;0, +&nbsp;&ndash;&nbsp;+,
+&nbsp;0&nbsp;&ndash;, +00, etc.
The negative numbers beginning at 0 
are 0, &ndash;, &ndash;&nbsp;+,
&ndash;0, 
&ndash;&nbsp;&ndash;, &ndash;&nbsp;+&nbsp;+, 
&ndash;&nbsp;+0, &ndash;&nbsp;+&nbsp;&ndash;,
&ndash;0&nbsp;+, &ndash;00, etc.

<table>
<tr><td valign=top>(a)</td><td>&nbsp;</td><td>
Construct addition and multiplication tables
for this number system and calculate the sum
and the product of the numbers 0&nbsp;&ndash; and
&ndash;&nbsp;&ndash;.
Use the decimal system to check all results.
</td></tr>
<tr><td valign=top>(b)</td><td>&nbsp;</td><td>
Negative numbers are represented in this system
without the attachment of a special sign position.
Special rules regarding sing are therefore
banished except that it is necesssary
to formulate a rule for changing the sign
of a number, i.e. to multiply by minus one.
Formulate such a rule.
</td></tr>
</table>
</p>


<p><b>1.35&nbsp;</b> For any integer <i>n</i>, let 
<i>x</i><sub>2</sub> = 2 |<sub>0</sub> <i>n</i>,
<i>x</i><sub>3</sub> = 3 |<sub>0</sub> <i>n</i>,
<i>x</i><sub>5</sub> = 5 |<sub>0</sub> <i>n</i>, and
<i>x</i><sub>7</sub> = 7 |<sub>0</sub> <i>n</i>.
As shown by
<acronym title="Garner, Harvey L. (1959), “The Residue Number System”, 
IRE Transactions, vol. EC-8, pp. 140-147.">Garner (1959)</acronym>,
the ordered array 
(<i>x</i><sub>2</sub>,&nbsp;<i>x</i><sub>3</sub>,&nbsp;<i>x</i><sub>5</sub>,&nbsp;<i>x</i><sub>7</sub>)
provides a representation of the integer
<i>n</i> in a so-called <i>residue</i> number system.

<table>
<tr><td valign=top>(a)</td><td>&nbsp;</td><td>
Write the residue representations of the first ten
nonnegative integers.
</td></tr>
<tr><td valign=top>(b)</td><td>&nbsp;</td><td>
For integers <i>n</i> in the range 0 &le; <i>n</i> &lt;
(2 &times; 3 &times; 5 &times; 7) show:
<table>
<tr><td valign=top>(1)</td><td>&nbsp;</td><td>
that the representation is unique.
</td></tr>
<tr><td valign=top>(2)</td><td>&nbsp;</td><td>
that an addition algorithm may be defined 
which treats the several columns independently, 
i.e., there are no carries.
(The sums must also lie within the specified range.)
</td></tr>
</table>
</td></tr>
<tr><td valign=top>(c)</td><td>&nbsp;</td><td>
Discuss the choice of moduli for extending
the range of the representation.
</td></tr>
<tr><td valign=top>(d)</td><td>&nbsp;</td><td>
Show that the algorithm derived in part (b) is valid
for all positive and negative integers in the range
&ndash;<i>a</i>/2 &le; <i>n</i> &lt; <i>a</i>/2
for <i>a</i> = 2 &times; 3 &times; 5 &times; 7.
</td></tr>
<tr><td valign=top>(e)</td><td>&nbsp;</td><td>
Derive an algorithm for obtaining &ndash;<i>n</i>
from <i>n</i>.
</td></tr>
<tr><td valign=top>(f)</td><td>&nbsp;</td><td>
Derive an algorithm for multiplication.
</td></tr>
<tr><td valign=top>(g)</td><td>&nbsp;</td><td>
The sign of the number (i.e., its relation to zero)
is not displayed directly by this representation.
Convince yourself that its determination
is nontrivial.
</td></tr>
</table>
</p>


<p><b>1.36&nbsp;</b> Let <b><i>x</i></b>, <b><i>y</i></b>, and
<b><i>z</i></b> be the positional representations
of the numbers <i>x</i>, <i>y</i>, and <i>z</i> respectively.
Using the floor and residue operations,
write programs to determine <b><i>z</i></b> as 
a function of <b><i>x</i></b> and <b><i>y</i></b>,
where <i>z</i> = <i>x</i> + <i>y</i>
and the representation in use is
<table>
<tr><td valign=top>(a)</td><td>&nbsp;</td><td>
base <i>b</i>.
</td></tr>
<tr><td valign=top>(b)</td><td>&nbsp;</td><td>
mixed base <i>b</i>.
</td></tr>
<tr><td valign=top>(c)</td><td>&nbsp;</td><td>
the +, &ndash;, 0 base three system 
(of Exercise 1.34).
</td></tr>
<tr><td valign=top>(d)</td><td>&nbsp;</td><td>
the residue number system (of Exercise 1.35).
</td></tr>
</table>
</p>


<p><b>1.37&nbsp;</b> Write programs for the multiplication 
<i>z</i> = <i>x</i> &times; <i>y</i>
for each of the cases of Exercise 1.36.
</p>


<p><b>1.38&nbsp;</b> Write programs to convert
in each direction between the following pairs
of number systems:
<table>
<tr><td valign=top>(a)</td><td>&nbsp;</td><td>
base <i>b</i><sub>1</sub> and <i>b</i><sub>2</sub>.
</td></tr>
<tr><td valign=top>(b)<sup> </sup></td><td>&nbsp;</td><td>
base <b><i>b</i></b><sup>1</sup> and <b><i>b</i></b><sup>2</sup>.
</td></tr>
<tr><td valign=top>(c)</td><td>&nbsp;</td><td>
base three and the +, &ndash;, 0 
base three of Exercise 1.34. 
</td></tr>
<tr><td valign=top>(d)</td><td>&nbsp;</td><td>
residue and base <i>b</i> (Exercise 1.35).
</td></tr>
</table>
</p>


<p><b>1.39&nbsp;</b>
<table>
<tr><td valign=top>(a)<sup> </sup></td><td>&nbsp;</td><td>
Show that the superdiagonal matrices satisfy 
&nbsp;<sup><i>j</i></sup><font face=Arial><b><i>I</i></b></font> 
<img src="APLimg/plustimes.bmp">
<sup><i>k</i></sup><font face=Arial><b><i>I</i></b></font> =
<sup>(<i>j</i>+<i>k</i>)</sup><font face=Arial><b><i>I</i></b></font>.
</td></tr>
<tr><td valign=top>(b)<sup> </sup></td><td>&nbsp;</td><td>
A matrix of the form <b><i>J</i></b> =
(<i>x</i><font face=Arial><b><i>I</i></b></font> + 
<sup>1</sup><font face=Arial><b><i>I</i></b></font>) is called a <i>Jordan box</i>.
Write the expansion of the <i>n</i>th power 
of <b><i>J</i></b>.
</td></tr>
<tr><td valign=top>(c)<sup> </sup></td><td>&nbsp;</td><td>
Show that 
<b><i>X</i></b> <img src="APLimg/plustimes.bmp"> <b><i>Y</i></b> = 
<b><i>X</i></b><sub>1</sub> <img src="APLimg/jottimes.bmp"> <b><i>Y</i></b><sup>1</sup> +
<b><i>X</i></b><sub>2</sub> <img src="APLimg/jottimes.bmp"> <b><i>Y</i></b><sup>2</sup> +
&#133; +
<b><i>X</i></b><sub><i>&nu;</i>(<b><i>X</i></b>)</sub> <img src="APLimg/jottimes.bmp"> 
<b><i>Y</i></b><sup> <i>&nu;</i>(<b><i>X</i></b>)</sup>.
</td></tr>
<tr><td valign=top>(d)</td><td>&nbsp;</td><td>
Determine an explicit solution 
to the set of linear equations
<b><i>A</i></b> <img src="APLimg/plustimes.bmp"> <b><i>x</i></b> = <b><i>y</i></b>,
where <b><i>u</i></b>/<b><i>x</i></b> = <b><i>a</i></b>
and   <b><i>v</i></b>/<b><i>y</i></b> = <b><i>b</i></b>
are known and where +/<b><i>u</i></b> + +/<b><i>v</i></b>
= <i>&nu;</i>(<b><i>A</i></b>) = <i>&mu</i>(<b><i>A</i></b>).
State the conditions for the existence
of a unique solution.
</td></tr>
</table>
</p>


<p><b>1.40&nbsp;</b> Any nonsingular matrix <b><i>A</i></b>
can be reduced to the identity <font face=Arial><b><i>I</i></b></font>
by a sequence of <i>row operations</i> of the form
<b><i>A</i></b><sup><i>i</i></sup> &larr; 
<i>x</i><b><i>A</i></b><sup><i>i</i></sup> + 
<i>y</i><b><i>A</i></b><sup><i>i</i></sup>, or
<b><i>A</i></b><sup><i>i</i></sup> &larr; <b><i>A</i></b><sup><i>&nbsp;j</i></sup>.
The process which accomplishes this
(using row operations only) by reducing successive column
vectors to the successive unit vectors is called
<i>Jordan</i> or <i>complete</i> elimination.
If the same sequence of row operations is executed
upon the identity matrix,
it will be transformed to the matrix <b><i>B</i></b>
such that <b><i>B</i></b> <img src="APLimg/plustimes.bmp">
<b><i>A</i></b> = <font face=Arial><b><i>I</i></b></font>.
The inverse of <b><i>A</i></b> can therefore be obtained
by performing Jordan elimination on the matrix
<b><i>M</i></b> = <b><i>A</i></b> <img src="APLimg/circleplus.bmp">
<font face=Arial><b><i>I</i></b></font>
so as to reduce the first <i>&nu;</i>(<b><i>A</i></b>) columns
to the identity.
The last <i>&nu;</i>(<b><i>A</i></b>) columns
are then the inverse of <b><i>A</i></b>.
<table>
<tr><td valign=top>(a)</td><td>&nbsp;</td><td>
Write a program to determine the inverse of <b><i>A</i></b>
by Jordan elimination.
</td></tr>
<tr><td valign=top>(b)<sup>&nbsp;</sup></td><td>&nbsp;</td><td>
The sequence of operations which reduce the <i>i</i>th
column of <b><i>A</i></b> to <tt><b>∊</b></tt><sup><i>i</i></sup>
is called the <i>i</i>th <i>step</i> of the process,
and the <i>i</i>th diagonal element at the beginning
of the <i>i</i>th step is called the <i>i</i>th pivot element.
Modify the program of part (a) so that each step
is preceded by a column permutation
which yields the largest (in absolute value)
pivot element possible.
This modification tends to reduce
the accumulation of round-off errors.
</td></tr>
<tr><td valign=top>(c)</td><td>&nbsp;</td><td>
In the Jordan elimination of part (a),
it is unnecessary to store the identity matrix explicitly,
and, since the <i>i</i>th column is first affected
at the <i>i</i>th step, 
only one new column need be brought in at each step.
Moreover, the <i>i</i>th column of <b><i>A</i></b>
may be discarded after its reduction 
to <tt><b>∊</b></tt><sup><i>i</i></sup>
on the <i>i</i>th step, 
and it is therefore necessary to store 
only a square matrix at all times.
Show that by shifting all columns to the left
and by moving the rows upward cyclically,
a very uniform process results,
with the pivot element in the leading position
at every step
[<acronym title="verson, K.E. (1954), 
“Machine Solutions of Linear Differential Equations”, 
Doctoral Thesis, Harvard University.">Iverson (1954)</acronym> or
<acronym title="Rutishauser, H. (1959), 
“Zur Matrizeninversion nach Gauss-Jordan”, 
Zeitschrift für Angewandte Mathematik und Physik, 
vol. X, pp. 281-291.">Rutishauser (1959)</acronym>].
Write a program for the process.
</td></tr>
<tr><td valign=top>(d)</td><td>&nbsp;</td><td>
Modify part (c) to allow the choice of pivot
elements as in part (b).
The effects of the permutation on the not explicitly
recorded identity cannot be indicated directly,
but the performance of the same set of 
permutations in reverse order upon the <i>rows</i>
of the resulting inverse produces the same result.
Verify this and program the process.
</td></tr>
</table>
</p>


<p><b>1.41&nbsp;</b>
<table>
<tr><td valign=top>(a)</td><td>&nbsp;</td><td>
Show that a group
<acronym title="Jacobson, N. (1951), Lectures in Abstract Algebra,
vol. 1, Van Nostrand, New York.">[Jacobson (1951)]</acronym>
can be represented by a square matrix <b><i>M</i></b>
such that each row and each column
is a permutation vector.
</td></tr>
<tr><td valign=top>(b)</td><td>&nbsp;</td><td>
Show that <b><i>M</i></b><sup><i>&nbsp;i</i></sup> =
<b><i>M</i></b><sub><i>i</i></sub> =
<tt><b>⍳</b></tt><sup>1</sup> for some <i>i</i>.
</td></tr>
<tr><td valign=top>(c)</td><td>&nbsp;</td><td>
What are the necessary and sufficient conditions
that the group represented by <b><i>M</i></b>
be Abelian?
</td></tr>
<tr><td valign=top>(d)</td><td>&nbsp;</td><td>
What a program to determine all cyclic subgroups
of a group represented by <b><i>M</i></b>.
</td></tr>
</table>
</p>


<p><b>1.42&nbsp;</b> If <b><i>U</i></b> is a logical matrix
whose rows are each nonzero, mutually disjoint, 
and collectively exhaustive (that is,
(+/<b><i>U</i></b> &ge; <tt><b>∊</b></tt>) = <tt><b>∊</b></tt>,
and +//<b><i>U</i></b> = <tt><b>∊</b></tt>),
then <b><i>U</i></b> defines an <i>m-way partition</i>
of <i>n</i>, where <i>m</i> = <i>&mu;</i>(<b><i>U</i></b>), and
<i>n</i> = <i>&nu;</i>(<b><i>U</i></b>).
The partition is more commonly represented
by the vector <i>p</i> = +/<b><i>U</i></b>
[<acronym title="Riordan, J. (1958), 
An Introduction to Combinatorial Analysis, 
Wiley, New York.">Riordan (1958)</acronym>,
p. 107].
Clearly +/<b><i>p</i></b> = <i>n</i>.
Write a program to generate

<table>
<tr><td valign=top>(a)</td><td>&nbsp;</td><td>
all partitions <b><i>U</i></b> of a given integer <i>n</i>.
</td></tr>
<tr><td valign=top>(b)</td><td>&nbsp;</td><td>
all distinct partitions of <i>n</i>, where <b><i>U</i></b>
and <b><i>V</i></b> are considered 
equivalent if <b><i>p</i></b> = +/<b><i>U</i></b>
is a permutation of <b><i>q</i></b> = +/<b><i>V</i></b>.
</td></tr>
</table>
</p>


<p><b>1.43&nbsp;</b> Let = <b><i>x</i></b> be a <i>space</i> vector
(i.e., of dimension three), and let <b><i>R</i></b>(<b><i>x</i></b>)
be the square matrix 
<tt><b>⍳</b></tt> &uarr; (<tt><b>∊</b></tt> <img src="APLimg/jotand.bmp">
<b><i>x</i></b>). Show that

<table>
<tr><td valign=top>(a)</td><td>&nbsp;</td><td>
+/<b><i>R</i></b>(<b><i>x</i></b> &times; <b><i>y</i></b>) = 
(<b><i>x</i></b> <img src="APLimg/plustimes.bmp"> 
<b><i>y</i></b>) &times; <tt><b>∊</b></tt>
</td></tr>
<tr><td valign=top>(b)</td><td>&nbsp;</td><td>
<tt><b>∊</b></tt> <img src="APLimg/plustimes.bmp"> 
(<b><i>x</i></b> &times; <b><i>y</i></b>) =
<b><i>x</i></b> <img src="APLimg/plustimes.bmp"> <b><i>y</i></b>
</td></tr>
<tr><td valign=top>(c)</td><td>&nbsp;</td><td>
(+/<b><i>R</i></b>(<b><i>x</i></b> &times; <b><i>y</i></b>))
<img src="APLimg/plustimes.bmp">
(<b><i>w</i></b> &times; <b><i>z</i></b>) =
(<b><i>x</i></b> <img src="APLimg/plustimes.bmp"> <b><i>y</i></b>) &times;
(<b><i>w</i></b> <img src="APLimg/plustimes.bmp"> <b><i>z</i></b>)
</td></tr>
<tr><td valign=top>(d)</td><td>&nbsp;</td><td>
(<b><i>x</i></b> <img src="APLimg/plustimes.bmp"> <b><i>y</i></b>) &times;
(<b><i>x</i></b> <img src="APLimg/plustimes.bmp"> <b><i>y</i></b>) =
(<b><i>x</i></b> &times; <b><i>y</i></b>) +
(<b><i>x</i></b> &times; <b><i>y</i></b>) +
2(&darr; <b><i>x</i></b> &times; &uarr; <b><i>y</i></b>)
<img src="APLimg/plustimes.bmp">
(&darr; <b><i>x</i></b> &times; &uarr; <b><i>y</i></b>).
</td></tr>
</table>
</p>


<p><b>1.44&nbsp;</b> Let <b><i>x</i></b> &middot; <b><i>y</i></b>
= (&uarr; <b><i>x</i></b> &times; &darr; <b><i>y</i></b>) &ndash;
(&darr; <b><i>x</i></b> &times; &uarr; <b><i>y</i></b>) 
be the <i>vector product</i> of <b><i>x</i></b>
and <b><i>y</i></b> for vectors of dimension three.
Show that

<table>
<tr><td valign=top>(a)</td><td>&nbsp;</td><td>
this agrees with the usual definition
<acronym title="Margenau, H., and G.M. Murphy (1943), 
The Mathematics of Physics and Chemistry, 
Van Nostrand, New York.">[Margenau and Murphy (1943)]</acronym>.
</td></tr>
<tr><td valign=top>(b)</td><td>&nbsp;</td><td>
<b><i>x</i></b> &middot; <b><i>y</i></b> = 
&ndash;(<b><i>y</i></b> &middot; <b><i>x</i></b>)
</td></tr>
<tr><td valign=top>(c)</td><td>&nbsp;</td><td>
<b><i>x</i></b> &middot; <b><i>y</i></b> is perpendicular
to <b><i>x</i></b>, that is, <b><i>x</i></b> 
<img src="APLimg/plustimes.bmp"> (<b><i>x</i></b> &middot; <b><i>y</i></b>) = 0.
(Use the fact that &darr; <b><i>x</i></b> = 2&uarr;<b><i>x</i></b>
for a vector of dimension three.)
</td></tr>
</table>
</p>


<p><b>1.45&nbsp;</b> Let [<b><i>x</i></b>] = 
<img align=middle src="APLimg/ex1x45a.bmp">
be the <i>length of</i> <b><i>x</i></b>,
and let <b><i>x</i></b> &gamma; <b><i>y</i></b> = 
<img align=middle src="APLimg/ex1x45b.bmp">
be the cosine of the angle between 
<b><i>x</i></b> and <b><i>y</i></b>,
and let <b><i>x</i></b> <i>&sigma;</i> <b><i>y</i></b>
= <img align=middle src="APLimg/ex1x45c.bmp"> &nbsp;be 
the sine of the angle.
Use the results of Exercises 1.43 and 1.44
to show that for space vectors

<table>
<tr><td valign=top>(a)</td><td>&nbsp;</td><td>
[<b><i>x</i></b> &middot; <b><i>y</i></b>] =
[<b><i>x</i></b>] &times; [<b><i>y</i></b>] &times;
(<b><i>x</i></b> <i>&sigma;</i> <b><i>y</i></b>).
Note that [<b><i>x</i></b> &middot; <b><i>y</i></b>]
is the area enclosed by the parallelogram defined by
<b><i>x</i></b> and <b><i>y</i></b>.
</td></tr>
<tr><td valign=top>(b)</td><td>&nbsp;</td><td>
(<b><i>x</i></b> &middot; <b><i>y</i></b>) &middot; <b><i>z</i></b>
= (<b><i>x</i></b> <img src="APLimg/plustimes.bmp"> <b><i>z</i></b>) 
&times; <b><i>y</i></b> &ndash;
(<b><i>y</i></b> <img src="APLimg/plustimes.bmp"> <b><i>z</i></b>) 
&times; <b><i>x</i></b>
</td></tr>
<tr><td valign=top>(c)</td><td>&nbsp;</td><td>
(<b><i>x</i></b> &middot; <b><i>y</i></b>) <img src="APLimg/plustimes.bmp">
<b><i>z</i></b> = <b><i>x</i></b> <img src="APLimg/plustimes.bmp">
(<b><i>y</i></b> &middot; <b><i>z</i></b>).
</td></tr>
</table>

</p>
<br>



<!-------------------------------------------------------------------------------
  ------------------------------------------------------------------------------->



<a name="3"></a>
<p><font size=+1>Chapter 3 &nbsp; Representation of Variables</font></p>

<a name="3.1"></a>
<p><b>3.1 Allocation and encoding</b></p>

<p>Although the abstract description 
of a program may be presented 
in any suitable language, 
its automatic execution must be performed on some
specified representation of the relevant operands. 
The specification of this representation 
presents two distinct aspects&mdash;allocation and encoding.</p>

<p>An <i>allocation</i> specifies the correspondences 
between physical devices and the variables represented thereby. 
An <i>encoding</i> specifies the correspondences
between the distinct states of the physical devices 
and the literals which they represent. 
If, for example, certain numerical data are to be
represented by a set of 50 two-state devices, 
the two-out-of-five coding system 
of Exercise 1.6 might be chosen, 
and it would then remain to specify the allocation. 
The two-digit quantity &ldquo;hours worked&rdquo; 
might be allocated as follows: 
devices 31-35 represent components 1-5, 
respectively, of the first digit, 
and devices 29, 16, 17, 24, and 47 
represent components 1, 2, 3, 4, 5, 
respectively, of the second digit.</p>

<p>The encoding of a variable will be specified 
by an <i>encoding matrix</i> <b><i>C</i></b> and
associated <i>format vector</i> <b><i>f</i></b> 
such that the rows of <img src="APLimg/fboscore.bmp">/<b><i>C</i></b> 
list the representands
and the rows of <b><i>f</i></b>/<b><i>C</i></b> 
list the corresponding representations. 
The encoding is normally fixed and normally 
concerns the programmer only in the
translation of input or output data. 
Even this translation is usually
handled in a routine manner, 
and attention will therefore be restricted
primarily to the problem of allocation.</p>

<p>However, the encoding of numeric quantities 
warrants special comment.
It includes the representation of the sign 
and of the scale, as well as the
representation of the significant digits. 
Small numbers, such as indices, 
admit not only of the usual positional representation 
but also of the use of the unit vector 
<tt><b>∊</b></tt><sup><i>&nbsp;j</i></sup>
to represent the number <i>j</i> 
(i.e., a one-out-of-<i>n</i> coding system),
or of the use of a logical vector of weight <i>j</i> 
(i.e., a base 1 number system).</p>

<p>Allocation will be described in terms 
of the <i>physical vector</i> <b>&pi;</b>, 
which denotes the physical storage elements 
of the computer. 
Each component of <b>&pi;</b> corresponds 
to one of the <i>&nu;</i>(<b>&pi;</b>) 
similar physical devices available, 
its range of values is the set of physical states 
achievable by each device, and
its index is the address of the device. 
Each component of <b>&pi;</b> may correspond
to a computer register, 
an individual character position in a register,
or an individual binary digit within a character, 
depending on the degree of resolution 
appropriate to the allocation problem considered. 
The 0-origin indexing normally used for computer addresses 
will be used for the physical vector, but 1-origin indexing will, 
throughout this chapter, normally be employed 
for all other structured operands.</p>

<p>An index of the physical vector 
will be called an <i>address</i> 
and will itself be represented 
in the (perhaps mixed) radix appropriate to the given computer.
The Univac, for example, employs base ten addressing 
for the registers, and (because of the use of 12-character words) 
a radix of twelve for finer resolution. 
The address of the fourth character of register 675
might therefore be written as 675.3. 
In computers which have two or more independent addressing systems 
(e.g., the independent addressing
systems for main memory and for auxiliary storage in the IBM 705),
superscripts may be used to identify 
the several physical vectors <b>&pi;</b><sup><i>&nbsp;j</i></sup>.</p>

<p>In general, the <i>representation</i> 
of a quantity <i>x</i> is a vector 
(to be denoted by <tt><b>⍴</b></tt>(<i>x</i>)) 
whose components are chosen 
from the physical vector <b>&pi;</b>. 
Thus <tt><b>⍴</b></tt>(<i>x</i>) = <b><i>k</i></b>&int;<b>&pi;</b>, 
where <b><i>k</i></b> is a mapping vector 
associated with <i>x</i>. 
The dimension of the representation 
(that is, <i>&nu;</i>(<tt><b>⍴</b></tt>(<i>x</i>))) 
is called the <i>dimension of</i> <i>x</i> <i>in</i> <b>&pi;</b>. 
If, for example, <tt><b>⍴</b></tt>(<i>x</i>) = 
<nobr>(<b>&pi;</b><sub>10</sub>, <b>&pi;</b><sub>9</sub>, <b>&pi;</b><sub>17</sub>, <b>&pi;</b><sub>18</sub>),</nobr> 
then <b><i>k</i></b> = <nobr>(10, 9, 17, 18),</nobr>
and the dimension of <i>x</i> in <b>&pi;</b> is four. 
If <tt><b>⍴</b></tt>(<i>x</i>) is an infix of <b>&pi;</b>, 
then the representation of <i>x</i> is said to be <i>solid</i>. 
A solid representation can be characterized 
by two parameters, 
its dimension <i>d</i> and its <i>leading address</i> <i>f</i>, 
that is, the index in <b>&pi;</b> of its first component. 
Then <tt><b>⍴</b></tt>(<i>x</i>) = (<i>f</i> <tt>↓</tt> <tt><b>⍺</b></tt><sup><i>d</i></sup>)/<b>&pi;</b>.
<br>&nbsp;</p>



<a name="3.2"></a>
<p><b>3.2 Representation of structured operands</b></p>

<a name="3.2.1"></a>
<p><b>The grid matrix</b></p>

<p>If each component of a vector <b><i>x</i></b> 
has a solid representation, 
then the representation of the entire vector 
is said to be solid and may be characterized
by the <i>grid matrix</i> <b>&Gamma;</b>(<b><i>x</i></b>), 
of dimension <nobr><i>&nu;</i>(<b><i>x</i></b>) &times; 2,</nobr>
defined as follows:
<b>&Gamma;</b><sub>1</sub><sup><i>i</i></sup>(<b><i>x</i></b>) 
is the leading address of <tt><b>⍴</b></tt>(<b><i>x</i></b><sub><i>i</i></sub>), 
and <b>&Gamma;</b><sub>2</sub><sup><i>i</i></sup>(<b><i>x</i></b>) 
is the dimension of <b><i>x</i></b><sub><i>i</i></sub> in <b>&pi;</b>.
If, for example, the vector <b><i>x</i></b> 
is represented as shown in Fig. 3.1<i>a</i>, then</p>

<table>
<tr><td rowspan=5>&nbsp; &nbsp; &nbsp;</td><td rowspan=5>
<b>&Gamma;</b>(<b><i>x</i></b>) =&nbsp;</td>
<td rowspan=5><img src="APLimg/matrixl5.bmp"></td>
<td>17 2</td>
<td rowspan=5><img src="APLimg/matrixr5.bmp"></td>
<td rowspan=5>.</td></tr>
<tr><td>19 4</td></tr>
<tr><td>27 5</td></tr>
<tr><td>23 1</td></tr>
<tr><td>32 3</td></tr>
</table>

<p>Any structured operand can first 
be reduced to an equivalent vector, 
and the grid matrix therefore suffices 
for describing the representation 
of any construct, 
providing only that the representation 
of each of its elements is solid. 
Thus a matrix <b><i>X</i></b> may be represented 
by either the row-by-row list
<b><i>r</i></b> = <font face=Arial><b>E</b></font>/<b><i>X</i></b> 
or the column-by-column list 
<b><i>c</i></b> = <font face=Arial><b>E</b></font>//<b><i>X</i></b>, 
and a tree <b>T</b> may be represented 
by the left list matrix [<b>T</b> 
or the right list matrix ]<b>T</b>, 
either of which may be represented, in turn, by a vector.</p>

<p>If a process involves only a small number of variables, 
it is practical to make their allocation 
implicit in the algorithm, 
i.e., to incorporate in the algorithm 
the selection operations on the vector <b>&pi;</b> 
necessary to extract the appropriate variables. 
This is the procedure usually employed, 
for example, in simple computer programs. 
In processes involving numerous variables, 
implicit allocation may become too cumbersome and confusing,
and more systematic procedures are needed.</p>

<img src="APLimg/fig3x1.bmp">
<p align=center><b>Figure 3.1</b>
<br>&nbsp;</p>

<img src="APLimg/fig3x2.bmp">
<p align=center><b>Figure 3.2</b> 
Linear Representation of a matrix <b><i>X</i></b></p>



<a name="3.2.2"></a>
<p><b>Linear representations</b></p>

<p>The representation of a structured operand 
is said to be <i>linear</i> 
if each component is represented 
by an infix of the form 
<nobr>(<i>l</i> <tt>↓</tt> <tt><b>⍺</b></tt><sup><i>d</i></sup>)/<b>&pi;</b>,</nobr> 
where <i>l</i> is a linear function of the indices of the component. 
For example, the representation of the matrix <b><i>X</i></b> 
indicated by Fig. 3.2 is linear, 
with <i>d</i> = 2 and <i>l</i> = &ndash;11 + 5<i>i</i> + 8<i>j</i>.</p>

<p>A linear representation is solid 
and can clearly be characterized 
by a small number of parameters&mdash;the 
dimension <i>d</i> of each component and the
coefficients in the linear expression <i>l</i>. 
The representation of a vector <b><i>x</i></b> is linear 
if and only if <b>&Gamma;</b><sub>2</sub>(<b><i>x</i></b>) = <i>d</i><tt><b>∊</b></tt> 
and the difference 
<i>&delta;</i> = <b>&Gamma;</b><sub>1</sub><sup><i>i</i></sup>(<b><i>x</i></b>) 
&ndash; <b>&Gamma;</b><sub>1</sub><sup><i>i</i>&ndash;1</sup>(<b><i>x</i></b>)
is constant for <i>i</i> = 2, 3, &#133; , <i>&nu;</i>(<b><i>x</i></b>).</p>

<p>If <i>l</i> = <i>p</i> + <i>qi</i> + <i>rj</i> 
is the function defining a linear representation 
of a matrix <b><i>x</i></b> 
and if <i>a</i> is the leading address of a given element, 
then the leading address of the succeeding element 
in the row (or column) is simply <i>a</i> + <i>r</i>
(or <i>a</i> + <i>q</i>). 
Frequently, the succession must be cyclic, 
and the resulting sum must be reduced modulo 
<i>&nu;</i>(<b><i>x</i></b>) &times; <i>r</i> 
(or <i>&mu;</i>(<b><i>x</i></b>) &times; <i>q</i>). 
The inherent convenience of linear representations 
is further enhanced by index registers,
which provide efficient incrementation and comparison of addresses.</p>

<p>Linear representation of a structured operand 
requires that all components be 
of the same dimension in <b>&pi;</b>. 
This common dimension may, however, 
be achieved by appending null elements to the shorter components.
The convenience of the linear representation 
must then be weighed against the waste occasioned 
by the null elements. 
Moreover, if several vectors or matrices 
are to be represented 
and if each is of unspecified total dimension in <b>&pi;</b>, 
it may be impossible to allot to each an infix sufficiently
large to permit linear representation. 
Consequently, a linear representation 
is not always practicable.</p>



<a name="3.2.3"></a>
<p><b>Nonlinear representations</b></p>

<p>Since the use of the grid matrix imposes 
only the condition of solidity for each component, 
it permits an allocation which is sufficiently general
for most purposes. 
The grid matrix serves in two distinct capacities: 
(1) as a useful conceptual device 
for describing an allocation 
even when the actual allocation is implicit in the program, 
and (2) as a parameter which enters directly 
into an algorithm and explicitly specifies the allocation.</p>

<p>If the grid matrix is used in a program 
as an explicit specification of the allocation, 
then the grid matrix must itself be represented 
by the physical vector. 
There remains, therefore, the problem of choosing a suitable
allocation for the grid matrix itself; 
a linear allocation is illustrated by Fig.3.lb.</p>

<p>If the grid matrix <b>&Gamma;</b>(<b><i>x</i></b>) 
itself employs a linear representation, 
its use offers advantages over the direct use 
of a linear representation of <b><i>x</i></b> 
only if the total dimension of <b>&Gamma;</b> in <b>&pi;</b> 
is much less than the total dimension of <b><i>x</i></b> 
in <b>&pi;</b> when linear representations are employed for both. 
This is frequently the case, 
since each element of a grid matrix 
belongs to the index set of <b>&pi;</b>
(that is, to <tt><b>⍳</b></tt><sup>0</sup>(<i>&nu;</i>(<b>&pi;</b>))), 
and the dimension of each element in <b>&pi;</b> 
is therefore both uniform and relatively small. 
Program 3.3 shows the use of the grid
matrix <b>&Gamma;</b>(<b><i>x</i></b>) 
and the encoding matrix <b><i>C</i></b> 
in determining the <i>k</i>th component
of the vector <b><i>x</i></b>.</p>

<!--
<table border=1 cellspacing=0 cellpadding=0><tr><td>
<table>
<tr><td nowrap><sup>&nbsp;</sup><i>l</i> &larr; <i>p</i> + <i>qk</i> + <i>r</i> &times; 1 <sub>&nbsp;</sub></td></tr>
<tr><td nowrap><sup>&nbsp;</sup><i>f</i> &larr; <b><i>b</i></b> <tt>⊥</tt> ((<i>l</i> &darr; <tt><b>⍺</b></tt><sup><i>g</i></sup>)/<b>&pi;</b>) <sub>&nbsp;</sub></td></tr>
<tr><td><sup>&nbsp;</sup><i>l</i> &larr; <i>l</i> + <i>r</i> <sub>&nbsp;</sub></td></tr>
<tr><td><sup>&nbsp;</sup><i>d</i> &larr; <b><i>b</i></b> <tt>⊥</tt> ((<i>l</i> &darr; <tt><b>⍺</b></tt><sup><i>g</i></sup>)/<b>&pi;</b> <sub>&nbsp;</sub></td></tr>
<tr><td><sup>&nbsp;</sup><b><i>z</i></b> &larr; (<i> f</i> &darr; <tt><b>⍺</b></tt><sup><i>d </i></sup>)/<b>&pi;</b> <sub>&nbsp;</sub></td></tr>
<tr><td><sup>&nbsp;</sup><i>h</i> &larr; <i>&mu;</i>(<b><i>C</i></b>) + 1<sub>&nbsp;</sub></td></tr>
<tr><td><sup>&nbsp;</sup><i>h</i> &larr; <i>h</i> &ndash; 1 <sub>&nbsp;</sub></td></tr>
<tr><td><sup>&nbsp;</sup><b><i>z</i></b> : <b><i>f</i></b>/<b><i>C</i></b><sup><i> h</i></sup> <sub>&nbsp;</sub></td></tr>
<tr><td><sup>&nbsp;</sup><b><i>z</i></b> &larr; <img src="APLimg/fboscore.bmp">/<b><i>C</i></b><sup><i> h</i></sup><sub>&nbsp;</sub></td></tr>
</table>
</td></tr></table>
-->

<table><tr>
<td><img src="APLimg/prog3x3.bmp"> <br><br>&nbsp;</td>
<td nowrap>&nbsp; &nbsp;</td>
<td><table border=1 cellspacing=0 cellpadding=0>
<tr><td colspan=2 align=center>0-origin for <b>&pi;</b> only</td></tr>
<tr><td><table>
<tr><td valign=top nowrap>&nbsp;<i>p, q, r</i> &nbsp;</td>
<td>Constant, coefficient of row index, 
and coefficient of column index in the linear function
for the representation of <b>&Gamma;</b>(<b><i>x</i></b>).</td></tr>
<tr><td valign=top>&nbsp;<b><i>b</i></b></td>
<td>Based used in representing elements 
of <b>&Gamma;</b>(<b><i>x</i></b>).</td></tr>
<tr><td valign=top>&nbsp;<i>g</i></td>
<td>Dimension of <b>&pi;</b> of each element 
of <b>&Gamma;</b>(<b><i>x</i></b>).</td></tr>
<tr><td valign=top>&nbsp;<i>f</i></td>
<td>Leading address of <tt><b>⍴</b></tt>(<b><i>x</i></b><sub><i>k</i></sub>).</td></tr>
<tr><td valign=top>&nbsp;<i>d</i></td>
<td>Dimension of <tt><b>⍴</b></tt>(<b><i>x</i></b><sub><i>k</i></sub>) in <b>&pi;</b>.</td></tr>
<tr><td valign=top>&nbsp;<b><i>z</i></b></td>
<td><tt><b>⍴</b></tt>(<b><i>x</i></b><sub><i>k</i></sub>).</td></tr>
<tr><td valign=top>&nbsp;<b><i>C</i></b></td>
<td>Encoding matrix for components of <b><i>x</i></b>.</td></tr>
<tr><td valign=top>&nbsp;<b><i>f</i></b></td>
<td>Format vector for <b><i>C</i></b>.</td></tr>
<tr><td>&nbsp;<i>z</i></td>
<td>Character encoded by <b><i>x</i></b><sub><i>k</i></sub>.</td></tr>
</table></td></tr>
</table>
<p align=center><b>Legend</b></p></td>
</tr></table>

<p align=center><b>Program 3.3</b> Determination of
<b><i>z</i></b> = <tt><b>⍴</b></tt>(<b><i>x</i></b><sub><i>k</i></sub>)
and <i>z</i> = <b><i>x</i></b><sub><i>k</i></sub><br>
from a linear representation of the grid matrix
<b>&Gamma;</b>(<b><i>x</i></b>)</p>

<table><tr><td>&nbsp;</td><td>
<p><b>Program 3.3</b>. A linear representation is assumed 
for <b>&Gamma;</b>(<b><i>x</i></b>), 
with element <b>&Gamma;</b><sub><i>j</i></sub><sup><i>i</i></sup>(<b><i>x</i></b>)
represented by the infix 
<nobr>((<i>p</i> + <i>qi</i> + <i>rj</i>) &darr; <tt><b>⍺</b></tt><sup><i>g</i></sup>)/<b>&pi;</b>.</nobr> 
Moreover, each element of <b>&Gamma;</b>(<b><i>x</i></b>)
is assumed to be represented 
in a base <b><i>b</i></b> number system. 
Step 1 determines the leading address 
of the representation of <b>&Gamma;</b><sub>1</sub><sup><i>k</i></sup>(<b><i>x</i></b>). 
Step 2 specifies <i>f</i> as the base <b><i>b</i></b> value 
of this representation, i.e., as the leading address of <tt><b>⍴</b></tt>(<b><i>x</i></b><sub><i>k</i></sub>). 
Steps 3 and 4 specify <i>d</i> 
as the dimension of <b><i>x</i></b><sub><i>k</i></sub> in <b>&pi;</b>, 
and step 5 therefore specifies <b><i>z</i></b> 
as the representation of <b><i>x</i></b><sub><i>k</i></sub>.</p>

<p>Steps 7-9 perform the decoding 
of <b><i>z</i></b> = <tt><b>⍴</b></tt>(<b><i>x</i></b><sub><i>k</i></sub>) 
to obtain <b><i>z</i></b> as the actual value of <b><i>x</i></b><sub><i>k</i></sub>. 
Since this process is normally performed by human or mechanical means
(e.g., a printer) outside the purview of the programmer, 
it is here expressed directly 
in terms of the encoding matrix <b><i>C</i></b> 
rather than in terms of its representation. 
The left-pointing exit on step 7 is followed 
only if <b><i>z</i></b> does not occur as an entry in the
encoding matrix.</p>
</td><td>&nbsp;</td></tr></table>

<p>The form chosen for the grid matrix is one of several possible. The two
columns could, for example, represent the leading and final addresses of
the corresponding representations or the dimensions and final addresses.
The present choice of leading address <i>f</i> and dimension <i>d</i> 
is, however, the most convenient for use in conjunction 
with the notation adopted for infixes; 
the logical vector <nobr>(<i>f</i> &darr; <tt><b>⍺</b></tt><sup><i>d</i></sup>)</nobr>
selects the appropriate infix.</p>



<a name="3.2.4"></a>
<p><b>Chained representations</b><sup><a href="APL1.htm#note3a">[a]</a></sup></p>

<p>If a linear representation is used for a vector, 
then the deletion of a component (as in a compress operation) 
necessitates the moving (i.e., respecification) 
of the representations of each of the subsequent components.
Similarly, mesh operations (insertion) and permutations
necessitate extensive respecification. 
The use of a grid matrix <b>&Gamma;</b>(<b><i>x</i></b>) 
obviates such respecification in <b><i>x</i></b>, 
since appropriate changes can instead be made 
in <b>&Gamma;</b>(<b><i>x</i></b>), 
where they may be much simpler to effect. 
If, for example, <b><i>x</i></b> is the vector represented 
as in Fig. 3.1a, and <i>z</i> is a quantity of dimension
six in <b>&pi;</b>, then the mesh operation</p>

<table><tr><td width=75>&nbsp;</td>
<td><b><i>x</i></b> &larr; \<b><i>x</i></b>, <tt><b>∊</b></tt><sup>3</sup>, <i>z</i>\</td>
</tr></table>

<p>may be effected by specifying the physical infix 
(70 &darr; <tt><b>⍺</b></tt><sup>6</sup>)/<b>&pi;</b> by 
<tt><b>⍴</b></tt>(<i>z</i>) 
and by respecifying <b>&Gamma;</b>(<b><i>x</i></b>) as follows:</p>

<table><tr><td rowspan=6>&nbsp; &nbsp; &nbsp;</td>
<td rowspan=6><b>&Gamma;</b>(<b><i>x</i></b>) =&nbsp;</td>
<td rowspan=6><img src="APLimg/matrixl6.bmp"></td>
<td>17 2</td>
<td rowspan=6><img src="APLimg/matrixr6.bmp"></td>
<td rowspan=6>.</td></tr>
<tr><td>19 4</td></tr>
<tr><td>70 6</td></tr>
<tr><td>27 5</td></tr>
<tr><td>23 1</td></tr>
<tr><td>32 3</td></tr>
</table>

<p>However, if the representation 
of <b>&Gamma;</b>(<b><i>x</i></b>) is itself linear, 
then insertions, deletions, and permutations in <b><i>x</i></b> 
will occasion changes in all components 
of <b>&Gamma;</b>(<b><i>x</i></b>) 
whose indices are affected. 
The need for a linear representation of the grid matrix 
(and hence for all linear representations) 
can be obviated by the use 
of a chained representation defined as follows.</p>

<p>Consider a vector <b><i>y</i></b>, 
each of whose components <b><i>y</i></b><sub><i>k</i></sub>
has a solid representation
<tt><b>⍴</b></tt>(<b><i>y</i></b><sub><i>k</i></sub>) 
whose infixes 
(<i>g</i> &darr; <tt><b>⍺</b></tt><sup><i>g</i></sup>)/<tt><b>⍴</b></tt>(<b><i>y</i></b><sub><i>k</i></sub>) 
and 
<tt><b>⍺</b></tt><sup><i>g</i></sup>/<tt><b>⍴</b></tt>(<b><i>y</i></b><sub><i>k</i></sub>) 
are, respectively,
the dimension 
of <tt><b>⍴</b></tt>(<b><i>y</i></b><sub><i>k</i></sub>) in <b>&pi;</b> 
and the leading address of the representation of
the (cyclically) succeeding component of <b><i>y</i></b> 
(both in a base <b><i>b</i></b> system), 
and whose suffix 
<img src="APLimg/alphaboscore.bmp"><sup>&nbsp;2<i>g</i></sup>/<tt><b>⍴</b></tt>(<b><i>y</i></b><sub><i>k</i></sub>) 
is the representation of the <i>k</i>th component 
of some vector <b><i>x</i></b>. 
Then (the representation of) <b><i>y</i></b> 
is called a <i>chained representation of</i> <b><i>x</i></b>. 
In other words, the representation of <b><i>y</i></b> 
incorporates its own grid matrix 
(with the address column <b>&Gamma;</b><sub>1</sub>(<b><i>y</i></b>) 
rotated upward by one place) 
as well as the representation of the vector <b><i>x</i></b>.</p>

<p>For example, if <i>g</i> = 2, <b><i>b</i></b> = 10<tt><b>∊</b></tt>, 
and <b><i>x</i></b> = <nobr>(365, 7, 24),</nobr> then</p>

<table>
<tr><td width=75>&nbsp;</td>
<td><tt><b>⍴</b></tt>(<b><i>y</i></b><sub>1</sub>) = 
(<b>&pi;</b><sub>17</sub>, <b>&pi;</b><sub>18</sub>, <b>&pi;</b><sub>19</sub>, <b>&pi;</b><sub>20</sub>, <b>&pi;</b><sub>21</sub>, <b>&pi;</b><sub>22</sub>, <b>&pi;</b><sub>23</sub>) = 
(6, 8, 0, 7, 3, 6, 5),</td></tr>
<tr><td>&nbsp;</td>
<td><tt><b>⍴</b></tt>(<b><i>y</i></b><sub>2</sub>) = 
(<b>&pi;</b><sub>68</sub>, <b>&pi;</b><sub>69</sub>, <b>&pi;</b><sub>70</sub>, <b>&pi;</b><sub>71</sub>, <b>&pi;</b><sub>72</sub>) = 
(2, 6, 0, 5, 7),</td></tr>
<tr><td>and</td></tr>
<tr><td>&nbsp;</td>
<td><tt><b>⍴</b></tt>(<b><i>y</i></b><sub>3</sub>) = 
(<b>&pi;</b><sub>26</sub>, <b>&pi;</b><sub>27</sub>, <b>&pi;</b><sub>28</sub>, <b>&pi;</b><sub>29</sub>, <b>&pi;</b><sub>30</sub>, <b>&pi;</b><sub>31</sub>) = 
(1, 7, 0, 6, 2, 4),</td></tr>
</table>

<p>is a suitable chained representation of <b><i>x</i></b>.</p>

<p>The parameters required in executing an algorithm on a chained
representation <b><i>y</i></b> are 
<i>g</i>, the common dimension in <b>&pi;</b> 
of the elements of the grid matrix <b>&Gamma;</b><sub>1</sub>(<b><i>y</i></b>); 
<b><i>b</i></b>, the base of the number system employed in their
representation; 
and <i>f</i> and <i>h</i>, the leading address and index, respectively,
of the representation of some one component of <b><i>y</i></b>. 
The parameters <i>g</i> and <b><i>b</i></b> 
are usually common to the entire set 
of chained representations in use.
Program 3.4 illustrates the type of algorithm required 
to determine <tt><b>⍴</b></tt>(<b><i>x</i></b><sub><i>k</i></sub>)
from a given chained representation of <b><i>x</i></b>.</p>

<!--
<table border=1 cellspacing=0 cellpadding=0><tr><td><table>
<tr><td><sup>&nbsp;</sup> <i>h</i> &larr; <i>&nu;</i>(<b><i>x</i></b>) |<sub>1</sub>(<i>h</i> + 1) <sub>&nbsp;</sub></td></tr>
<tr><td><sup>&nbsp;</sup> <i>f</i> &larr; <b><i>b</i></b> <tt>⊥</tt> (( <i>f</i> &darr; <tt><b>⍺</b></tt><sup><i>g </i></sup>)/<b>&pi;</b>) <sub>&nbsp;</sub></td></tr>
<tr><td><sup>&nbsp;</sup> <i>h</i> : <i>k</i> <sub>&nbsp;</sub></td></tr>
<tr><td nowrap><sup>&nbsp;</sup> <i>d</i> &larr; <b><i>b</i></b> <tt>⊥</tt> (( <i>f</i> + <i>g</i>) &darr; <tt><b>⍺</b></tt><sup><i>g </i></sup>)/<b>&pi;</b> <sub>&nbsp;</sub></td></tr>
<tr><td><sup>&nbsp;</sup> <b><i>z</i></b> &larr; ( <i>f</i> &darr; <tt><b>⍺</b></tt><sup><i>d</i></sup>)/<b>&pi;</b> <sub>&nbsp;</sub></td></tr>
<tr><td><sup>&nbsp;</sup> <tt><b>⍴</b></tt>(<b><i>x</i></b><sub><i>k</i></sub>) &larr; <img src="APLimg/alphaboscore.bmp"><sup> 2<i>g</i></sup>/<b>&pi;</b> <sub>&nbsp;</sub></td></tr>
</table>
</td></tr></table>
-->

<table><tr><td><img src="APLimg/prog3x4.bmp"> <br><br>&nbsp;</td>
<td nowrap>&nbsp; &nbsp;</td>
<td><table border=1 cellspacing=0 cellpadding=0>
<tr><td align=center>0-origin indexing for <b>&pi;</b> only</td></tr>
<tr><td><table>
<tr><td valign=top nowrap>&nbsp;<i>h</i>, <i>f</i> &nbsp;</td>
 <td><i>f</i> is the leading address of the <i>h</i>th 
 component of the chained representation of <b><i>x</i></b>.</td></tr>
<tr><td valign=top>&nbsp;<i>b</i> &nbsp;</td>
 <td>Base used for representation of the elements 
 of the grid matrix.</td></tr>
<tr><td valign=top>&nbsp;<i>g</i> &nbsp;</td>
 <td>Dimension in <b>&pi;</b> of elements 
 of the grid matrix.</td></tr>
<tr><td valign=top>&nbsp;<i>d</i> &nbsp;</td>
 <td>Dimension in <b>&pi;</b> of <i>k</i>th component
 of the chained representation of <b><i>x</i></b>.</td></tr>
<tr><td valign=top>&nbsp;<i>z</i> &nbsp;</td>
 <td><i>k</i>th component of the chained representation 
 of <b><i>x</i></b>.</td></tr>
</table></td></tr>
</table>
<p align=center><b>Legend</b></p>
</td></tr>
</table>

<p align=center><b>Program 3.4</b> 
Determination of <tt><b>⍴</b></tt>(<b><i>x</i></b><sub><i>k</i></sub>) 
from a chained representation of <b><i>x</i></b></p>

<table><tr><td>&nbsp;</td><td>
<p><b>Program 3.4.</b> The loop (1-3) is executed 
<i>&nu;</i>(<b><i>x</i></b>)|<sub>0</sub>(<i>k</i> &ndash; <i>h</i>) times, 
with the result that at step 4 the parameter <i>f</i> 
is the leading address of <tt><b>⍴</b></tt>(<b><i>y</i></b><sub><i>k</i></sub>). 
Step 4 therefore specifies <i>d</i> as the dimension 
of <tt><b>⍴</b></tt>(<b><i>x</i></b><sub><i>k</i></sub>), 
that is, as the base <b><i>b</i></b> value 
of <b>&Gamma;</b><sub>2</sub><sup><i>k</i></sup>(<b><i>y</i></b>). 
Step 5 then specifies <b><i>z</i></b> as <tt><b>⍴</b></tt>(<b><i>y</i></b><sub><i>k</i></sub>). 
Step 6 deletes those components of <b><i>z</i></b> which represent
the elements of the grid matrix, 
leaving <tt><b>⍴</b></tt>(<b><i>x</i></b><sub><i>k</i></sub>).</p>

<p>The parameters <i>f</i> and <i>h</i> 
are themselves respecified in the execution of the
algorithm so that <i>h</i> becomes <i>k</i> 
and <i>f</i> becomes, appropriately, 
the leading address of <tt><b>⍴</b></tt>(<b><i>y</i></b><sub><i>k</i></sub>). 
A subsequent execution then begins from this new initial condition.</p>
</td><td>&nbsp;</td></tr></table>

<p>The chained representation used thus far is cyclic 
and contains no internal identification 
of the first or the last components. 
Such an identification can be incorporated 
by adding a null component between the last
and first components of <b><i>x</i></b>. 
Alternatively the identification may be achieved
without augmenting the dimension 
but by sacrificing the end-around chaining, 
i.e., by replacing the last component 
of <nobr>&uarr;<b>&Gamma;</b><sub>1</sub>(<b><i>y</i></b>)</nobr>
by a null element.
Moreover, a chained representation may be entered 
(i.e., the scan may be begun) at anyone of several points, 
provided only that the index <i>h</i> and
corresponding leading address <i>f</i> 
are known for each of the points.</p>

<p>The number of components 
of a chained representation scanned 
(steps 1-3 of Program 3.4) 
in selecting the <i>k</i>th component of <b><i>x</i></b> 
is given by 
<nobr><i>&nu;</i>(<b><i>x</i></b>)|<sub>0</sub>(<i>k</i> &ndash; <i>h</i>),</nobr>
where <i>h</i> is the index of the component last selected. 
The selection operation is therefore most efficient 
when the components are selected in ascending order on the index. 
The chaining is effective in the
forward direction only, 
and the component <nobr>(<i>h</i> &ndash; 1)</nobr> 
would be obtained only by a complete cyclic forward scan 
of <nobr><i>&nu;</i>(<b><i>x</i></b>) &ndash; 1</nobr> components. 
The representation is therefore called a <i>forward chain</i>. 
A <i>backward chain</i> can
be formed by incorporating the vector 
<nobr>&darr;<b>&Gamma;</b><sub>1</sub>(<b><i>y</i></b>)</nobr> 
instead of 
<nobr>&uarr;<b>&Gamma;</b><sub>1</sub>(<b><i>y</i></b>),</nobr> 
and a double chain results from incorporating both.</p>

<p>A vector <b><i>x</i></b> which is respecified only 
by either deleting the final component
or by adding a new final component 
(i.e., by operations of the form 
<nobr><b><i>x</i></b> &larr; <img src="APLimg/omegaboscore.bmp"><sup>1</sup>/<b><i>x</i></b>,</nobr> or 
<nobr><b><i>x</i></b> &larr; <b><i>x</i></b> <img src="APLimg/circleplus.bmp"> (<i>z</i>))</nobr> 
behaves as a stack (cf. Exercise 2.6). 
A backward-chained representation is clearly 
convenient for such a stack.</p>

<p>A simple example of the use of a chained stack occurs 
in representing the available (i.e., unused) segments 
of the physical vector <b>&pi;</b>. 
This will be illustrated by a program 
for the vector compression</p>

<p>&nbsp; &nbsp; &nbsp;<b><i>x</i></b> &larr; <b><i>v</i></b>/<b><i>x</i></b></p>

<p>executed on a forward-chained representation 
of <b><i>x</i></b>. 
The unused segments
representing the components 
of <img src="APLimg/vboscore.bmp">/<b><i>x</i></b> 
are returned to a backward-chained
stack or <i>pool</i> of available components. 
A linear representation can usually
be used for logical control vectors such as <b><i>v</i></b>; 
in any case the problems involved in their representation 
are relatively trivial and will be subordinated
by expressing each operation directly in terms 
of the logical vectors and not in terms 
of the physical components representing them.</p>

<!--
<table border=1 cellspacing=0 cellpadding=0><tr><td>
<table>
<tr><td>&nbsp; 1<sup>&nbsp;</sup> <i>x</i> : <tt>∘</tt> <sub>&nbsp;</sub></td></tr>
<tr><td>&nbsp; 2<sup>&nbsp;</sup> <i>i</i> &larr; <i>x</i> <sub>&nbsp;</sub></td></tr>
<tr><td>&nbsp; 3<sup>&nbsp;</sup> <i>t</i> &larr; <i>x</i> <sub>&nbsp;</sub></td></tr>
<tr><td>&nbsp; 4<sup>&nbsp;</sup> <i>x</i> &larr; <tt>∘</tt> <sub>&nbsp;</sub></td></tr>
<tr><td>&nbsp; 5<sup>&nbsp;</sup> <i>k</i> &larr; 1 <sub>&nbsp;</sub></td></tr>
<tr><td>&nbsp; 6<sup>&nbsp;</sup> <b><i>b</i></b> <tt>⊥</tt> ((<i>r</i> &darr; <tt><b>⍺</b></tt><sup><i>g</i></sup>)/<b>&pi;</b>) &larr; <i>s</i> <sub>&nbsp;</sub></td></tr>
<tr><td>&nbsp; 7<sup>&nbsp;</sup> <i>k</i> &larr; <i>k</i> + 1<sub>&nbsp;</sub></td></tr>
<tr><td>&nbsp; 8<sup>&nbsp;</sup> <i>i</i> &larr; <i>j</i> <sub>&nbsp;</sub></td></tr>
<tr><td>&nbsp; 9<sup>&nbsp;</sup> <i>i</i> : <i>t</i> <sub>&nbsp;</sub></td></tr>
<tr><td>10<sup>&nbsp;</sup> <i>x</i> : <tt>∘</tt> <sub>&nbsp;</sub></td></tr>
<tr><td nowrap>11<sup>&nbsp;</sup> <b><i>b</i></b> <tt>⊥</tt> ((<i>h</i> &darr; <tt><b>⍺</b></tt><sup><i>g</i></sup>)/<b>&pi;</b>) &larr; <i>x</i> <sub>&nbsp;</sub></td></tr>
<tr><td>12<sup>&nbsp;</sup> <i>j</i> &larr; <b><i>b</i></b> <tt>⊥</tt> ((<i>i</i> &darr; <tt><b>⍺</b></tt><sup><i>g</i></sup>)/<b>&pi;</b>) <sub>&nbsp;</sub></td></tr>
<tr><td>13<sup>&nbsp;</sup> <b><i>v</i></b><sub><i>k</i></sub> : 0 <sub>&nbsp;</sub></td></tr>
<tr><td>14<sup>&nbsp;</sup> <i>x</i> : <tt>∘</tt> <sub>&nbsp;</sub></td></tr>
<tr><td>15<sup>&nbsp;</sup> <i>x</i> &larr; <i>i</i> <sub>&nbsp;</sub></td></tr>
<tr><td>16<sup>&nbsp;</sup> <i>h</i> &larr; <i>i</i><sub>&nbsp;</sub></td></tr>
<tr><td>17<sup>&nbsp;</sup> <b><i>v</i></b><sub><i>k</i>&ndash;1</sub> : 0 <sub>&nbsp;</sub></td></tr>
<tr><td>18<sup>&nbsp;</sup> <i>r</i> &larr; <i>h</i> <sub>&nbsp;</sub></td></tr>
<tr><td>19<sup>&nbsp;</sup> <i>s</i> &larr; <i>i</i> <sub>&nbsp;</sub></td></tr>
<tr><td>20<sup>&nbsp;</sup> <i>h</i> &larr; <i>i</i> <sub>&nbsp;</sub></td></tr>
<tr><td>21<sup>&nbsp;</sup> <i>r</i> &larr; <i>i</i> <sub>&nbsp;</sub></td></tr>
<tr><td>22<sup>&nbsp;</sup> <i>s</i> &larr; <i>p</i> <sub>&nbsp;</sub></td></tr>
<tr><td>23<sup>&nbsp;</sup> <i>p</i> &larr; <i>i</i> <sub>&nbsp;</sub></td></tr>
</table>
</td></tr></table>
-->

<table>
<tr><td><img src="APLimg/prog3x5.bmp"></td><td>&nbsp; &nbsp; &nbsp;</td><td valign=top>
<table border=1 cellspacing=0 cellpadding=0>
<tr><td align=center nowrap>0-origin indexing for <b>&pi;</b> only</td></tr>
<tr><td><table>
<tr><td valign=top>&nbsp;<i>x</i> &nbsp;</td><td>
 Leading address 
 of <tt><b>⍴</b></tt>(<b><i>x</i></b><sub>1</sub>)
 if <i>&nu;</i>(<b><i>x</i></b>) &gt; 0; 
 otherwise <i>x</i> = <tt>∘</tt>
 </td></tr>
<tr><td valign=top nowrap>&nbsp;<b><i>v</i></b> &nbsp;</td><td>
 Logical vector.
 </td></tr>
<tr><td valign=top nowrap>&nbsp;<i>k</i> &nbsp;</td><td>
 Index of <b><i>v</i></b>.
 </td></tr>
<tr><td valign=top>&nbsp;<i>i</i> &nbsp;</td><td>
 Leading address of <tt><b>⍴</b></tt>(<b><i>x</i></b><sub><i>k</i></sub>)
 </td></tr>
<tr><td valign=top>&nbsp;<i>j</i> &nbsp;</td><td>
 Leading address of <tt><b>⍴</b></tt>(<b><i>x</i></b><sub><i>k</i>+1</sub>)
 </td></tr>
<tr><td valign=top>&nbsp;<i>h</i> &nbsp;</td><td>
 Leading address of last preceding component
 of <b><i>v</i></b>/<b><i>x</i></b>.
 </td></tr>
<tr><td valign=top>&nbsp;<i>p</i> &nbsp;</td><td>
 Leading address of last preceding component
 of pool of available segments.
 </td></tr>
<tr><td valign=top>&nbsp;<i>g</i> &nbsp;</td><td>
 Dimension in <b>&pi;</b> of elements of grid matrices.
 </td></tr>
<tr><td valign=top>&nbsp;<b><i>b</i></b> &nbsp;</td><td>
 Base of representation of elements of grid matrices.
 </td></tr>
</table></td></tr>
</table>
<p align=center><b>Legend</b></p></td></tr>
</td></tr>
</table>

<p align=center><b>Program 3.5</b> 
Program for <b><i>x</i></b> &larr; <b><i>v</i></b>/<b><i>x</i></b> 
on a forward chained representation of <b><i>x</i></b><br>
and a backward chained stack of available segments</p>

<table><tr><td>&nbsp;</td><td>
<p><b>Program 3.5</b>. In the major loop (6-23), 
<i>k</i> determines the index of the current component 
<b><i>v</i></b><sub><i>k</i></sub>, 
and <i>i</i> and <i>j</i> determine the leading addresses 
of <tt><b>⍴</b></tt>(<b><i>x</i></b><sub><i>k</i></sub>) 
and <tt><b>⍴</b></tt>(<b><i>x</i></b><sub><i>k</i>+1</sub>),
respectively. 
These three parameters are cycled through successive values 
by steps 7, 8, and 12 
and are initialized by steps 2,5, and 12. 
If <b><i>v</i></b><sub><i>k</i></sub> = 0, the infix
<tt><b>⍴</b></tt>(<b><i>x</i></b><sub><i>k</i></sub>) 
is returned to the pool by steps 21, 22, 23, and 6 
so as to construct a backward chain.</p>

<p>The parameter <i>x</i> specifies the leading address 
of <tt><b>⍴</b></tt>(<b><i>x</i></b><sub>1</sub>) 
unless <i>&nu;</i>(<b><i>x</i></b>) = 0, 
in which case <i>x</i> is null. 
Step 1 terminates the process if <i>&nu;</i>(<b><i>x</i></b>) = 0, 
and otherwise step 4 respecifies <i>x</i> as the null element. 
If <b><i>v</i></b> = 0, 
this null value of <i>x</i> remains; 
if not, the first nonzero component of <b><i>v</i></b> 
causes a branch to step 14. 
Since <i>x</i> = <tt>∘</tt>, 
step 15 is executed to respecify <i>x</i> 
as the leading address 
of <tt><b>⍴</b></tt>((<b><i>v</i></b>/<b><i>x</i></b>)<sub>1</sub>). 
Step 16 then specifies <i>h</i>,
the leading address of the last completed component 
of <b><i>v</i></b>/<b><i>x</i></b>. 
Step 15 is never again executed.</p>

<p>Components of <b><i>v</i></b>/<b><i>x</i></b> 
other than the first must each be chained 
(in a forward chain) to the preceding one. 
Hence the leading address <i>i</i> of a newly added component
must be inserted in the last preceding component 
(whose leading address is <i>h</i>). 
This is normally done by steps 18, 19, and 6; 
step 20 respecifies <i>h</i>. 
If, however, the component 
<b><i>x</i></b><sub><i>k</i>&ndash;1</sub> were also included, 
it would appear as the last completed component 
of <b><i>v</i></b>/<b><i>x</i></b> 
and would already be chained to the new component 
<b><i>x</i></b><sub><i>k</i></sub>.
This situation is recognized by step 17 
and occasions a branch to step 16. 
Step 16 then respecifies <i>h</i> 
and repeats the loop without executing steps 18, 19, and 6.</p>

<p>The process terminates when the cycle 
through the chained representation of <b><i>x</i></b>
is completed, that is, 
when <i>i</i> returns to the original value of <i>x</i>, 
preserved as <i>t</i> by step 3. 
Step 10 is then executed, 
terminating the process directly if 
<i>&nu;</i>(<b><i>v</i></b>/<b><i>x</i></b>) = 0.
Otherwise, step 11 is executed to close the chain 
of <b><i>v</i></b>/<b><i>x</i></b>, 
that is, to insert <i>x</i>, 
the leading address 
of <tt><b>⍴</b></tt>((<b><i>v</i></b>/<b><i>x</i></b>)<sub>1</sub>),
in the representation of the last component 
of <b><i>v</i></b>/<b><i>x</i></b>.</p>
</td><td>&nbsp;</td></tr></table>

<p>A chained representation can be generalized 
to allow the direct representation of more complex constructs, 
such as trees, by incorporating the address of each 
of the successor components associated with a given component. 
This notion is formalized in the chain list matrix of Sec. 3.4.
The same scheme can also be employed 
to produce an efficient combined representation 
of two or more vectors which share certain common components. 
If, for example, <b><i>x</i></b><sub><i>j</i></sub> 
= <b><i>x</i></b><sub><i>k</i></sub>, 
and chained representations are used 
for both <b><i>x</i></b> and <b><i>z</i></b>, 
then <b><i>x</i></b> may be represented in standard form except
that component <b><i>x</i></b><sub><i>j</i></sub> 
incorporates a secondary address, 
which is the leading address of <b><i>z</i></b><sub><i>k</i>+1</sub>. 
Moreover <b><i>z</i></b> has a standard representation 
except that <b><i>z</i></b><sub><i>k</i>&ndash;1</sub> 
is chained to <b><i>x</i></b><sub><i>j</i></sub> 
with an indicator to show that the secondary address
of the succeeding component is to be used. 
Deletion of any vector component 
in such a shared system must occasion 
only the corresponding change in the address chain 
of the vector, the actual representation of the
component being deleted 
only when no associated address remains.</p>



<a name="3.2.5"></a>
<p><b>Partitions</b></p>

<p>If the set <b><i>a</i></b> is the range 
of the components of the physical vector <b>&pi;</b>, 
and if some element, say <b><i>a</i></b><sub>1</sub> 
is reserved as a <i>partition symbol</i> 
and is excluded from use 
in the normal representation of quantities, 
it can be inserted to demark the end (or beginning) 
of an infix of <b>&pi;</b>. 
If the vector <b><i>y</i></b> is represented
by a single infix of <b>&pi;</b> 
such that the beginning of component 
<b><i>y</i></b><sub><i>j</i>+1</sub>
follows immediately 
after the terminal partition of
<b><i>y</i></b><sub><i>j</i></sub>,
then the structure of
<b><i>y</i></b> is completely represented by the partitions, 
and <b><i>y</i></b> is called a <i>partitioned representation</i>. 
A partitioned representation can be used 
for more complex operands, 
such as matrices, 
if a set of two or more 
distinct partition symbols are provided, 
one for each level of structure. 
The distinct partition symbols can, of course, 
be represented by multiple occurrences of
a single symbol <b><i>a</i></b><sub>1</sub> 
rather than by distinct members of <b><i>a</i></b>.</p>

<p>A partitioned representation 
is similar to a double-chained representation
without end-around chaining in the following particular: 
beginning from component <b><i>y</i></b><sub><i>i</i></sub>, 
the component <b><i>y</i></b><sub><i>j</i></sub> 
can be reached only by scanning 
all intervening components 
between <i>i</i> and <i>j</i> 
in increasing or decreasing order according 
as <i>i</i> &lt; <i>j</i> or <i>i</i> &gt; <i>j</i>. 
The file notation introduced in Sec. 1.22 
clearly provides the operations appropriate 
to a partitioned representation of a vector, 
with conventions which suppress all inessential
references to the partitions themselves.</p>

<p>The use of a partition to demark 
the end of an infix is particularly convenient 
when the infix must be processed component by component
for other reasons, 
as in the use of magnetic tape or other serial storage.
The partition also appears to be more economical than 
the grid matrix, which it replaces. 
This apparent economy is, however, somewhat illusory,
since the reservation of a special partition symbol 
reduces the information content of each nonpartition component 
by the factor 
<nobr>log<sub>2</sub>(<i>&nu;</i>(<b><i>a</i></b>) &ndash; 1) 
<tt>÷</tt> log<sub>2</sub> <i>&nu;</i>(<b><i>a</i></b>),</nobr> 
where <b><i>a</i></b> is the range 
of the components of <b>&pi;</b>.</p>

<p>Partitions can be employed in chained representations. 
For example, the dimension in <b>&pi;</b> 
of each component of a chained representation <b><i>y</i></b> can be
specified implicitly by terminal partitions 
instead of explicitly by the vector
<b>&Gamma;</b><sub>2</sub>(<b><i>y</i></b>)
of the grid matrix. 
Thus if the elements of 
<b>&Gamma;</b><sub>1</sub>(<b><i>y</i></b>) are of dimension <i>g</i>
in <b>&pi;</b>, then 
<tt><b>⍵</b></tt><sup>1</sup>/<tt><b>⍴</b></tt>(<b><i>y</i></b><sub><i>j</i></sub>) = 
<b><i>a</i></b><sub>1</sub>,
and 
<nobr>(<img src="APLimg/alphaboscore.bmp"><sup><i> g</i></sup> &and;
<img src="APLimg/omegaboscore.bmp"><sup>1</sup>)/<tt><b>⍴</b></tt>(<b><i>y</i></b><sub><i>j</i></sub>) = 
<tt><b>⍴</b></tt>(<b><i>x</i></b><sub><i>j</i></sub>),</nobr>
where <b><i>x</i></b> is the
vector represented by <b><i>y</i></b>. 
Program 3.6 shows the determination of 
<tt><b>⍴</b></tt>(<b><i>x</i></b><sub><i>k</i></sub>)
from a chained representation <b><i>y</i></b> 
with terminal partitions <b><i>a</i></b><sub>1</sub>.</p>

<!--
<table border=1 cellspacing=0 cellpadding=0><tr><td><table>
<tr><td>1<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td><sup>&nbsp;</sup> <i>h</i> &larr; <i>&nu;</i>(<b><i>x</i></b>) |<sub>1</sub> (<i>h</i> + 1) <sub>&nbsp;</sub></td></tr>
<tr><td>2<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td nowrap><sup>&nbsp;</sup> <i>f</i> &larr; <b><i>b</i></b> <tt>⊥</tt> ((<i>f</i> &darr; <tt><b>⍺</b></tt><sup><i>g</i></sup>)/<b>&pi;</b>) <sub>&nbsp;</sub></td></tr>
<tr><td>3<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td><sup>&nbsp;</sup> <i>h</i> : <i>k</i> <sub>&nbsp;</sub></td></tr>
<tr><td>4a<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td><sup>&nbsp;</sup> <i>j</i> &larr; <i>f</i> + <i>g</i> <sub>&nbsp;</sub></td></tr>
<tr><td>4b<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td><sup>&nbsp;</sup> <b>&pi;</b><sub><i>j</i></sub> : <b><i>a</i></b><sub>1</sub> <sub>&nbsp;</sub></td></tr>
<tr><td>4c<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td><sup>&nbsp;</sup> <i>j</i> &larr; <i>j</i> + 1 <sub>&nbsp;</sub></td></tr>
<tr><td>4d<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td><sup>&nbsp;</sup> <i>d</i> &larr; <i>j</i> &ndash; <i>f</i> <sub>&nbsp;</sub></td></tr>
<tr><td>5<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td><sup>&nbsp;</sup> <b><i>z</i></b> &larr; ( <i>f</i> &darr; <tt><b>⍺</b></tt><sup><i>d</i></sup>)/<b>&pi;</b> <sub>&nbsp;</sub></td></tr>
<tr><td>6<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td><sup>&nbsp;</sup> <tt><b>⍴</b></tt>(<b><i>x</i></b><sub><i>k</i></sub>) &larr; <img src="APLimg/alphaboscore.bmp"><sup><i> g</i></sup>/<b><i>z</i></b> <sub>&nbsp;</sub></td></tr>
</table>
</td></tr></table>
-->

<table><tr><td><img src="APLimg/prog3x6.bmp"></td>
<td>&nbsp; &nbsp;</td><td>
<table border=1 cellspacing=0 cellpadding=0>
<tr><td align=center>0-origin indexing for <b>&pi;</b> only</td></tr>
<tr><td><table>
<tr><td valign=top nowrap>&nbsp; <i>h</i>, <i>f</i> &nbsp;</td><td>
 <i>f</i> is the leading address of the
 <i>h</i>th component of the chained representation of <b><i>x</i></b>.
<tr><td valign=top nowrap>&nbsp; <b><i>b</i></b>  &nbsp;</td><td>
 Base used for representation of
 the elements of the grid matrix.
 </td></tr>
<tr><td valign=top nowrap>&nbsp; <i>g</i>  &nbsp;</td><td>
 Dimension in <b>&pi;</b> of the elements 
 of the grid matrix.
 </td></tr>
<tr><td valign=top nowrap>&nbsp; <b><i>a</i></b><sub>1</sub>  &nbsp;</td><td>
 Partition symbol.
 </td></tr>
<tr><td valign=top nowrap>&nbsp; <b><i>z</i></b>  &nbsp;</td><td>
 <i>k</i>th component of the chained representation of <b><i>x</i></b>
 exclusive of the terminal partition symbol.
 </td></tr>
<tr><td valign=top nowrap>&nbsp; <i>d</i> &nbsp;</td><td>
 Dimension of <b><i>z</i></b> in <b>&pi;</b>.
 </td></tr>
</table></td></tr></table>
<p align=center><b>Legend</b></p>
</td></tr></table>

<p align=center><b>Program 3.6</b> Determination of 
<tt><b>⍴</b></tt>(<b><i>x</i></b><sub><i>k</i></sub>)
from a chained representation of <b><i>x</i></b> <br>
with terminal partitions <b><i>a</i></b><sub>1</sub></p>

<table><tr><td>&nbsp;</td><td>
<p><b>Program 3.6</b>. The program is similar to Program 3.4 
and the step numbering indicates the correspondences. 
The dimension <i>d</i> is so determined (steps 4a-d) 
as to exclude the terminal partition itself 
from the quantity <b><i>z</i></b> specified by step 5.
Since only the first column of the grid matrix is incorporated in the partitioned
representation, step 6 excises a prefix of dimension <i>g</i> 
rather than 2<i>g</i> as in Program 3.4.</p>
</td><td>&nbsp;</td></tr></table>



<a name="3.2.6"></a>
<p><b>Pools</b></p>

<p>Components of the physical vector <b>&pi;</b> 
in use for the representation of one quantity 
must not be allocated to the representation of some other quantity.
The <i>construction</i> of a chained representation 
therefore poses one problem
not encountered in its <i>use</i>, 
namely, the specification and observation of
restrictions on the availability 
of components of <b>&pi;</b>. 
The restrictions can conveniently be specified as a <i>pool</i>, 
consisting of the available components of <b>&pi;</b>. 
Each allocation made must then be reflected in a corresponding
change in the pool. 
Moreover, as each piece of data is deleted, 
the components allocated to it are returned to the pool.</p>

<p>If, as in Program 3.5, 
a pool is treated as a stack, 
then the component next taken from the pool 
is the component last added to it. 
The queue of components in the pool 
thus obeys a so-called <i>last in first out</i>, 
or LIFO discipline. 
The dimension in <b>&pi;</b> 
of the last component of a pool will not, 
in general, agree with the dimension required 
for the next quantity it is called on to represent. 
If it exceeds the requirements, 
the extra segment may be left in the pool, 
and the pool therefore tends to accrue 
more and more components 
of smaller and smaller dimension. 
Hence it may be wise, or even essential, 
to revise the pool occasionally 
so as to coalesce the segments
into the smallest possible number of infixes. 
This process can even be extended to allow substitutions 
in other vectors in order to return to the pool short segments 
which may unite existing segments of the pool. 
This, however, will require 
a systematic scan of the chained vectors.</p>

<p>If the dimension of the last component 
(or perhaps of all components)
of the pool falls short 
of the requirements for representing a new quantity,
segments of the pool can be chained together. 
This requires the use of a
special partition symbol or other indication 
to distinguish two types of links, 
one which marks the end of a given representation 
and one which does not. 
More generally, it may be convenient to use multilevel partition
symbols to distinguish several levels of links, 
as was suggested for the representation of a matrix.</p>

<p>Queue disciplines other than LIFO may be used. 
Three other types of primary interest in allocation queues 
are the FIFO (first in first out), 
the <i>dimension-ordered</i>, 
and the <i>address-ordered</i> disciplines. 
FIFO uses a forward chain and may be preferred over LIFO 
because it uses the entire original pool 
before using any returned (and usually shorter) segments.</p>

<p>The components of a dimension-ordered pool 
are maintained in ascending (or descending) order 
on their dimensions in <b>&pi;</b>. 
This arrangement is convenient in selecting 
a pool element according to the dimension required. 
The components of an address-ordered pool are arranged in
ascending order on their leading addresses. 
This arrangement facilitates the fusion of components 
which together form an infix of <b>&pi;</b>.</p>

<p>If each of the available components 
of <b>&pi;</b> is set to a special value 
which is used for no other purpose, 
then the available components can be
determined by a scan of <b>&pi;</b>. 
Such a pool has no structure imposed by
chaining and will be called a <i>marked pool</i>.</p>

<p>A marked pool requires little maintenance, 
since components returned
to it are simply marked, 
but selection from it requires a scan of <b>&pi;</b> 
and is therefore relatively slow. 
The use of marked and chained pools may also
be combined&mdash;all returned components 
go to a marked pool which is left undisturbed 
until the chained pool is exhausted, 
at which time the entire marked pool 
is organized into a chained pool.</p>



<a name="3.2.7"></a>
<p><b>Summary</b></p>

<p>Since any structured operand 
can first be reduced to an equivalent vector, 
the problems of representation can be discussed 
in terms of vectors alone. 
The characteristics of the linear, chained, 
and partitioned representations
of a vector may be summarized as follows. 
A linear representation permits the address 
of any component to be computed directly 
as a linear function of its indices 
and hence requires no scanning of the vector.
However, the strict limitations 
which it imposes on allocation may engender:
(1) conflicts with allocations for other operands, 
(2) waste of storage due to the imposition 
of a common dimension in <b>&pi;</b> 
for all components, or
(3) uneconomical execution due to 
the extensive reallocations occasioned
by the insertion or deletion 
of other than terminal components.</p>

<p>The concept of the grid matrix is helpful 
even when the corresponding
allocation is implicit in the program. 
The explicit use of a grid matrix
which is itself in a linear representation 
removes the restrictions on the allocation 
of the vector itself while retaining the advantage 
of direct address computation. 
The address computation differs 
from the linear case only in the addition 
of a single reference to the grid matrix 
and hence requires no scanning. 
The difficulties enumerated for the direct linear
representation are not eliminated 
but merely shifted to the linearly
represented grid matrix itself, 
where they may, however, prove much less serious.</p>

<p>A chained representation allows 
virtually arbitrary allocation, 
relatively simple operations 
for the insertion and deletion of components, 
the direct representation of more complex structures 
such as trees, 
and economical joint representations of vectors 
which have one or more components in common. 
However, a chained representation 
requires extra storage for the grid matrix 
which it incorporates and occasions additional operations
for scanning when the components 
are selected in other than serial order.
The required scanning can be reduced 
by the retention of auxiliary information 
which allows the chained representation 
to be entered at several points.</p>

<p>A partitioned representation requires 
the allocation of a single infix of <b>&pi;</b>, 
and selection requires a fine scan, 
i.e., a component-by-component scan
of <b>&pi;</b> to detect partition symbols. 
Partitioning removes the need to incorporate 
the grid matrix explicitly and does not impose a common
dimension in <b>&pi;</b> for all components.</p>

<p>Mixed systems employing combinations 
of linear, chained, and partitioned
representations are frequently advantageous. 
Block chaining, for example, 
involves the chaining of blocks, 
each consisting of an infix of <b>&pi;</b>
and each serving as a linear representation 
of some infix of the represented vector. 
Alternatively, each chained block may be 
a partitioned representation of some infix.
<br>&nbsp;</p>



<a name="3.3"></a>
<p><b>3.3 Representation of matrices</b></p>

<p>Structured operands other than vectors 
may be represented by first
reducing them to equivalent vectors which can, 
by employing the techniques of the preceding section, 
be represented, in turn, in the physical vector <b>&pi;</b>. 
In the case of a matrix <b><i>A</i></b>, 
two alternative reductions are of interest, 
the row list 
<nobr><b><i>r</i></b> = <b><i>E</i></b>/<b><i>A</i></b></nobr> 
= <nobr><b><i>A</i></b><sup>1</sup> <img src="APLimg/circleplus.bmp"> 
<b><i>A</i></b><sup>2</sup> <img src="APLimg/circleplus.bmp"> &#133;
<img src="APLimg/circleplus.bmp"> <b><i>A</i></b><sup><i>&mu;</i></sup></nobr>
and the column list <b><i>c</i></b> = <b><i>E</i></b>//<b><i>A</i></b>. 
If <b><i>r</i></b><sub><i>h</i></sub>, 
<b><i>A</i></b><sub><i>j</i></sub><sup><i>i</i></sup>, 
and <b><i>c</i></b><sub><i>k</i></sub> 
are corresponding elements of the three
alternative representations, 
then in a 0-origin system:</p>

<table>
<tr><td width=75>&nbsp;</td><td><i>h</i> = <i>vi</i> + <i>j</i>,</td></tr>
<tr><td>&nbsp;</td><td><i>k</i> = <i>i</i> + <i>&mu;j</i>.</td></tr>
<tr><td colspan=2>Consequently,</td></tr>
<tr><td>&nbsp;</td><td><i>i</i> = <tt>⌊</tt><i>h</i> <tt>÷</tt> <i>&nu;</i><tt>&#8971;</tt> = <i>&mu;</i> |<sub>0</sub> <i>k</i>,</td></tr>
<tr><td>and</td><td><i>j</i> = <i>&nu;</i> |<sub>0</sub> h = <tt>⌊</tt><i>k</i> <tt>÷</tt> <i>&mu;</i><tt>&#8971;</tt>.</td></tr>
</table>

<p>The dependence of <i>h</i> on <i>k</i> 
can be obtained directly by substituting the
foregoing expressions in the identity</p>

<table>
<tr><td width=75>&nbsp;</td><td><i>h</i> = <i>&nu;</i> &times; <tt>⌊</tt><i>h</i> <tt>÷</tt> <i>&nu;</i><tt>&#8971;</tt> + <i>&nu;</i> |<sub>0</sub> <i>h</i></td></tr>
<tr><td>to yield</td><td><i>h</i> =  <i>&nu;</i> &times; (<i>&mu;</i> |<sub>0</sub> <i>k</i>) + <tt>⌊</tt><i>k</i> <tt>÷</tt> <i>&mu;</i><tt>&#8971;</tt>.</td></tr>
<tr><td>Similarly,</td><td><i>k</i> = <i>&mu;</i> &times; (<i>&nu;</i> |<sub>0</sub> <i>h</i>) + <tt>⌊</tt><i>h</i> <tt>÷</tt> <i>&nu;</i><tt>&#8971;</tt>.</td></tr>
</table>

<p>The permutation <b><i>h</i></b> 
which carries the row list <b><i>r</i></b> 
into the column list <b><i>c</i></b>
(that is, <b><i>c</i></b> = <b><i>h</i></b>&int;<sub>0</sub><b><i>r</i></b>) 
can be obtained directly 
from the foregoing expression for <b><i>h</i></b> as follows:</p>

<table>
<tr><td width=75>&nbsp;</td><td><b><i>h</i></b> = <i>&nu;</i> &times; 
 (<i>&mu;</i><tt><b>∊</b></tt> |<sub>0</sub> <tt><b>⍳</b></tt><sup>0</sup>) + 
 <tt>⌊</tt><tt><b>⍳</b></tt><sup>0</sup> <tt>÷</tt> <i>&mu;</i><tt><b>∊</b></tt><tt>&#8971;</tt>.
</td></tr>
</table>

<p>The expression for the <i>k</i>th component 
of <b><i>h</i></b> is identical with the expression
for <b><i>h</i></b> above. 
Hence, if <nobr><b><i>c</i></b> = 
<b><i>h</i></b>&int;<sub>0</sub><b><i>r</i></b>,</nobr> 
then 
<nobr><b><i>c</i></b><sub><i>k</i></sub> = 
<b><i>r</i></b><sub><b><i>h</i></b><sub><i>k</i></sub></sub> = 
<b><i>r</i></b><sub><i>h</i></sub></nobr> as required.</p>

<p>If the row list (or column list) 
is itself represented linearly, 
then the address of any component 
<b><i>A</i></b><sub><i>j</i></sub><sup><i>i</i></sup> 
is obtained as a linear function of the indices
<i>i</i> and <i>j</i>. 
If either a file or a chained representation 
is to be used for the list vector, 
then the components are processed most efficiently in serial order,
and the use of column list or row list 
is dictated by the particular processes to be effected.</p>

<p>If a large proportion of the elements 
of a matrix are null elements, 
it is called a <i>sparse</i> matrix. 
Sparse matrices occur frequently in numerical work 
(where zero serves as the null element), 
particularly in the treatment
of partial difference equations. 
A sparse matrix <b><i>A</i></b> can be represented
compactly by the row list 
<b><i>r</i></b> = <b><i>U</i></b>/<b><i>A</i></b>, 
and the logical matrix <b><i>U</i></b>, where
<b><i>U</i></b> = <nobr>(<b><i>A</i></b> &ne; 0).</nobr> 
The matrix <b><i>A</i></b> may then be obtained by expansion:
<b><i>A</i></b> = <b><i>U</i></b>\<b><i>r</i></b>.</p>

<p>Alternatively, the column list 
<nobr><b><i>c</i></b> = (<b><i>A</i></b> &ne; 0)//<b><i>A</i></b></nobr>
may be used. 
The transformation between the column list 
<b><i>c</i></b> and row list <b><i>r</i></b> must, 
in general, be performed as a sequential operation 
on the elements of <b><i>U</i></b>. 
Since it is frequently necessary to scan a given matrix 
in both row and column order
(e.g., as either pre- or post-multiplier 
in a matrix multiplication), 
neither the row list nor the column list alone 
is satisfactory. 
A chaining system can, however, 
be devised to provide both row and column scanning.</p>

<p>Let <b><i>L</i></b> be a matrix 
such that <b><i>L</i></b><sub>1</sub> 
is a list of the nonzero elements 
of a matrix <b><i>A</i></b> in arbitrary order, 
<b><i>L</i></b><sub>2</sub><sup><i>i</i></sup> 
is the column index in <b><i>A</i></b> of element 
<b><i>L</i></b><sub>1</sub><sup><i>i</i></sup>,
and <b><i>L</i></b><sub>3</sub><sup><i>i</i></sup> 
is the row index in <b><i>L</i></b> 
of the next nonzero element following 
<b><i>L</i></b><sub>1</sub><sup><i>i</i></sup>
in its row of <b><i>A</i></b>. 
If <b><i>L</i></b><sub>1</sub><sup><i>i</i></sup> 
is the last nonzero element in its row, 
<b><i>L</i></b><sub>3</sub><sup><i>i</i></sup> = <tt>∘</tt>.
Let <b><i>f</i></b><sub><i>j</i></sub>
be the row index in <b><i>L</i></b> 
of the first nonzero element of row 
<b><i>A</i></b><sup><i>j</i></sup>, 
and let <b><i>f</i></b><sub><i>j</i></sub> = <tt>∘</tt> 
if <b><i>A</i></b><sup><i>j</i></sup> = 0. 
The following example shows corresponding values of
<b><i>f</i></b>, <b><i>L</i></b>, and <b><i>f</i></b>&nbsp;:</p>

<table><tr><td width=75>&nbsp;</td>
<td><table>
<tr><td rowspan=5><b><i>A</i></b> =&nbsp;</td>
<td rowspan=5><img src="APLimg/matrixl5.bmp"></td>
<td>6 0 0 9</td>
<td rowspan=5><img src="APLimg/matrixr5.bmp"></td>
</tr>
<tr><td>0 3 0 0</td></tr>
<tr><td>0 0 0 0</td></tr>
<tr><td>7 8 0 4</td></tr>
<tr><td>0 0 5 0</td></tr>
</table></td><td>&nbsp; &nbsp;</td>
<td><table>
<tr><td rowspan=7><b><i>L</i></b> =&nbsp;</td>
<td rowspan=7><img src="APLimg/matrixl7.bmp"></td>
<td>8 2 7</td>
<td rowspan=7><img src="APLimg/matrixr7.bmp"></td>
</tr>
<tr><td>5 3 <tt>∘</tt></td></tr>
<tr><td>6 1 5</td></tr>
<tr><td>3 2 <tt>∘</tt></td></tr>
<tr><td>9 4 <tt>∘</tt></td></tr>
<tr><td>7 1 1</td></tr>
<tr><td>4 4 <tt>∘</tt></td></tr>
</table></td><td>&nbsp; &nbsp;</td>
<td><table>
<tr><td rowspan=5><b><i>f</i></b> =&nbsp;</td>
<td rowspan=5><img src="APLimg/matrixl5.bmp"></td>
<td>3</td>
<td rowspan=5><img src="APLimg/matrixr5.bmp"></td>
<td rowspan=5>.</td>
</tr>
<tr><td>4</td></tr>
<tr><td><tt>∘</tt></td></tr>
<tr><td>6</td></tr>
<tr><td>2</td></tr>
</table></td></tr>
</table>

<p>The matrix <b><i>L</i></b> will be called 
a <i>row-chained</i> representation of <b><i>A</i></b> 
and may be used, together with the vector <b><i>f</i></b>, 
for the efficient scanning 
of any row <b><i>A</i></b><sup><i>i</i></sup> 
as illustrated by Program 3.7. 
The vector <b><i>L</i></b><sub>3</sub> 
can be modified so as to give the
address in <b>&pi;</b> directly 
rather than the row index in <b><i>L</i></b> 
of the next element in the row, 
and Program 3.7 can then be easily re-expressed 
in terms of the physical vector <b>&pi;</b>.</p>

<!--
<table border=1 cellspacing=0 cellpadding=0><tr><td>
<table>
<tr><td nowrap>1<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td><sup>&nbsp;</sup> <b><i>A</i></b><sup><i>i</i></sup> &larr; 0 <sub>&nbsp;</sub></td></tr>
<tr><td>2<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td><sup>&nbsp;</sup> <i>k</i> &larr; <b><i>f</i></b><sub><i>i</i></sub> <sub>&nbsp;</sub></td></tr>
<tr><td>3<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td><sup>&nbsp;</sup> <i>k</i> :  <tt>∘</tt> <sub>&nbsp;</sub></td></tr>
<tr><td>4<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td><sup>&nbsp;</sup> <i>j</i> &larr; <b><i>L</i></b><sub>2</sub><sup><i>k</i></sup> <sub>&nbsp;</sub></td></tr>
<tr><td>5<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td nowrap><sup>&nbsp;</sup> <b><i>A</i></b><sub><i>j</i></sub><sup><i>i</i></sup> &larr; <b><i>L</i></b><sub>1</sub><sup><i>k</i></sup> <sub>&nbsp;</sub></td></tr>
<tr><td>6<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td><sup>&nbsp;</sup> <i>k</i> &larr; <b><i>L</i></b><sub>3</sub><sup><i>k</i></sup> <sub>&nbsp;</sub></td></tr>
</table>
</td></tr></table>
-->

<table><tr><td><img src="APLimg/prog3x7.bmp"></td>
<td>&nbsp; &nbsp;</td><td><table border=1 cellspacing=0 cellpadding=0>
<tr><td align=center>1-origin indexing</td></tr>
<tr><td><table>
<tr><td valign=top nowrap>&nbsp; <b><i>f</i></b><sub><i>i</i></sub> <sup>&nbsp;</sup></td>
 <td>Row index in <b><i>L</i></b> 
 of first nonzero element of row <b><i>A</i></b><sup><i>i</i></sup>.
 <nobr><b><i>f</i></b><sub><i>i</i></sub> = <tt>∘</tt></nobr> 
 if <nobr><b><i>A</i></b><sup><i>i</i></sup> = 0.</nobr>
 </td></tr>
<tr><td valign=top nowrap>&nbsp; <i>k</i> &nbsp;</td>
 <td>Row index in <b><i>L</i></b> of next element.
 </td></tr>
<tr><td valign=top nowrap>&nbsp; <b><i>L</i></b><sub>1</sub> &nbsp;</td>
 <td>List of nonzero elements of <b><i>A</i></b>.
 </td></tr>
<tr><td valign=top nowrap>&nbsp; <b><i>L</i></b><sub>2</sub><sup><i>k</i></sup> &nbsp;</td>
 <td>Column index in <b><i>A</i></b> 
 of <b><i>L</i></b><sub>1</sub><sup><i>k</i></sup>.
 </td></tr>
<tr><td valign=top nowrap>&nbsp; <b><i>L</i></b><sub>3</sub><sup><i>k</i></sup> &nbsp;</td>
 <td>Row index in<sub>&nbsp;</sub><b><i>L</i></b><sup>&nbsp;</sup>of next nonzero element 
 following <b><i>L</i></b><sub>1</sub><sup><i>k</i></sup> 
 in its row in <b><i>A</i></b>. 
 <nobr><b><i>L</i></b><sub>3</sub><sup><i>k</i></sup> = 
 <tt>∘</tt></nobr> if no such element exists.
 </td></tr>
</table></td></tr></table>
<p align=center><b>Legend</b></p></td></tr>
</table>

<p align=center><b>Program 3.7</b> Determination of the row vector 
<b><i>A</i></b><sup><i>i</i></sup><br>
from a row-chained representation of <b><i>A</i></b></p>

<table><tr><td>&nbsp;</td><td>
<p><b>Program 3.7</b>. Step 2 yields the index in <b><i>L</i></b> 
of the first element of the <i>i</i>th row of <b><i>A</i></b>.
Step 4 determines its column index <i>j</i>, 
and step 6 determines the index of the succeeding component. 
The process terminates at step 3 
when the scan of the row is completed.</p>
</td><td>&nbsp;</td></tr></table>

<p>If <b><i>L</i></b><sub>1</sub> is chosen as a row list, 
the vector <b><i>L</i></b><sub>3</sub> 
reduces to the form 
<nobr><b><i>L</i></b><sub>3</sub><sup><i>k</i></sup> = <i>k</i> + 1</nobr>
or 
<nobr><b><i>L</i></b><sub>3</sub><sup><i>k</i></sup> = <tt>∘</tt>.</nobr>
Its function can then be served instead 
by incrementation of
the index <i>k</i> and by the use of the logical vector 
<b><i>u</i></b> = (<b><i>L</i></b><sub>3</sub><sup><i>k</i></sup> = 
<tt>∘</tt><tt><b>∊</b></tt>) 
for determining the end of each row.</p>

<p>The construction of a column-chained representation 
is analogous to that of a row-chained representation, 
and the two representations 
can be combined in a single matrix 
<b><i>L</i></b> which gives 
both row and column chaining 
employing but a single representation 
(that is, <b><i>L</i></b><sub>1</sub>) 
of the nonzero elements of <b><i>A</i></b>.
<br>&nbsp;</p>



<a name="3.4"></a>
<p><b>3.4 Representation of trees</b><sup><a href="APL1.htm#note3b">[b]</a></sup></p>

<p>A tree <b><i>T</i></b> may be represented 
by a matrix and hence, in turn, by a vector
in a number of useful ways as follows:</p>

<table>
<tr><td>1.</td><td>
by a full right list matrix ]<b><i>T</i></b> 
or by any column permutation thereof (Sec. 1.23),
 </td></tr>
<tr><td>2.</td><td>
by a full left list matrix [<b><i>T</i></b> 
or by any column permutation thereof,
 </td></tr>
<tr><td>3. <sup>&nbsp;</sup></td><td>
by a right list matrix <tt><b>⍺</b></tt><sup>2</sup>/]<b><i>T</i></b>,
 </td></tr>
<tr><td>4. <sup>&nbsp;</sup></td><td>
by a left list matrix <tt><b>⍺</b></tt><sup>2</sup>/[<b><i>T</i></b>,
 </td></tr>
<tr><td>5.</td><td>
by various chain list matrices.
 </td></tr>
</table>

<p>The full left and right lists seldom 
prove more convenient than the more
concise left and right lists. 
Except for the special case of a homogeneous tree, 
both the right list and the left list 
are awkward to use for path tracing.
This function is better served by the chain list matrix, 
to be defined as a formalization 
of the chaining scheme suggested in Sec. 3.2.</p>



<a name="3.4.1"></a>
<p><b>Simplified list matrices</b></p>

<p>In certain important special cases, 
the various list representations 
of trees may be simplified. 
If the degree of each node 
is a known function <i>&delta;</i>
of the value of the node, 
then for any list matrix 
<b><i>M</i></b>, 
<nobr><b><i>M</i></b><sub>1</sub><sup><i>i</i></sup> = 
<i>&delta;</i>(<b><i>M</i></b><sub>2</sub><sup><i>i</i></sup>),</nobr> 
and the degree vector <b><i>M</i></b><sub>1</sub> 
may be eliminated without loss. 
The node vector alone then represents
the tree and may be referred to as a
<i>right</i> or <i>left list vector</i> as the case may be.</p>

<p align=center><img src="APLimg/fig3x8.bmp"></p>

<p align=center><b>Figure 3.8</b> 
The compound logical statement 
<img src="APLimg/xoscore.bmp"> <tt>∧</tt> (<i>y</i> &or; <i>z</i>)</p>

<p>For example, in the tree of Fig. 3.8
(which represents the compound logical statement 
<nobr><img src="APLimg/xoscore.bmp"> 
<tt>∧</tt> (<i>y</i> &or; <i>z</i>)),</nobr> 
a fixed degree is associated with each of the logical operators
<i>and</i>, <i>or</i>, and <i>not</i> 
(namely, 2, 2, and 1), and the
degree zero is associated with each of the variables.
The statement can therefore be represented 
unambiguously by the left list vector</p>

<table>
<tr><td width=75>&nbsp;</td>
<td><b><i>v</i></b> = (&and;, <tt>¯</tt>, <i>x</i>, &or;, <i>y</i>, <i>z</i>).</td></tr>
</table>

<p>This is the so-called <i>Lukasiewicz</i>, <i>Polish</i>, 
or <i>parenthesis-free</i> form of the
compound statement 
[<acronym title="Lukasiewicz, Jan, (1951), 
Aristotle’s Syllogistic from the Standpoint of Modern Formal Logic, 
Clarendon Press, Oxford, England, p. 78.">Lukasiewicz (1951)</acronym> and 
<acronym title="Burks, A.W., D.W. Warren, and J.B. Wright, (1954), 
“An Analysis of a Logical Machine Using Parenthesis-free Notation”, 
Mathematical Tables and Other Aids to Computation, 
vol. VIII, pp. 53-57. ">Burks et al. (1954)</acronym>].
Frequently, the only significant nodes 
of a tree <b>T</b> are its leaves 
(e.g., in Example 3.2 and in a certain key transformation 
of Fig. 4.7) and all other
nodes may be considered as nulls. 
Hence if <b><i>M</i></b> is any list matrix, the
significant portions of <b><i>M</i></b><sub>1</sub> 
and <b><i>M</i></b><sub>2</sub> 
are <nobr>(<b><i>M</i></b><sub>1</sub> &ne; 0)/<b><i>M</i></b><sub>1</sub></nobr> and 
<nobr>(<b><i>M</i></b><sub>1</sub> = 0)/<b><i>M</i></b><sub>2</sub></nobr>,
respectively. These significant portions may then be coalesced to form the
single vector</p>

<table>
<tr><td width=75>&nbsp;</td>
<td><b><i>v</i></b> = /<b><i>M</i></b><sub>1</sub>, (<b><i>M</i></b><sub>1</sub> = 0), <b><i>M</i></b><sub>2</sub>/,</td></tr>
</table>

<p>which, together with the logical vector 
<nobr>(<b><i>M</i></b><sub>1</sub> = 0),</nobr>
forms a <i>leaf list matrix</i>
that describes the tree. 
Moreover, if the values of the leaves are distinguishable
from the components of the degree vector, the logical vector
<nobr>(<b><i>M</i></b><sub>1</sub> = 0)</nobr> 
may also be dropped.</p>



<a name="3.4.2"></a>
<p><b>The use of left lists</b></p>

<p>The use of the right list matrix 
is illustrated by the repeated selection sort 
treated in Sec. 6.4. 
The use of left lists will be illustrated here by two examples, 
each of interest in its own right: 
the partitioning of the left list of an <i>n</i>-tuply rooted tree 
to yield the left lists of the component singular subtrees 
and the construction of a Huffman minimum-redundancy prefix code.</p>

<!--
<table border=1 cellspacing=0 cellpadding=0><tr><td>
<table>
<tr><td nowrap>1<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td><sup>&nbsp;</sup> <b><i>p</i></b> &larr; <tt><b>∊</b></tt>(0) <sub>&nbsp;</sub></td></tr>
<tr><td>2<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td><sup>&nbsp;</sup> <i>i</i> &larr; 0 <sub>&nbsp;</sub></td></tr>
<tr><td>3<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td><sup>&nbsp;</sup> <i>i</i> : <i>&mu;</i>(<b><i>Z</i></b>) <sub>&nbsp;</sub></td></tr>
<tr><td>4<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td><sup>&nbsp;</sup> <i>m</i> &larr; 0 <sub>&nbsp;</sub></td></tr>
<tr><td>5<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td><sup>&nbsp;</sup> <i>r</i> &larr; 0 <sub>&nbsp;</sub></td></tr>
<tr><td>6<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td><sup>&nbsp;</sup> <i>i</i> : <i>&mu;</i>(<b><i>Z</i></b>) <sub>&nbsp;</sub></td></tr>
<tr><td>7<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td><sup>&nbsp;</sup> <i>i</i> &larr; <i>i</i> + 1 <sub>&nbsp;</sub></td></tr>
<tr><td>8<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td><sup>&nbsp;</sup> <i>m</i> &larr; <i>m</i> + 1 <sub>&nbsp;</sub></td></tr>
<tr><td>9<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td nowrap><sup>&nbsp;</sup> <i>r</i> &larr; <i>r</i> + 1 &ndash; <b><i>Z</i></b><sub>1</sub><sup><i>i</i></sup> <sub>&nbsp;</sub></td></tr>
<tr><td>10<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td><sup>&nbsp;</sup> <i>r</i> : 1 <sub>&nbsp;</sub></td></tr>
<tr><td>11<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td><sup>&nbsp;</sup> <b><i>p</i></b> &larr; <b><i>p</i></b> <img src="APLimg/circleplus.bmp"> (<i>m</i>) <sub>&nbsp;</sub></td></tr>
</table>
</td></tr></table>
-->

<table><tr><td><img src="APLimg/prog3x9.bmp"></td><td>&nbsp; &nbsp; &nbsp;</td>
<td><table border=1 cellspacing=0 cellpadding=0>
<tr><td align=center>1-origin indexing</td></tr>
<tr><td><table>
<tr><td valign=top nowrap><b><i>Z</i></b> &nbsp;</td><td>
 Given left list of <b>T</b>.
 </td></tr>
<tr><td valign=top><i>i</i> &nbsp;</td><td>
 Row index of <b><i>Z</i></b> in ascending scan.
 </td></tr>
<tr><td valign=top><i>r</i> &nbsp;</td><td>
Indicated number of roots of current rooted subtree.
 </td></tr>
<tr><td valign=top nowrap><i>m</i> &nbsp;</td><td>
 Moment of current rooted subtree.
 </td></tr>
<tr><td valign=top><b><i>p</i></b> &nbsp;</td><td>
 Partition vector of <b><i>Z</i></b>, that is,
 <b><i>p</i></b><sub><i>j</i></sub> = <i>&mu;</i>(<b>T</b><sub><i>j</i></sub>).
 </td></tr>
</table></td></tr>
</table>
<p align=center><b>Legend</b></p>
</td></tr>
</table>

<p align=center><b>Program 3.9</b> 
Partitioning of the left list of an <i>n</i>-tuply rooted tree</p>

<table><tr><td>&nbsp;</td><td>
<p><b>Example 3.1. Partitioning of an <i>n</i>-tuply rooted tree.</b> 
Program 3.9 shows a scheme 
for partitioning a left list <b><i>Z</i></b> of a tree <b>T</b> 
into component subtrees, 
i.e., for determining the vector <b><i>p</i></b> 
such that <b><i>p</i></b><sub><i>j</i></sub> 
is the moment of the singular subtree 
<b>T</b><sub><i>j</i></sub>.
Thus <i>&nu;</i>(<b><i>p</i></b>) = <b>&mu;</b><sub>1</sub>(<b>T</b>), 
<b><i>p</i></b><sub><i>j</i></sub> = <i>&mu;</i>(<b>T</b><sub><i>j</i></sub>), 
and the infix 
<nobr>((<b><i>p</i></b> <img src="APLimg/plustimes.bmp"> 
<b><i>a</i></b><sup><i> j</i>&ndash;1</sup>) &darr; 
<b><i>a</i></b><sup><b><i> p</i></b><sub><i>j</i></sub></sup>)//<b><i>Z</i></b></nobr>
is the left list
of <b>T</b><sub><i>j</i></sub>.</p>

<p>The loop 6-10 scans successive components 
of the degree vector <b><i>Z</i></b><sub>1</sub> 
(in ascending order) and computes <b><i>r</i></b>, 
the indicated number of roots. 
The value of <b><i>r</i></b> increases
by, at most, one per iteration, 
and when <b><i>r</i></b> becomes unity, 
the end of a singly rooted tree has been reached. 
Its moment <i>m</i> is then appended (step 11) 
as a new final component of the partition vector <b><i>p</i></b>, 
the parameters <i>m</i> and <i>r</i> are reset,
and the scan of the next rooted tree is begun. 
Normal termination occurs at step 3; 
termination at step 6 indicates ill formation of <b><i>Z</i></b>.</p>
</td><td>&nbsp;</td></tr></table>
<br>

<table align=center>
<tr><td><img src="APLimg/fig3x10.bmp"></td></tr>
</table>

<p align=center><b>Figure 3.10</b> Construction of a Huffman prefix code</p>

<table><tr><td>&nbsp;</td><td>
<p><b>Example 3.2. Huffman minimum redundancy prefix code.</b> 
If <b><i>b</i></b> is any set 
such that <i>&nu;</i>(<b><i>b</i></b>) &gt; 1, 
then any other finite set <b><i>a</i></b> 
can be encoded in <b><i>b</i></b>, 
that is, represented by <b><i>b</i></b>. 
(The sets <b><i>a</i></b> and <b><i>b</i></b> 
may be called the &ldquo;alphabet&rdquo; 
and &ldquo;basic alphabet&rdquo;, respectively.) 
If <i>&nu;</i>(<b><i>a</i></b>) <tt>≤</tt> <i>&nu;</i>(<b><i>b</i></b>), 
the encoding may be described by a mapping vector <b><i>k</i></b> 
such that <tt><b>⍴</b></tt>(<b><i>a</i></b><sub><i>i</i></sub>) = 
<b><i>b</i></b><sub><b><i>k</i></b><sub><i>i</i></sub></sub>. 
If <i>&nu;</i>(<b><i>a</i></b>) &gt; <i>&nu;</i>(<b><i>b</i></b>), 
then each <b><i>a</i></b><sub><i>i</i></sub> 
must be represented by a vector 
<b><i>x</i></b><sup><i>i</i></sup> <tt>⊆</tt> <b><i>b</i></b>. 
For example, if <b><i>a</i></b> = <tt><b>⍳</b></tt><sup>0</sup>(10) 
and <b><i>b</i></b> = <tt><b>⍳</b></tt><sup>0</sup>(2), 
then the decimal digits <b><i>a</i></b> 
may be encoded in the so-called 8421 system:</p>

<table>
<tr><td width=75>&nbsp;</td><td>(2 <tt><b>∊</b></tt>(4)) <tt>⊥</tt> 
<b><i>x</i></b><sup><i>i</i></sup> = <b><i>a</i></b><sub><i>i</i></sub>
</td></tr>
</table>

<p>In so-called fixed length coding 
the vectors <b><i>x</i></b><sup><i>i</i></sup> 
have a common dimension <i>d</i>, 
and the decoding of a message <i>m</i> 
(consisting of the catenation 
of vectors <b><i>x</i></b><sup><i>i</i></sup>) 
involves the selection of successive infixes 
of dimension <i>d</i>. 
If the probability distribution of 
the characters <b><i>a</i></b><sub>1</sub> 
occurring in messages is not uniform, 
more compact encoding may be achieved 
by using variable length codes 
and assigning the shorter codes to
the more frequent characters. 
Decoding of a message in variable length coding
can be performed only if the boundaries 
between the successive <b><i>x</i></b><sup><i>i</i></sup> 
are indicated in some way.</p>

<p>The boundaries between characters in a message 
in variable length code may be demarked 
by special partition symbols 
(which is inefficient) 
or by using a <i>prefix</i> code 
in which no legitimate 
<i>code point</i> <b><i>x</i></b><sup><i>i</i></sup> 
is the prefix of any other legitimate code point, 
including itself. 
The index vectors of the leaves of any tree possess this property; 
conversely, any set of prefix codes 
can be arrayed as the leaves of some tree. 
Hence if each character of the set to be encoded 
is assigned as the leaf of a common tree, 
and if each character is encoded by the associated index vector,
a so-called prefix code is attained. 
Figure 3.10 furnishes an example of a binary code 
(i.e., the branching ratios do not exceed two) 
constructed in this manner.
0-origin indexing is used. 
The discussion will be limited to binary trees.</p>

<p>If <b><i>f</i></b><sub><i>i</i></sub> 
is the frequency of the <i>i</i>th character 
and <b><i>l</i></b><sub><i>i</i></sub> 
is the length of the assigned code
(i.e., the length of path to the root), 
then the most efficient code is attained by
minimizing the scalar product 
<nobr><b><i>f</i></b> <img src="APLimg/plustimes.bmp"> <b><i>l</i></b>.</nobr> 
This may be achieved by the following construction,
shown to be optimal by 
<acronym title="Huffman, D.A., (1952), 
“A Method for the Construction of Minimum Redundancy Codes”, 
Proc. IRE, vol. 40, pp. 1098-1101.">Huffman (1952)</acronym>. 
First, the characters to be
encoded are all considered as roots, 
and the two roots of lowest frequency 
are rooted to an auxiliary node 
(shown as a null element in Fig. 3.10), 
which is then assigned their combined frequency. 
The process is repeated until only two roots remain. 
The tree of Fig. 3.10 is optimal 
with respect to the frequencies shown to
the left of the leaves. 
The appropriate combined frequencies are shown to the left
of each of the nonleaves.</p>

<p>Programs 3.11 and 3.12 show the construction 
of the tree <b>T</b> representing a Huffman code 
for a set of characters 
<b><i>c</i></b><sub><i>i</i></sub> 
with frequencies 
<b><i>f</i></b><sub><i>i</i></sub> 
the former in terms of the tree itself 
and the latter in terms of its left list.</p>
</td><td>&nbsp;</td></tr></table>
<br>

<!--
<table border=1 cellspacing=0 cellpadding=0><tr><td>
<table>
<tr><td nowrap>1<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td><sup>&nbsp;</sup> <b>T</b> &larr; <b><i>c</i></b> <sub>&nbsp;</sub></td></tr>
<tr><td>2<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td><sup>&nbsp;</sup> <b>&mu;</b><sub>1</sub>(<b>T</b>) : 2 <sub>&nbsp;</sub></td></tr>
<tr><td>3<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td><sup>&nbsp;</sup> <b>T</b> &larr; (<i>&theta;</i>/<b><i>f</i></b> )&int;<b>T</b> <sub>&nbsp;</sub></td></tr>
<tr><td>4<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td><sup>&nbsp;</sup> <b>T</b> &larr; \\(<tt>∘</tt>) <img src="APLimg/circleplus.bmp">
 <tt><b>⍺</b></tt><sup>2</sup>//<b>T</b>, <img src="APLimg/alphaboscore.bmp"><sup>1</sup>,  
 <img src="APLimg/alphaboscore.bmp"><sup>2</sup>//<b>T</b>\\ <sub>&nbsp;</sub></td></tr>
<tr><td>5<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td nowrap><sup>&nbsp;</sup> <b><i>f</i></b> &larr; (<i>&theta;</i>/<b><i>f</i></b>) &int; <b><i>f</i></b> <sub>&nbsp;</sub></td></tr>
<tr><td>6<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td><sup>&nbsp;</sup> <b><i>f</i></b> &larr; 
 \+/<tt><b>⍺</b></tt><sup>2</sup>/<b><i>f</i></b>, 
 <img src="APLimg/alphaboscore.bmp"><sup>1</sup>,
 <img src="APLimg/alphaboscore.bmp"><sup>2</sup>/<b><i>f</i></b> \ <sub>&nbsp;</sub></td></tr>
</table>
</td></tr></table>
-->

<table align=center><tr><td>
<img src="APLimg/prog3x11.bmp">
</td></tr></table>

<p align=center><b>Program 3.11</b> Construction of the binary Huffman code <b>T</b><br> 
for characters <b><i>c</i></b> with frequency <b><i>f</i></b></p>

<table><tr><td>&nbsp;</td><td>
<p><b>Program 3.11</b>. The frequency vector <b><i>f</i></b> 
is permuted (step 5) to bring it to ascending order, 
and the tree is subjected (step 3) to the same permutation. 
Step 4 replaces the first two rooted subtrees of <b>T</b> 
by the single subtree obtained by rooting them in a null, 
and step 6 makes the corresponding alterations 
in the frequency vector. 
The tree is initialized (step 1) 
as a one-level tree whose roots
are the given characters, 
and the process terminates when the number of roots of
<b>T</b> has been reduced to two.</p>
</td><td>&nbsp;</td></tr></table>
<br>

<!--
<table border=1 cellspacing=0 cellpadding=0><tr><td>
<table>
<tr><td nowrap>1<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td><sup>&nbsp;</sup> <b><i>z</i></b> &larr; <b><i>c</i></b> <sub>&nbsp;</sub></td></tr>
<tr><td>2<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td nowrap><sup>&nbsp;</sup> <b><i>p</i></b> &larr; <tt><b>∊</b></tt>(<i>&nu;</i>(<b><i>z</i></b>)) <sub>&nbsp;</sub></td></tr>
<tr><td>3<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td><sup>&nbsp;</sup> <i>&nu;</i>( <b><i>f</i></b> ) : 2 <sub>&nbsp;</sub></td></tr>
<tr><td>4<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td><sup>&nbsp;</sup> <i>i</i> &larr; 1 <sub>&nbsp;</sub></td></tr>
<tr><td>5<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td nowrap><sup>&nbsp;</sup> <b><i>x</i></b> &larr; <tt><b>∊</b></tt>(0) <sub>&nbsp;</sub></td></tr>
<tr><td>6<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td><sup>&nbsp;</sup> <i>j</i> &larr; (<i>&theta;</i>/<b><i>f</i></b> )<sub><i>i</i></sub> <sub>&nbsp;</sub></td></tr>
<tr><td>7<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td nowrap><sup>&nbsp;</sup> <b><i>x</i></b> &larr; <b><i>x</i></b> 
 <img src="APLimg/circleplus.bmp"> ((( <b><i>p</i></b> <img src="APLimg/plustimes.bmp"> <tt><b>⍺</b></tt><sup><i> j</i>&ndash;1</sup>) 
 &darr; <tt><b>⍺</b></tt><sup> <b><i>p</i></b><sub><i>j</i></sub></sup>)/<b><i>z</i></b>)
 <sub>&nbsp;</sub></td></tr>
<tr><td>8<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td><sup>&nbsp;</sup> <i>i</i> &larr; <i>i</i> + 1 <sub>&nbsp;</sub></td></tr>
<tr><td>9<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td><sup>&nbsp;</sup> <i>i</i> : <i>&nu;</i>( <b><i>f</i></b> ) <sub>&nbsp;</sub></td></tr>
<tr><td>10<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td><sup>&nbsp;</sup> <b><i>z</i></b> &larr; (<tt>∘</tt>) <img src="APLimg/circleplus.bmp"> <b><i>x</i></b> <sub>&nbsp;</sub></td></tr>
<tr><td>11<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td><sup>&nbsp;</sup> <b><i>p</i></b> &larr; (<i>&theta;</i>/<b><i>f</i></b> ) &int; <b><i>p</i></b> <sub>&nbsp;</sub></td></tr>
<tr><td>12<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td><sup>&nbsp;</sup> <b><i>p</i></b> &larr;
 (1 + ( <b><i>p</i></b> <img src="APLimg/plustimes.bmp"> <tt><b>⍺</b></tt><sup>2</sup>))
 <img src="APLimg/circleplus.bmp"> <img src="APLimg/alphaboscore.bmp"><sup>2</sup>/<b><i>p</i></b>
  <sub>&nbsp;</sub></td></tr>
<tr><td>13<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td><sup>&nbsp;</sup> <b><i>f</i></b> &larr; (<i>&theta;</i>/<b><i>f</i></b> ) &int; <b><i>f</i></b> <sub>&nbsp;</sub></td></tr>
<tr><td nowrap>14<sup>&nbsp;</sup><sub>&nbsp;</sub></td><td><sup>&nbsp;</sup> <b><i>f</i></b> &larr;
 (+/<tt><b>⍺</b></tt><sup>2</sup>/<b><i>f</i></b> )
 <img src="APLimg/circleplus.bmp"> <img src="APLimg/alphaboscore.bmp"><sup> 2</sup>/<b><i>f</i></b> <sub>&nbsp;</sub></td></tr>
</table>
</td></tr></table>
-->

<table><tr><td>
<img src="APLimg/prog3x12.bmp"></td><td>&nbsp; &nbsp;</td><td>
<table border=1 cellspacing=0 cellpadding=0>
<tr><td align=center>1-origin indexing</td></tr>
<tr><td><table>
<tr><td valign=top><b><i>c</i></b></td><td>&nbsp;</td><td>Given character set.</td></tr>
<tr><td valign=top><b><i>z</i></b></td><td>&nbsp;</td><td>Left list of Huffman tree.</td></tr>
<tr><td valign=top><b><i>f</i></b><sub><i>i</i></sub></td><td>&nbsp;</td>
 <td>Frequency of <i>i</i>th subtree of <b><i>z</i></b>.</td></tr>
<tr><td valign=top><b><i>p</i></b></td><td>&nbsp;</td>
 <td>Partition vector <b><i>p</i></b><sub><i>i</i></sub> is
 the moment of the <i>i</i>th subtree of <b><i>z</i></b>.</td></tr>
<tr><td valign=top><b><i>x</i></b></td><td>&nbsp;</td>
 <td>Reordered left list with subtrees in ascending order on frequency.</td></tr>
</table></td></tr></table>
<p align=center><b>Legend</b></p>
<p align=center><b>Program 3.12</b> Construction of the left list <b><i>z</i></b><br> 
of the binary Huffman code 
for characters <b><i>c</i></b> with frequency <b><i>f</i></b></p>
</td></tr>
</table>
<br>

<table><tr><td>&nbsp;</td><td>
<p><b>Program 3.12</b>. The tree <b>T</b> of Program 3.11 is represented 
by the left list node vector <b><i>z</i></b>, 
in conjunction with the implicit degree vector 
<nobr><b><i>d</i></b> = 2 &times; (<b><i>z</i></b> = <tt>∘</tt><tt><b>∊</b></tt>).</nobr> 
The algorithm differs from Program 3.11 
primarily in the reordering of the subtrees (steps 6-9). 
Step 7 appends to <b><i>x</i></b> the left list 
of the ith subtree (of the reordered tree) 
selected by the partition vector <b><i>p</i></b> 
according to the conventions of Program 3.9. 
Step 1a prefixes <b><i>x</i></b> by the new null root, 
and steps 11-12 redefine <b><i>p</i></b> appropriately.</p>

<p>Program 1.21 can be applied to the left list 
produced by Program 3.12 to determine the associated index matrix 
(in a 0-origin system), and hence the actual codes assigned.</p>

<p>It is not essential that the characters 
be assigned to leaves in precisely the order
specified by Programs 3.11 and 3.12, 
and it is sufficient that the dimension 
of the leaf index increase monotonically 
with decreasing frequency of the character. 
It is therefore unnecessary to carry 
the characters themselves through the process;
it suffices to determine the structure of the tree, 
sort the corresponding index matrix to right list order 
(which is ordered on dimension of the index vectors),
and assign the characters (in decreasing order by frequency) 
to successive leaves.
Since the structure of such a tree 
(whose nodes have a common irrelevant value
and whose nonleaves all have a common branching ratio 
equal to the number of roots) 
is sufficiently determined by the moment vector 
<b>&mu;</b>(<b>T</b>), the process of Program
3.12 can be simplified.</p>
</td><td>&nbsp;</td></tr></table>



<a name="3.4.3"></a>
<p><b>Chain list matrices</b></p>

<p>The full chain list matrix of a tree <b>T</b> 
is a matrix <b><i>P</i></b> of dimension 
<nobr><i>&mu;</i>(<b>T</b>) &times; (<i>&delta;</i>(<b>T</b>) + 2)</nobr>
defined as follows: 
<b><i>P</i></b><sub>2</sub> is some node vector of <b>T</b>, 
<b><i>P</i></b><sub>1</sub> is the associated degree vector, 
<b><i>P</i></b><sub><i>j</i>+2</sub><sup><i>i</i></sup> 
is null if <i>j</i> exceeds the associated degree 
<b><i>P</i></b><sub>1</sub><sup><i>i</i></sup> 
and is otherwise the row index in <b><i>P</i></b> 
of the <i>j</i>th node emanating from node
<b><i>P</i></b><sub>2</sub><sup><i>i</i></sup>.
Table 3.13 shows a full chain list matrix 
for the tree of Fig. 1.16. 
A full chain list matrix is called 
a full <i>right</i> (<i>left</i>) chain list matrix 
if the nodes occur in right (left) list order.</p>

<table align=center><tr>
<td valign=top><table>
 <tr><td>&nbsp;</td></tr>
 <tr><td align=center>1</td></tr> <tr><td align=center>2</td></tr> <tr><td align=center>3</td></tr> <tr><td align=center>4</td></tr> <tr><td align=center>5</td></tr>
 <tr><td align=center>6</td></tr> <tr><td align=center>7</td></tr> <tr><td align=center>8</td></tr> <tr><td align=center>9</td></tr> <tr><td>10</td></tr>
 <tr><td>11</td></tr> <tr><td>12</td></tr> <tr><td>13</td></tr> <tr><td>14</td></tr> <tr><td>15</td></tr>
 <tr><td>16</td></tr> <tr><td>17</td></tr> <tr><td>18</td></tr> <tr><td>19</td></tr> <tr><td>20</td></tr>
 <tr><td>21</td></tr> <tr><td>22</td></tr> <tr><td>23</td></tr> <tr><td>24</td></tr> <tr><td>25</td></tr>
 <tr><td>26</td></tr> 
 </table></td>

<td>&nbsp; &nbsp;</td>

<td valign=top align=center><table border=1 cellspacing=0 cellpadding=0>
<tr><td align=center>&nbsp;<b><i>d</i></b>&prime;&nbsp;</td>
 <td align=center>&nbsp;<b><i>n</i></b>&prime;&nbsp;</td>
 <td colspan=4 align=center><b><i>Q</i></b></td></tr>
<tr>
 <td><table>
 <tr><td align=center>1</td></tr> <tr><td align=center>2</td></tr> <tr><td align=center>0</td></tr> <tr><td align=center>0</td></tr> <tr><td align=center>3</td></tr>
 <tr><td align=center>2</td></tr> <tr><td align=center>0</td></tr> <tr><td align=center>0</td></tr> <tr><td align=center>0</td></tr> <tr><td align=center>0</td></tr>
 <tr><td align=center>0</td></tr> <tr><td align=center>0</td></tr> <tr><td align=center>0</td></tr> <tr><td align=center>2</td></tr> <tr><td align=center>0</td></tr>
 <tr><td align=center>0</td></tr> <tr><td align=center>3</td></tr> <tr><td align=center>2</td></tr> <tr><td align=center>0</td></tr> <tr><td align=center>3</td></tr>
 <tr><td align=center>0</td></tr> <tr><td align=center>0</td></tr> <tr><td align=center>1</td></tr> <tr><td align=center>4</td></tr> <tr><td align=center>0</td></tr>
 <tr><td align=center>0</td></tr> 
 </table></td>
 <td><table>
 <tr><td align=center>n</td></tr> <tr><td align=center>g</td></tr> <tr><td align=center>u</td></tr> <tr><td align=center>t</td></tr> <tr><td align=center>a</td></tr>
 <tr><td align=center>b</td></tr> <tr><td align=center>v</td></tr> <tr><td align=center>k</td></tr> <tr><td align=center>z</td></tr> <tr><td align=center>o</td></tr>
 <tr><td align=center>f</td></tr> <tr><td align=center>r</td></tr> <tr><td align=center>y</td></tr> <tr><td align=center>s</td></tr> <tr><td align=center>d</td></tr>
 <tr><td align=center>j</td></tr> <tr><td align=center>m</td></tr> <tr><td align=center>i</td></tr> <tr><td align=center>w</td></tr> <tr><td align=center>h</td></tr>
 <tr><td align=center>e</td></tr> <tr><td align=center>p</td></tr> <tr><td align=center>x</td></tr> <tr><td align=center>c</td></tr> <tr><td align=center>q</td></tr>
 <tr><td align=center>l</td></tr> 
 </table></td>
 <td><table>
 <tr><td>18</td></tr> <tr><td>16</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>24</td></tr>
 <tr><td align=center>8</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr>
 <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td align=center>4</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr>
 <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td align=center>3</td></tr> <tr><td>22</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>10</td></tr>
 <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>13</td></tr> <tr><td>11</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr>
 <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> 
 </table></td>
 <td><table>
 <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>26</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td align=center>9</td></tr>
 <tr><td>20</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr>
 <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>19</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr>
 <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>14</td></tr> <tr><td>25</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>17</td></tr>
 <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>15</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr>
 <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> 
 </table></td>
 <td><table>
 <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td align=center>1</td></tr>
 <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr>
 <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr>
 <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>23</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td align=center>7</td></tr>
 <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>12</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr>
 <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> 
 </table></td>
 <td><table>
 <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr>
 <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr>
 <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr>
 <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr>
 <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>21</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr>
 <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> 
 </table></td>
</tr></table> 
 <p align=center>(a)<br>A full chain list matrix</p></td>

<td>&nbsp; &nbsp;</td>

<td valign=top align=center><table border=1 cellspacing=0 cellpadding=0>
<tr><td>&nbsp;<b><i>d</i></b>&Prime;&nbsp;</td>
 <td>&nbsp;<b><i>n</i></b>&Prime;&nbsp;</td>
 <td align=center>&nbsp;<b><i>p</i></b>&nbsp;</td></tr>
<tr>
 <td><table>
 <tr><td>3</td></tr> <tr><td>2</td></tr> <tr><td>2</td></tr> <tr><td>4</td></tr> <tr><td>0</td></tr>
 <tr><td>1</td></tr> <tr><td>0</td></tr> <tr><td>3</td></tr> <tr><td>0</td></tr> <tr><td>0</td></tr>
 <tr><td>0</td></tr> <tr><td>0</td></tr> <tr><td>0</td></tr> <tr><td>0</td></tr> <tr><td>2</td></tr>
 <tr><td>0</td></tr> <tr><td>3</td></tr> <tr><td>0</td></tr> <tr><td>0</td></tr> <tr><td>0</td></tr>
 <tr><td>0</td></tr> <tr><td>2</td></tr> <tr><td>1</td></tr> <tr><td>0</td></tr> <tr><td>0</td></tr>
 <tr><td>0</td></tr> 
 </table></td>
 <td><table>
 <tr><td align=center>a</td></tr> <tr><td align=center>b</td></tr> <tr><td align=center>g</td></tr> <tr><td align=center>c</td></tr> <tr><td align=center>z</td></tr>
 <tr><td align=center>n</td></tr> <tr><td align=center>k</td></tr> <tr><td align=center>h</td></tr> <tr><td align=center>j</td></tr> <tr><td align=center>l</td></tr>
 <tr><td align=center>f</td></tr> <tr><td align=center>d</td></tr> <tr><td align=center>r</td></tr> <tr><td align=center>e</td></tr> <tr><td align=center>i</td></tr>
 <tr><td align=center>o</td></tr> <tr><td align=center>m</td></tr> <tr><td align=center>v</td></tr> <tr><td align=center>p</td></tr> <tr><td align=center>q</td></tr>
 <tr><td align=center>u</td></tr> <tr><td align=center>s</td></tr> <tr><td align=center>x</td></tr> <tr><td align=center>t</td></tr> <tr><td align=center>w</td></tr>
 <tr><td align=center>y</td></tr> 
 </table></td>
 <td><table>
 <tr><td align=center>4</td></tr> <tr><td align=center>7</td></tr> <tr><td align=center>9</td></tr> <tr><td>11</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr>
 <tr><td>15</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>16</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr>
 <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>19</td></tr>
 <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>21</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr>
 <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>24</td></tr> <tr><td>26</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr>
 <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> 
 </table></td>
</tr></table> 
 <p align=center>(b)<br>The right chain<br>list matrix</p></td>
<td>&nbsp;</td>

<td valign=top align=center><table border=1 cellspacing=0 cellpadding=0>
<tr><td>&nbsp;<b><i>d</i></b>&prime;&nbsp;</td>
 <td>&nbsp;<b><i>n</i></b>&prime;&nbsp;</td>
 <td>&nbsp;<b><i>f</i></b>&nbsp;</td>
 <td>&nbsp;<b><i>h</i></b>&nbsp;</td></tr>
<tr>
 <td><table>
 <tr><td align=center>1</td></tr> <tr><td align=center>2</td></tr> <tr><td align=center>0</td></tr> <tr><td align=center>0</td></tr> <tr><td align=center>3</td></tr>
 <tr><td align=center>2</td></tr> <tr><td align=center>0</td></tr> <tr><td align=center>0</td></tr> <tr><td align=center>0</td></tr> <tr><td align=center>0</td></tr>
 <tr><td align=center>0</td></tr> <tr><td align=center>0</td></tr> <tr><td align=center>0</td></tr> <tr><td align=center>2</td></tr> <tr><td align=center>0</td></tr>
 <tr><td align=center>0</td></tr> <tr><td align=center>3</td></tr> <tr><td align=center>2</td></tr> <tr><td align=center>0</td></tr> <tr><td align=center>3</td></tr>
 <tr><td align=center>0</td></tr> <tr><td align=center>0</td></tr> <tr><td align=center>1</td></tr> <tr><td align=center>4</td></tr> <tr><td align=center>0</td></tr>
 <tr><td align=center>0</td></tr> 
 </table></td>
 <td><table>
 <tr><td align=center>n</td></tr> <tr><td align=center>g</td></tr> <tr><td align=center>u</td></tr> <tr><td align=center>t</td></tr> <tr><td align=center>a</td></tr>
 <tr><td align=center>b</td></tr> <tr><td align=center>v</td></tr> <tr><td align=center>k</td></tr> <tr><td align=center>z</td></tr> <tr><td align=center>o</td></tr>
 <tr><td align=center>f</td></tr> <tr><td align=center>r</td></tr> <tr><td align=center>y</td></tr> <tr><td align=center>s</td></tr> <tr><td align=center>d</td></tr>
 <tr><td align=center>j</td></tr> <tr><td align=center>m</td></tr> <tr><td align=center>i</td></tr> <tr><td align=center>w</td></tr> <tr><td align=center>h</td></tr>
 <tr><td align=center>e</td></tr> <tr><td align=center>p</td></tr> <tr><td align=center>x</td></tr> <tr><td align=center>c</td></tr> <tr><td align=center>q</td></tr>
 <tr><td align=center>l</td></tr> 
 </table></td>
 <td><table>
 <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>14</td></tr> <tr><td>19</td></tr> <tr><td align=center>6</td></tr>
 <tr><td align=center>2</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>20</td></tr> <tr><td align=center>1</td></tr> <tr><td>17</td></tr>
 <tr><td>15</td></tr> <tr><td>21</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>23</td></tr> <tr><td>12</td></tr>
 <tr><td>26</td></tr> <tr><td align=center>7</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr>
 <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>25</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td align=center>9</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr>
 <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> 
 </table></td>
 <td><table>
 <tr><td>18</td></tr> <tr><td>16</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>24</td></tr>
 <tr><td align=center>8</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr>
 <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td align=center>4</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr>
 <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td align=center>3</td></tr> <tr><td>22</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>10</td></tr>
 <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> <tr><td>13</td></tr> <tr><td>11</td></tr> <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr>
 <tr><td>&nbsp;<tt>∘</tt>&nbsp;</td></tr> 
 </table></td>
</tr></table> 
 <p align=center>(c)<br>Filial-heir chain list</p></td>

<td valign=top><table>
 <tr><td>&nbsp;</td></tr>
 <tr><td align=center>1</td></tr> <tr><td align=center>2</td></tr> <tr><td align=center>3</td></tr> <tr><td align=center>4</td></tr> <tr><td align=center>5</td></tr>
 <tr><td align=center>6</td></tr> <tr><td align=center>7</td></tr> <tr><td align=center>8</td></tr> <tr><td align=center>9</td></tr> <tr><td>10</td></tr>
 <tr><td>11</td></tr> <tr><td>12</td></tr> <tr><td>13</td></tr> <tr><td>14</td></tr> <tr><td>15</td></tr>
 <tr><td>16</td></tr> <tr><td>17</td></tr> <tr><td>18</td></tr> <tr><td>19</td></tr> <tr><td>20</td></tr>
 <tr><td>21</td></tr> <tr><td>22</td></tr> <tr><td>23</td></tr> <tr><td>24</td></tr> <tr><td>25</td></tr>
 <tr><td>26</td></tr> 
 </table></td>

</tr></table>

<p align=center><b>Table 3.13</b> Chain lists of the tree of Fig. 1.16</p>

<p>The full chain list matrix is a formalization 
of the scheme suggested 
in the discussion of chained representations (Sec. 3.2). 
Its convenience in forward path tracing is obvious. 
Since it does not identify the roots of the tree, 
an auxiliary vector must be provided for this purpose. 
However, if the ordering chosen for the nodes 
is that of a right list, 
the roots occur first in the list, 
their number 
<nobr><i>r</i> = <i>&nu;</i>(<b><i>P</i></b><sub>1</sub>) &ndash; 
(+/<b><i>P</i></b><sub>1</sub>)</nobr>
is specified by the degree vector <b><i>P</i></b><sub>1</sub>, 
and the need for the auxiliary vector vanishes. 
Moreover, since a right list groups all nodes emanating 
from a given node, each row of 
<nobr><img src="APLimg/alphaboscore.bmp"><sup>2</sup>/<b><i>P</i></b></nobr>
is simply a sequence of integers followed by null elements, 
and the information necessary to path tracing 
is provided by the column <b><i>P</i></b><sub>3</sub> alone.</p>

<p>The <i>right chain list matrix</i> of a tree <b>T</b> 
is therefore defined as 
<nobr><img src="APLimg/alphaboscore.bmp"><sup>3</sup>/<b><i>P</i></b>,</nobr>
where <b><i>P</i></b> is the full right chain list matrix of <b>T</b>. 
It is illustrated by Table 3.13b.
Program 3.14 shows its use in path tracing. 
Although the degree vector <b><i>P</i></b><sub>1</sub> is redundant 
(that is, <b><i>P</i></b><sub>1</sub> and <b><i>P</i></b><sub>3</sub> 
can be determined one from the other), 
it provides a direct check (step 6) on the legitimacy 
of the index vector <b><i>r</i></b>
which would be difficult to obtain from <b><i>P</i></b><sub>3</sub> alone.</p>

<p>For a search of the type described by Program 3.14, 
it is necessary to scan down a level 
until agreement is reached and then across to the next level. 
For this type of scan, 
the <i>filial-heir chain list</i> is compact and convenient.</p>

<!--
<table border=1 cellspacing=0 cellpadding=0>
<tr><td><table>
<tr><td>1</td><td>&nbsp;</td><td><sub>&nbsp;</sub> <i>k</i> &larr; 1 <sup>&nbsp;</sup></td></tr>
<tr><td>2</td><td>&nbsp;</td><td><sub>&nbsp;</sub> <i>j</i> &larr; 0 <sup>&nbsp;</sup></td></tr>
<tr><td>3</td><td>&nbsp;</td><td nowrap><sub>&nbsp;</sub> <i>d</i> &larr; <i>&nu;</i>(<b><i>P</i></b><sub>1</sub>) &ndash; +/<b><i>P</i></b><sub>1</sub> <sup>&nbsp;</sup></td></tr>
<tr><td>4</td><td>&nbsp;</td><td><sub>&nbsp;</sub> <i>j</i> : <i>&nu;</i>(<b><i>r</i></b>) <sup>&nbsp;</sup></td></tr>
<tr><td>5</td><td>&nbsp;</td><td><sub>&nbsp;</sub> <i>j</i> &larr; <i>j</i> + 1 <sup>&nbsp;</sup></td></tr>
<tr><td>6</td><td>&nbsp;</td><td><sub>&nbsp;</sub> <b><i>r</i></b><sub><i> j</i></sub> : <i>d</i> <sup>&nbsp;</sup></td></tr>
<tr><td>7</td><td>&nbsp;</td><td><sub>&nbsp;</sub> <i>i</i> &larr; <i>k</i> + <b><i>r</i></b><sub><i> j</i></sub> &ndash; 1 <sup>&nbsp;</sup></td></tr>
<tr><td>8</td><td>&nbsp;</td><td><sub>&nbsp;</sub> <b><i>p</i></b><sub><i> j</i></sub> &larr; <b><i>P</i></b><sub>2</sub><sup><i>i</i></sup> <sup>&nbsp;</sup></td></tr>
<tr><td>9</td><td>&nbsp;</td><td><sub>&nbsp;</sub> <i>d</i> &larr; <b><i>P</i></b><sub>1</sub><sup><i>i</i></sup> <sup>&nbsp;</sup></td></tr>
<tr><td>10</td><td>&nbsp;</td><td><sub>&nbsp;</sub> <i>k</i> &larr; <b><i>P</i></b><sub>3</sub><sup><i>i</i></sup> <sup>&nbsp;</sup></td></tr>
</table></td></tr>
</table>
-->

<table>
<tr><td valign=top><img src="APLimg/prog3x14.bmp"></td>
<td>&nbsp; &nbsp; &nbsp;</td>
<td><table border=1 cellspacing=0 cellpadding=0>
<tr><td align=center>1-origin indexing</td></tr>
<tr><td><table>
<tr><td valign=top>&nbsp;<b><i>r</i></b></td><td>&nbsp;</td><td>Given index vector.</td></tr>
<tr><td valign=top>&nbsp;<b><i>P</i></b></td><td>&nbsp;</td><td>Right chain list matrix of <b>T</b>.</td></tr>
<tr><td valign=top>&nbsp;<b><i>P</i></b><sub>1</sub></td><td>&nbsp;</td><td>Degree vector of <b>T</b>.</td></tr>
<tr><td valign=top>&nbsp;<b><i>P</i></b><sub>2</sub></td><td>&nbsp;</td><td>Node vector of <b>T</b>.</td></tr>
<tr><td valign=top>&nbsp;<b><i>P</i></b><sub>3</sub></td><td>&nbsp;</td><td>Chaining vector of <b>T</b>.</td></tr>
<tr><td valign=top>&nbsp;<b><i>p</i></b><sup>&nbsp;</sup></td><td>&nbsp;</td><td>Path vector <b>T</b><sup><b><i>r</i></b></sup>.</td></tr>
<tr><td valign=top>&nbsp;<i>d</i></td><td>&nbsp;</td><td>Degree of current node.</td></tr>
<tr><td valign=top>&nbsp;<i>k</i></td><td>&nbsp;</td><td>Base address of the infix containing the current node.</td></tr>
<tr><td valign=top>&nbsp;<i>i</i></td><td>&nbsp;</td><td>Index of succeeding node in the path <b>T</b><sup><b><i>r</i></b></sup>.</td></tr>
<tr><td valign=top>&nbsp;<i>j</i></td><td>&nbsp;</td><td>Current index of index vector <b><i>r</i></b>.</td></tr>
</table></td></tr></table>
<p align=center><b>Legend</b></p>
</td></tr></table>

<p align=center><b>Program 3.14</b> Determination of the path <b><i>p</i></b> 
= <b>T</b><sup><b><i>r</i></b></sup><br>
from the right chain list matrix <b><i>P</i></b></p>

<p>The set of (<i>j</i> + 1)th level nodes 
of the subtree <b>T</b><sub><b><i>i</i></b></sub> are collectively called
the <i>jth filial vector</i> of node <b><i>i</i></b>, 
and the first member of the first filial vector of
node <b><i>i</i></b> is called the <i>heir</i> of node <b><i>i</i></b>. 
(For brevity, the first filial vector of a
node will also be called its filial vector.) 
If each node is chained only to its successor 
in the filial vector containing it and to its heir, 
the resulting representation is called 
a <i>filial-heir chain list</i>. 
Formally, the filial-heir representation of a tree <b>T</b> 
is a matrix <b><i>F</i></b> of dimension 
<nobr><i>&mu;</i>(<b>T</b>) &times; 4</nobr>
such that <b><i>F</i></b><sub>2</sub> is a node vector of <b>T</b>, 
<b><i>F</i></b><sub>1</sub> is the associated degree vector, 
<b><i>F</i></b><sub>3</sub> is a <i>filial chain</i> 
such that <b><i>F</i></b><sub>3</sub><sup><i>i</i></sup> = <i>j</i> 
if node <b><i>F</i></b><sub>2</sub><sup><i>&nbsp;j</i></sup> 
is the successor of node 
<b><i>F</i></b><sub>2</sub><sup><i>i</i></sup> 
in the smallest filial set containing it and 
<b><i>F</i></b><sub>3</sub><sup><i>i</i></sup> = <tt>∘</tt> 
if node <b><i>F</i></b><sub>2</sub><sup><i>i</i></sup>
has no such successor, 
and <b><i>F</i></b><sub>4</sub> is an <i>heir chain</i> such that 
<b><i>F</i></b><sub>4</sub><sup><i>i</i></sup> = <i>h</i> 
if node <b><i>F</i></b><sub>2</sub><sup><i>h</i></sup> 
is the heir of node 
<b><i>F</i></b><sub>2</sub><sup><i>i</i></sup>
and 
<b><i>F</i></b><sub>4</sub><sup><i>i</i></sup> = <tt>∘</tt> 
if <b><i>F</i></b><sub>2</sub><sup><i>i</i></sup> is a leaf. 
The filial-heir chain list is illustrated in Table 3.13c.
<br>&nbsp;</p>



<a name="ref3"></a>
<p><b>References</b></p>

<table>
<tr><td valign=top nowrap>&#149; &nbsp;</td><td>
Blaauw, G. A., (1959), &ldquo;Indexing and Control-Word Techniques&rdquo;, 
<i>IBM Journal of Research and Development</i>, vol. 3, pp. 288-301.
 </td></tr>
<tr><td valign=top>&#149; &nbsp;</td><td>
Brooks, F.P., Jr., and K.E. Iverson, (1962), (in press) <i>Automatic Data Processing</i>,
Wiley, New York.
 </td></tr>
<tr><td valign=top>&#149; &nbsp;</td><td>
Burks, A.W., D.W. Warren, and J.B. Wright, (1954), 
&ldquo;An Analysis of a Logical Machine Using Parenthesis-free Notation&rdquo;, 
<i>Mathematical Tables and Other Aids to Computation</i>, vol. VIII, pp. 53-57.
 </td></tr>
<tr><td valign=top>&#149; &nbsp;</td><td>
Dewey, Godfrey, (1923), <i>Relative Frequency of English Speech Sounds</i>, 
Cambridge University Press, p. 185.
 </td></tr>
<tr><td valign=top>&#149; &nbsp;</td><td>
Huffman, D.A., (1952), &ldquo;A Method for the Construction of Minimum Redundancy
Codes&rdquo;, <i>Proc. IRE</i>, vol. 40, pp. 1098-1101.
 </td></tr>
<tr><td valign=top>&#149; &nbsp;</td><td>
Iverson, K.E., (1955), &ldquo;Report by the Staff of the Computation Laboratory to the
American Gas Association and Edison Electric Institute&rdquo;,
Section III, Report No.1, Harvard Computation Laboratory.
 </td></tr>
<tr><td valign=top>&#149; &nbsp;</td><td>
Johnson, L.R., (1962), &ldquo;On Operand Structure, Representation, Storage, and Search&rdquo;,
Research Report # RC-603, IBM Corp.
 </td></tr>
<tr><td valign=top>&#149; &nbsp;</td><td>
Lukasiewicz, Jan, (1951), 
<i>Aristotle&rsquo;s Syllogistic from the Standpoint of Modern Formal Logic</i>, 
Clarendon Press, Oxford, England, p. 78.
 </td></tr>
<tr><td valign=top>&#149; &nbsp;</td><td>
Marimont, R.B., (1959), 
&ldquo;A New Method of Checking the Consistency of Precedence Matrices&rdquo;, 
<i>J. ACM</i>, vol. 6, pp. 164-171.
 </td></tr>
<tr><td valign=top>&#149; &nbsp;</td><td>
Ross, I.C., and F. Harary, (1960), 
&ldquo;The Square of a Tree&rdquo;, 
<i>Bell System Tech. J.</i>, vol. XXXIX, pp. 641-8.
 </td></tr>
<tr><td valign=top>&#149; &nbsp;</td><td>
Shaw, J.C., A. Newell, H.A. Simon, and T.O. Ellis, (1958), 
&ldquo;A Command Structure for Complex Information Processing&rdquo;, 
<i>Proc. Western Joint Computer Conference</i>,
pp. 119-128.
 </td></tr>
</table>
<br>



<a name="notes3"></a>
<p><b>Notes</b></p>

<table>
<tr><td valign=top nowrap>a.<a name="note3a"></a> &nbsp;</td><td>
Chained representations have received extensive treatment,
frequently under the name &ldquo;lists&rdquo;.
See, for example, 
<acronym title="Shaw, J.C., A. Newell, H.A. Simon, and T.O. Ellis, (1958), 
“A Command Structure for Complex Information Processing”, 
Proc. Western Joint Computer Conference, pp. 119-128.">Shaw et al. (1958)</acronym> and
<acronym title="Blaauw, G. A., (1959), “Indexing and Control-Word Techniques”, 
IBM Journal of Research and Development, vol. 3, pp. 288-301.">Blaauw (1959)</acronym>.
 </td></tr>
<tr><td valign=top>b.<a name="note3b"></a> &nbsp;</td><td>
<acronym title="Johnson, L.R., (1962), “On Operand Structure, Representation, Storage, and Search”, 
Research Report # RC-603, IBM Corp.">Johnson (1962)</acronym> 
provides a comprehensive treatment 
of the representations of trees and discusses the suitability 
of each representation for a variety of search procedures.
 </td></tr>
</table>
<br>



<a name="ex3"></a>
<p><b>Exercises</b></p>

<p>The symbols <b><i>a</i></b> and <b><i>c</i></b> 
will be used exclusively to denote lower case and capital
alphabets defined as follows:</p>

<table>
<tr><td width=75>&nbsp;</td>
 <td><b><i>a</i></b> =&nbsp;</td>
 <td>(0, a, b, c, &#133; , z, <b>.</b>, <b>,</b>, #, *, +).</td></tr>
<tr><td>&nbsp;</td>
 <td><b><i>c</i></b> =&nbsp;</td>
 <td>(0, A, B, C, &#133; , Z, <b>.</b>, <b>,</b>, #, *, +).</td></tr>
</table>

<p>The expression <nobr><b>&pi;</b> <tt>⊆</tt> <b><i>x</i></b></nobr>
will be used to specify the set <b><i>x</i></b> 
as the range of the components of <b>&pi;</b>.
</p>


<p><b>3.1&nbsp;</b> For each of the following cases, 
specify a suitable encoding matrix and format vector 
and show the explicit value of the infix of <b>&pi;</b> 
which (in a solid representation) represents 
the given example vector <b><i>x</i></b>:

<table>
<tr><td valign=top nowrap>(a) <sup>&nbsp;</sup></td><td>the decimal digits 
<b><i>d</i></b> = <tt><b>⍳</b></tt><sup>0</sup>(10) 
in a ranked fixed-length code 
for <b>&pi;</b> <tt>⊆</tt> <tt><b>⍳</b></tt><sup>0</sup>(2).<br>
Example: <b><i>x</i></b> = (6, 8, 9).
 </td></tr>
<tr><td valign=top nowrap>(b) <sup>&nbsp;</sup></td><td>the set <b><i>a</i></b> 
in a ranked fixed-length code 
for <b>&pi;</b> <tt>⊆</tt> <tt><b>⍳</b></tt><sup>0</sup>(2).<br>
Example: <b><i>x</i></b> = (c, a, t).
 </td></tr>
<tr><td valign=top>(c) <sup>&nbsp;</sup></td><td>the set 
<b><i>a</i></b> <tt>∪</tt> <b><i>c</i></b> <tt>∪</tt> <tt><b>⍳</b></tt><sup>0</sup>(10) 
in a fixed-length code
for <b>&pi;</b> <tt>⊆</tt> <tt><b>⍳</b></tt><sup>0</sup>(10).<br>
Example: <b><i>x</i></b> = (M, a, y, <tt>∘</tt>, 3, <b>,</b>, 1,9,6,0, <b>.</b>).
 </td></tr>
<tr><td valign=top>(d) &nbsp;</td><td>the set <b><i>a</i></b> <tt>∪</tt> <b><i>c</i></b> 
in a two-case code (with single-character shift) 
for <b>&pi;</b> <tt>⊆</tt> <b><i>a</i></b>.
(See <acronym title="Brooks, F.P., Jr., and K.E. Iverson, (1962), 
(in press) Automatic Data Processing, Wiley, New York.">Brooks and Iverson, 1962.</acronym>)<br>
Example: x = (T, r, o, y, <b>,</b>, N, <b>.</b>, Y, <b>.</b>).
 </td></tr>
<tr><td valign=top>(e) <sup>&nbsp;</sup></td><td>the set <b><i>a</i></b> 
in a Huffman prefix code 
for <b>&pi;</b> <tt>⊆</tt> <tt><b>⍳</b></tt><sup>0</sup>(2).
Assume the frequency distribution given in 
<acronym title="Dewey, Godfrey, (1923), Relative Frequency of English Speech Sounds, 
Cambridge University Press, p. 185.">Dewey (1923)</acronym>.<br>
Example: <b><i>x</i></b> = (t, r, e, e).</p>
 </td></tr>
</table>


<p><b>3.2&nbsp;</b> For each of the cases of Exercise 3.1 
write a program which decodes the infix 
<nobr>(<i>i</i> &darr; <tt><b>⍺</b></tt><sup><i>j</i></sup>)/<b>&pi;</b>,</nobr> 
that is, which produces the vector <b><i>z</i></b> 
represented by the infix. 
The auxiliary physical vector 
<b>&pi;</b><sup>1</sup> <tt>⊆</tt> <b><i>s</i></b>
may be employed to represent the first column 
of the encoding matrix, 
where <b><i>s</i></b> is the set encoded. 
Perform a partial trace of each program 
for the example value used in Exercise 3.1.
</p>


<p><b>3.3&nbsp;</b> The ordered set of months 
<b><i>m</i></b> = (JANUARY, FEBRUARY, &#133; , DECEMBER) 
is to be represented by the physical vector 
<b>&pi;</b> <tt>⊆</tt> <b><i>c</i></b> <tt>∪</tt> <tt><b>⍳</b></tt><sup>0</sup>(10). 
For each of the following types of representation, 
specify a particular representation
and show the values of the relevant components of <b>&pi;</b>:

<table>
<tr><td valign=top nowrap>(a) &nbsp;</td><td>a linear representation 
(employing null elements for filling to a common dimension in <b>&pi;</b>).
 </td></tr>
<tr><td valign=top nowrap>(b) &nbsp;</td><td>a solid representation 
for each element of <b><i>m</i></b> 
and an appropriate grid matrix itself represented linearly.
 </td></tr>
<tr><td valign=top nowrap>(c) &nbsp;</td><td>a chained representation.
 </td></tr>
<tr><td valign=top nowrap>(d) &nbsp;</td><td>a double chained representation.
 </td></tr>
</table>
</p>


<p><b>3.4&nbsp;</b> 
<table><td valign=top nowrap>(a) &nbsp;</td><td>
For each of the cases of Exercise 3.3, 
write a program which selects month <b><i>m</i></b><sub><i>k</i></sub>.
 </td></tr>
<tr><td valign=top nowrap>(b) &nbsp;</td><td>
Trace each program for the case <i>k</i> = 2.
 </td></tr>
<tr><td valign=top nowrap>(c) &nbsp;</td><td>
For case (d) of Exercise 3.3, 
write a program which selects <b><i>m</i></b><sub><i>k</i></sub> 
by forward chaining if <i>k</i> <tt>≤</tt> <i>&nu;</i>(<b><i>m</i></b>)<tt>÷</tt>2, 
and by backward chaining if <i>k</i> &gt; <i>&nu;</i>(<b><i>m</i></b>)<tt>÷</tt>2.
 </td></tr>
</table>
</p>


<p><b>3.5&nbsp;</b> For each of the cases of Exercise 3.3, 
write a program which &ldquo;prints out&rdquo;
the set of months in a minimum number of <i>n</i>-character lines, 
inserting a single null between successive months except where 
(i) further nulls must be added to prevent the continuation 
of a single word from one line to the next, or 
(ii) no null is needed between two successive words, 
the first of which is coterminous with the line. 
In other words, produce a matrix <b><i>Z</i></b> 
of row dimension <i>n</i> and of minimum
column dimension such that 
(<b><i>Z</i></b> &ne; <tt>∘</tt><b><i>E</i></b>)/<b><i>Z</i></b> = 
<tt><b>⍴</b></tt>(<b><i>m</i></b><sub>1</sub>) <img src="APLimg/circleplus.bmp">
<tt><b>⍴</b></tt>(<b><i>m</i></b><sub>2</sub>) <img src="APLimg/circleplus.bmp"> &#133;
<img src="APLimg/circleplus.bmp"> <tt><b>⍴</b></tt>(<b><i>m</i></b><sub>12</sub>),
and such that each row <b><i>Z</i></b><sup><i>i</i></sup> 
may be partitioned into one or more vectors of the form 
<nobr><tt><b>⍴</b></tt>(<b><i>m</i></b><sub><i>k</i></sub>) 
<img src="APLimg/circleplus.bmp"> <tt>∘</tt><tt><b>∊</b></tt>,</nobr> 
all but the last of which must be of dimension 
<nobr><i>&nu;</i>[<tt><b>⍴</b></tt>(<b><i>m</i></b><sub><i>k</i></sub>)] + 1.</nobr>
</p>


<p><b>3.6&nbsp;</b> Assuming a linear representation 
for each of the logical vectors involved,
and a forward-chained representation 
for each of the remaining operands, 
write programs for the following operations. 
Assume in each case that the arguments <b><i>x</i></b>
and <b><i>y</i></b> need not be retained, 
and assume the use of a backward-chained pool where necessary.
<table>
<tr><td>(a) &nbsp;</td><td><b><i>z</i></b> &larr; \<b><i>x</i></b>, <b><i>u</i></b>, <b><i>y</i></b>\</td></tr>
<tr><td>(b) &nbsp;</td><td><b><i>z</i></b> &larr; /<b><i>x</i></b>, <b><i>u</i></b>, <b><i>y</i></b>/</td></tr>
<tr><td>(c) &nbsp;</td><td><b><i>z</i></b> &larr; <i>k</i> &uarr; <b><i>x</i></b></td></tr>
<tr><td>(d) &nbsp;</td><td><b><i>z</i></b> &larr; <i>k</i> &darr; <b><i>x</i></b></td></tr>
</table>
</p>


<p><b>3.7&nbsp;</b> Repeat Exercise 3.6(a), 
using separate grid matrices for <b><i>x</i></b>, 
<b><i>y</i></b>, and <b><i>z</i></b> 
instead of chained representations. 
Specify a suitable linear representation for each of
the grid matrices.
</p>


<p><b>3.8&nbsp;</b> 
<table>
<tr><td valign=top nowrap>(a) &nbsp;</td><td>
If a chained representation is used 
for a vector <b><i>x</i></b>, 
then the selection of a specified component 
can be made faster 
by providing a number of alternative starting points 
for the required scan. 
State precisely the quantities required in such a process and 
write a program showing its use.
 </td></tr>
<tr><td valign=top nowrap>(b) &nbsp;</td><td>
If provision is made for starting the scan 
at any component of <b><i>x</i></b>, 
the chained representation may itself be simplified. 
Show precisely what the simplified form is and 
identify the type of representation to which it
is equivalent.
 </td></tr>
</table>
</p>


<p><b>3.9&nbsp;</b> Frequently a vector <b><i>x</i></b> 
kept in a partitioned representation 
(for efficient use of storage) must be &ldquo;unpacked&rdquo; 
to a linear or other more accessible form for
efficient processing. 
The converse operation of &ldquo;packing&rdquo; is also required. Let
the partitioned representation be a file <b>&Phi;</b> 
employing an intercomponent partition <b>&lambda;</b><sub>1</sub>,
and a terminal partition <b>&lambda;</b><sub>2</sub>, 
and write both packing and unpacking programs
for each of the following cases. 
Assume that the maximum dimension in <b>&pi;</b> 
of any component is <i>n</i>.

<table>
<tr><td valign=top nowrap>(a) &nbsp;</td><td>A solid linear representation 
employing null fill.
 </td></tr>
<tr><td valign=top nowrap>(b) &nbsp;</td><td>An allocation prescribed 
by a grid matrix <b><i>G</i></b> 
with <b><i>G</i></b><sub>2</sub> = <i>n</i><tt><b>∊</b></tt>.
 </td></tr>
</table>
</p>


<p><b>3.10&nbsp;</b> Let <b>&pi;</b> <tt>⊆</tt> <tt><b>⍳</b></tt><sup>0</sup>(2), 
let the set a be encoded in a five-bit code such that 
<nobr>(2<tt><b>∊</b></tt>) <tt>⊥</tt> 
<tt><b>⍴</b></tt>(<b><i>a</i></b><sub><i>i</i></sub>) = <i>i</i>,</nobr>
and let each component of the vector <b><i>x</i></b> 
be an (uncapitalized) English word. 
Using 0-origin indexing throughout, 
specify a suitable partitioned representation
in <b>&pi;</b> for the vector <b><i>x</i></b>, 
and repeat Exercises 3.9(a) and 3.9(b), 
using it in lieu of the files.
</p>


<p><b>3.11&nbsp;</b> For each of the following pool organizations, 
write a program to convert
a given marked pool into a backward-chained pool:
<table>
<tr><td>(a) &nbsp;</td><td>dimension-ordered.</td></tr>
<tr><td>(b) &nbsp;</td><td>address-ordered.</td></tr>
</table>
</p>


<p><b>3.12&nbsp;</b> For each of the following queue disciplines, 
write programs which take from and return 
to the pool an infix of length <i>n</i>. 
Use secondary linking and relegate to a marked pool 
any infix which is too short for linking. 
In each case choose the type of chaining best suited 
to the particular queue discipline.
<table>
<tr><td valign=top nowrap>(a) &nbsp;</td><td>LIFO (last-in-first-out).</td></tr>
<tr><td valign=top nowrap>(b) &nbsp;</td><td>FIFO (first-in-first-out).</td></tr>
<tr><td valign=top nowrap>(c) &nbsp;</td><td>Dimension ordered.</td></tr>
<tr><td valign=top nowrap>(d) &nbsp;</td><td>Address-ordered 
(utilize the possibility of fusing adjacent infixes).</td></tr>
</table>
</p>


<p><b>3.13&nbsp;</b> Give a complete specification of a scheme 
for representing a tree <b>T</b> by a full chain list matrix 
which is not in right list order. 
Write a program (expressed in terms of the physical vector <b>&pi;</b>) 
which determines the path vector <b>T</b><sup><b><i>i</i></b></sup> 
for a given index vector <b><i>i</i></b>.
</p>


<p><b>3.14&nbsp;</b> Give a complete specification of a scheme allowing joint representation of
those components shared by two or more of a family of vectors 
<b><i>x</i></b><sup>1</sup>, <b><i>x</i></b><sup>2</sup>, &#133;, 
<b><i>x</i></b><sup><i>n</i></sup> as suggested in Sec. 3.2. 
Write programs to (i) select component 
<b><i>x</i></b><sub><i>j</i></sub><sup><i>i</i></sup>, 
and (ii) delete component 
<b><i>x</i></b><sub><i>j</i></sub><sup><i>i</i></sup>.
</p>


<p><b>3.15&nbsp;</b> Let <b>&pi;</b> <tt>⊆</tt> 
<b><i>a</i></b> <tt>∪</tt> <tt><b>⍳</b></tt><sup>0</sup>(10), 
and let 
<b><i>x</i></b><sup>1</sup>, <b><i>x</i></b><sup>2</sup>, &#133;, 
<b><i>x</i></b><sup><i>n</i></sup>
be a family of vectors whose
components belong to the set 
<nobr><img src="APLimg/alphaboscore.bmp"><sup>1</sup>/[<b><i>a</i></b> <tt>∪</tt> <tt><b>⍳</b></tt><sup>0</sup>(10)].</nobr> 
Let the average and the maximum
dimensions of the vectors <b><i>x</i></b><sup><i>i</i></sup> 
be <i>a</i> and <i>m</i>, respectively. 
Assume that the chaining index is represented in decimal, 
with each digit represented by one component of <b>&pi;</b>. 
Determine (as a function of <i>m</i> and <i>n</i>) 
the value of <i>a</i> below which a chained representation 
provides more compact storage 
than a linear representation with null fill.
</p>


<p><b>3.16&nbsp;</b> Write a program 
which uses the minimization operation 
<nobr><b><i>u</i></b> &larr; <i>v</i> <tt>⌊</tt> <i>x</i></nobr> 
to determine the ordering permutation vector 
<nobr><b><i>p</i></b> &larr; <i>&theta;</i><sub>1</sub>/(<b><i>a</i></b> <tt>⍳</tt><sub>1</sub> <b><i>b</i></b>).</nobr>
</p>


<p><b>3.17&nbsp;</b> Let <nobr><b><i>U</i></b> = (<b><i>X</i></b> &ne; 0)</nobr>
and <nobr><b><i>r</i></b> = <b><i>U</i></b>/<b><i>X</i></b></nobr> 
jointly represent the sparse matrix <b><i>X</i></b>.

<table>
<tr><td valign=top nowrap>(a) &nbsp;</td><td>
Write a program which determines 
(as a function of <b><i>U</i></b> and <b><i>r</i></b>) 
a suitable row-chained and column-chained representation 
of <b><i>X</i></b>.
 </td></tr>
<tr><td valign=top nowrap>(b) &nbsp;</td><td>
Write a program defined on the representation produced in part (a) to
compute the product 
<nobr><b><i>Y</i></b> = <b><i>X</i></b> 
<img src="APLimg/plustimes.bmp"> <b><i>X</i></b>,</nobr> 
itself represented in the form 
<nobr><b><i>V</i></b> =
(<b><i>Y</i></b> &ne; 0) and <b><i>p</i></b> = 
<b><i>V</i></b>/<b><i>Y</i></b>.</nobr>
 </td></tr>
<tr><td valign=top nowrap>(c) &nbsp;</td><td>
Write a program to determine the trace 
(that is, +/<b><i>I</i></b>/<b><i>X</i></b>) 
of <b><i>X</i></b> from the
representation produced in part (a).
 </td></tr>
</table>
</p>


<p><b>3.18&nbsp;</b> The unique assignment 
of Huffman codes produced by Program 3.12 is,
in general, only one of many equally efficient assignments, 
since the symbols to be coded need only be assigned, 
in decreasing order on frequency, 
to the leaves of the code tree 
in increasing order on their levels. 
Show that the structure of the
tree produced can be sufficiently described 
by its moment vector alone, 
and write a program for the construction 
of a Huffman code based on this fact.
</p>


<p><b>3.19&nbsp;</b> Following the notation and terminology 
used in Program 3.9 
for the analogous case of a left list,
write a program which determines 
from the right list <b><i>R</i></b> of a tree <b><i>T</i></b>, 
the partition vector <b><i>p</i></b> which partitions it by levels.
</p>


<p><b>3.20&nbsp;</b> Write a program which determines the right list 
<b><i>R</i></b> = <tt><b>⍺</b></tt><sup>2</sup>/]<b><i>T</i></b> 
as a function of the left list 
<b><i>L</i></b> = <tt><b>⍺</b></tt><sup>2</sup>/[<b><i>T</i></b>. 
Incorporate tests of well formation.
</p>


<p><b>3.21&nbsp;</b> Let [<b><i>X</i></b><img align=middle src="APLimg/circle1circle2.bmp">]<sup><i>p</i></sup> 
denote the <i>p</i>th power 
of the square matrix <b><i>X</i></b> 
with respect to the operators 
<img src="APLimg/circledot.bmp"><sub>1</sub> and 
<img src="APLimg/circledot.bmp"><sub>2</sub>, 
that is, 
[<b><i>X</i></b><img align=middle src="APLimg/circle1circle2.bmp">]<sup><i>p</i></sup> = 
<b><i>X</i></b> <img align=middle src="APLimg/circle1circle2.bmp">
<b><i>X</i></b> <img align=middle src="APLimg/circle1circle2.bmp"> &#133; 
<img align=middle src="APLimg/circle1circle2.bmp"> <b><i>X</i></b>
to <i>p</i> factors.

<table>
<tr><td valign=top nowrap>(a) <sup>&nbsp;</sup></td><td>
Show that 
([<b><i>C</i></b><img src="APLimg/orand.bmp">]<sup><i>p</i></sup>)<sub><i>j</i></sub><sup><i>i</i></sup> = 1 
if and only if there is a path of length <i>p</i> from
node <i>i</i> to node <i>j</i> in the graph (<b><i>n</i></b>,&nbsp;<b><i>C</i></b>).
 </td></tr>
<tr><td valign=top nowrap>(b) <sup>&nbsp;</sup></td><td>
Show that [<b><i>C</i></b><img src="APLimg/orand.bmp">]<sup><i>p</i></sup> = 0 
for some <i>p</i> &lt; <i>&nu;</i>(<b><i>C</i></b>) 
if and only if (<b><i>n</i></b>,&nbsp;<b><i>C</i></b>) 
contains no circuits.
 </td></tr>
<tr><td valign=top nowrap>(c) &nbsp;</td><td>
If (<b><i>n</i></b>, <b><i>C</i></b>) contains no circuits, 
the connection matrix <b><i>C</i></b> 
is said to be &ldquo;consistent&rdquo;.
The result of part (a) can be used to check consistency. 
Program the alternative method of 
<acronym title="Marimont, R.B., (1959), 
“A New Method of Checking the Consistency of Precedence Matrices”, 
J. ACM, vol. 6, pp. 164-171.">Marimont (1959)</acronym>.
 </td></tr>
<tr><td valign=top nowrap>(d) &nbsp;</td><td>
If <b><i>H</i></b> = <b><i>C</i></b> &or; <b><i>I</i></b>, then 
([<b><i>H</i></b><img src="APLimg/orand.bmp">]<sup><i>p</i></sup>)<sub><i>j</i></sub><sup><i>i</i></sup> = 1 
if and only if <i>i</i> = <i>j</i> 
or there exists a path 
from node <i>i</i> to node <i>j</i> 
of length <nobr><i>n</i> <tt>≤</tt> <i>p</i> + 1.</nobr>
Show that for any connection matrix <b><i>C</i></b>, 
<nobr>[<b><i>H</i></b><img src="APLimg/orand.bmp">]<sup><i>p</i></sup></nobr>
converges to a limit.
 </td></tr>
</table>
</p>

<p><b>3.22&nbsp;</b> Devise programs to determine

<table>
<tr><td valign=top nowrap>(a) &nbsp;</td><td>
whether a given connection matrix <b><i>C</i></b> represents a tree.
 </td></tr>
<tr><td valign=top nowrap>(b) &nbsp;</td><td>
the left list of the tree (<b><i>n</i></b>, <b><i>C</i></b>).
 </td></tr>
<tr><td valign=top nowrap>(c) &nbsp;</td><td>
the right list of the tree (<b><i>n</i></b>, <b><i>C</i></b>).
 </td></tr>
<tr><td valign=top nowrap>(d) &nbsp;</td><td>
a node list <b><i>n</i></b> and connection matrix <b><i>C</i></b> as a function of
<table>
<tr><td>(i)</td><td>a left list <b><i>L</i></b></td></tr>
<tr><td>(ii)&nbsp;</td><td>a right list <b><i>R</i></b>.</td></tr>
</table>
 </td></tr>
</table>
</p>


<p><b>3.23&nbsp;</b> Show that (<b><i>n</i></b>, <b><i>C</i></b>) 
and (<b><i>n</i></b><sub><b><i>p</i></b></sub>, <b><i>C</i></b><sub><b><i>p</i></b></sub><sup><b><i>p</i></b></sup>) 
represent the same graph 
for any permutation <b><i>p</i></b>.</p>


<p><b>3.24&nbsp;</b> If (<b><i>n</i></b>, <b><i>C</i></b>) 
is a tree and if <nobr><b><i>K</i></b> = 
<b><i>C</i></b> <img src="APLimg/orand.bmp"> <b><i>C</i></b>,</nobr> 
then <b><i>C</i></b> can be determined as a function of <b><i>K</i></b>
(see <acronym title="Ross, I.C., and F. Harary, (1960), “The Square of a Tree”, 
Bell System Tech. J., vol. XXXIX, pp. 641-8.">Ross and Harary, 1960</acronym>). 
Write a program for determining <b><i>C</i></b> from <b><i>K</i></b>.
<br>&nbsp;</p>



<!-------------------------------------------------------------------------------
  ------------------------------------------------------------------------------->



<a name="summary"></a>
<p><font size=+1>Summary of Notation</font></p>

<a name="s.1"></a>
<p><b>S.1 Conventions</b></p>

<a name="s.1.1"></a>
<p><b>Basic conventions</b></p>

<table>
<tr><td valign=top>(a)</td><td>&nbsp;</td><td>
1-origin indexing assumed in this summary.
</td></tr>
<tr><td valign=top>(b)</td><td>&nbsp;</td><td>
Controlling variables appear to the left, e.g.,
<b><i>u</i></b>/<b><i>x</i></b>,
<b><i>u</i></b> <tt>⊥</tt> <b><i>y</i></b>,
<i>k</i> <tt>↑</tt> <b><i>x</i></b>, and
<b><i>u</i></b> <tt>⌈</tt> <b><i>x</i></b>.
</td></tr>
<tr><td valign=top>(c)<sup> </sup></td><td>&nbsp;</td><td>
Dimension <i>n</i> may be elided 
(if determined by compatibility) from 
<tt><b>∊</b></tt>(<i>n</i>),
<tt><b>∊</b></tt><sup><i>k</i></sup>(<i>n</i>),
<tt><b>⍺</b></tt><sup><i>k</i></sup>(<i>n</i>),
<tt><b>⍵</b></tt><sup><i>k</i></sup>(<i>n</i>), and
<tt><b>⍳</b></tt><sup>&nbsp;<i>j</i></sup>(<i>n</i>).
</td></tr>
<tr><td valign=top>(d)</td><td>&nbsp;</td><td>
The parameter <i>j</i> may be elided from operators 
<tt>|</tt><sub>&nbsp;<i>j</i></sub>,
&theta;<sub>&nbsp;<i>j</i></sub>,
&int;<sub>&nbsp;<i>j</i></sub>, and
<tt>⍳</tt><sub>&nbsp;<i>j</i></sub>,
and from the vector 
<tt><b>⍳</b></tt><sup>&nbsp;<i>j</i></sup>
if <i>j</i> is the index origin in use.
</td></tr>
<tr><td valign=top>(e)</td><td>&nbsp;</td><td>
The parameter <i>k</i> may be elided from
<i>k</i> <tt>↑</tt> <b><i>x</i></b> if
<i>k</i> = 1.
</td></tr>
</table>



<a name="s.1.2"></a>
<p><b>Branching conventions</b></p>

<table>
<tr><td valign=top>(a)</td><td>&nbsp;</td><td>
<p align=center>│ <i>x</i> : <i>y</i> │<img src="APLimg/APLbranch.bmp"></p>
<p>The statement to which the arrow leads is executed
if <nobr>(<i>x</i> <font face=Script>R</font> <i>y</i>)</nobr> = 1;
otherwise the listed successor is executed next.
An unlabeled arrow is always followed.
<br>&nbsp;</p></td></tr>
<tr><td valign=top>(b)</td><td>&nbsp;</td><td>
<p align=center><i>x</i> : <i>y</i>, &nbsp; <b><i>r</i></b> &rarr; <b><i>s</i></b></p>
<p>The statement numbered <b><i>s</i></b><sub>&nbsp;<i>i</i></sub>
is executed next if (<i>x</i><b><i>r</i></b><sub><i>&nbsp;i&nbsp;</i></sub><i>y</i>) = 1.
The null symbol <tt>∘</tt> occurring as a component
of <b><i>r</i></b> denotes the relation
which complements the disjunction 
of the remaining relations in <b><i>r</i></b>.
<br>&nbsp;</p></td></tr>
<tr><td valign=top>(c)</td><td>&nbsp;</td><td>
<p align=center>&rarr; Program <i>a</i>, <i>b</i></p>
<p>Program <i>a</i> branches to its statement <i>b</i>.
The symbol <i>a</i> may be elided 
if the statement occurs in Program <i>a<i> itself.</p>
</td></tr>
</table>



<a name="s.1.3"></a>
<p><b>Operand conventions used in summary</b></p>

<table>
<tr><td>&nbsp;</td><td>&nbsp; &nbsp; &nbsp; &nbsp;</td><td align=center>Scalar</td>
 <td>&nbsp; &nbsp; &nbsp;</td><td align=center>Vector</td>
 <td>&nbsp; &nbsp; &nbsp;</td><td align=center>Matrix</td>
 <td>&nbsp; &nbsp; &nbsp;</td><td align=center>Tree</td></tr>
<tr><td>Logical</td><td>&nbsp;</td><td><i>u</i>, <i>v</i>, <i>w</i></td>
 <td>&nbsp;</td><td><b><i>u</i></b>, <b><i>v</i></b>, <b><i>w</i></b></td>
 <td>&nbsp;</td><td><b><i>U</i></b>, <b><i>V</i></b>, <b><i>W</i></b></td>
 <td>&nbsp;</td><td><b>U</b>, <b>V</b>, <b>W</b></td></tr>
<tr><td>Integral</td><td>&nbsp;</td><td><i>h</i>, <i>i</i>, <i>j</i>, <i>k</i></td>
 <td>&nbsp;</td><td><b><i>h</i></b>, <b><i>i</i></b>, <b><i>j</i>, <b><i>k</i></b></td>
 <td>&nbsp;</td><td><b><i>H</i></b>, <b><i>I</i></b>, <b><i>J</i>, <b><i>K</i></b></td>
 <td>&nbsp;</td><td><b>H</b>, <b>I</b>, <b>J</b>, <b>K</b></td></tr>
<tr><td>Numerical</td><td>&nbsp;</td><td><i>x</i>, <i>y</i>, <i>z</i></td>
 <td>&nbsp;</td><td><b><i>x</i></b>, <b><i>y</i></b>, <b><i>z</i></b></td>
 <td>&nbsp;</td><td><b><i>X</i></b>, <b><i>Y</i></b>, <b><i>Z</i></b></td>
 <td>&nbsp;</td><td><b>X</b>, <b>Y</b>, <b>Z</b></td></tr>
<tr><td>Arbitrary</td><td>&nbsp;</td><td><i>a</i>, <i>b</i>, <i>c</i></td>
 <td>&nbsp;</td><td><b><i>A</i></b>, <b><i>B</i></b>, <b><i>C</i></b></td>
 <td>&nbsp;</td><td><b><i>A</i></b>, <b><i>B</i></b>, <b><i>C</i></b></td>
 <td>&nbsp;</td><td><b>A</b>, <b>B</b>, <b>C</b></td></tr>
</table>
<br>



<a name="s.2"></a>
<p><b>S.2 Structural Parameters, Null</b></p>

<table>
<tr><td>Dimension</td><td>&nbsp;</td><td><i>&nu;</i>(<b><i>a</i></b>)</td><td>&nbsp;</td>
 <td>Number of components in vector <b><i>a</i></b></td>
 <td align=right valign=top><a href="APL1.htm#nu_vector"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top nowrap>Row dimension</td><td>&nbsp;</td>
 <td valign=top><i>&nu;</i>(<b><i>A</i></b>)</td><td>&nbsp;</td>
 <td>Number of components in each<br>row vector <b><i>A</i></b><sup><i>i</i></sup></td>
 <td align=right valign=top><a href="APL1.htm#nu_matrix"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top nowrap>Column dimension</td><td>&nbsp;</td>
 <td valign=top><i>&mu;</i>(<b><i>A</i></b>)</td><td>&nbsp;</td>
 <td>Number of components in each<br>column vector <b><i>A</i></b><sub><i>j</i></sub></td>
 <td align=right valign=top><a href="APL1.htm#mu_matrix"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td>Height</td><td>&nbsp;</td><td><i>&nu;</i>(<b>A</b>)</td><td>&nbsp;</td>
 <td>Length of longest path in <b>A</b></td>
 <td align=right valign=top><a href="APL1.htm#nu_tree"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td>Moment</td><td>&nbsp;</td><td><i>&mu;</i>(<b>A</b>)</td><td>&nbsp;</td>
 <td>Number of nodes in <b>A</b></td>
 <td align=right valign=top><a href="APL1.htm#mu_tree"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top>Dispersion vector<sup>&nbsp;</sup></td><td>&nbsp;</td>
 <td valign=top><b>&nu;</b>(<b>A</b>)<sup>&nbsp;</sup></td><td>&nbsp;</td>
 <td><table>
  <tr><td valign=top><b>&nu;</b><sub>1</sub>(<b>A</b>)</td>
   <td valign=top>=&nbsp;</td>
   <td>number of roots of <b>A</b></td></tr>
  <tr><td valign=top><b>&nu;</b><sub><i>&nbsp;j</i></sub>(<b>A</b>)</td>
   <td valign=top>=&nbsp;</td>
   <td>maximum degree of nodes on level <nobr><i>j</i> &ndash; 1;</nobr></td></tr> 
  <tr><td valign=top nowrap><i>&nu;</i>(<b>&nu;</b>(<b>A</b>))</td>
   <td valign=top>=&nbsp;</td>
   <td><i>&nu;</i>(<b>A</b>)</td></tr>
  </table></td>
  <td align=right valign=top><sup>&nbsp;</sup><a href="APL1.htm#dispersion_vector"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top>Moment vector</td><td>&nbsp;</td>
 <td valign=top><b>&mu;</b>(<b>A</b>)</td><td>&nbsp;</td>
 <td><b>&mu;</b><sub>&nbsp;j</sub>(<b>A</b>) = number of nodes on level &nbsp;<i>j</i>
  of <b>A</b>; <nobr><i>&nu;</i>(<b>&mu;</b>(<b>A</b>))</nobr> = <i>&nu;</i>(<b>A</b>)</td>
 <td align=right valign=top><a href="APL1.htm#mu_tree"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top nowrap>Degree of node <i>i</i></td><td>&nbsp;</td>
 <td valign=top nowrap><i>&delta;</i>(<b><i>i</i></b>, <b>A</b>)</td><td>&nbsp;</td>
 <td>Degree of node <i>i</i> of tree <b>A</b></td>
 <td align=right valign=top><a href="APL1.htm#delta2"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top nowrap>Degree</td><td>&nbsp;</td>
 <td valign=top nowrap><i>&delta;</i>(<b>A</b>)</td><td>&nbsp;</td>
 <td><i>&delta;</i>(<b>A</b>) = max <i>&delta;</i>(<b><i>i</i></b>, <b>A</b>)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<sup><b><i>i</i></b></sup></td>
 <td align=right valign=top><a href="APL1.htm#delta_tree"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top nowrap>Leaf count</td><td>&nbsp;</td>
 <td valign=top nowrap><i>&lambda;</i>(<b>A</b>)</td><td>&nbsp;</td>
 <td><i>&lambda;</i>(<b>A</b>) is the number of leaves in <b>A</b></td>
 <td align=right valign=top><a href="APL1.htm#lambda_tree"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top nowrap>Row dimension of file</td><td>&nbsp;</td>
 <td valign=top><i>&nu;</i>(<b>&Phi;</b>)</td><td>&nbsp;</td>
 <td>Number of files in each row<br>of a file array</td>
 <td align=right valign=top><a href="APL1.htm#file_array"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top nowrap>Column dimension of file</td><td>&nbsp;</td>
 <td valign=top><i>&mu;</i>(<b>&Phi;</b>)</td><td>&nbsp;</td>
 <td>Number of files in each column<br>of a file array</td>
 <td align=right valign=top><a href="APL1.htm#file_array"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top nowrap>Null character</td><td>&nbsp;</td>
 <td valign=top><tt>∘</tt></td><td>&nbsp;</td>
 <td>Null character of a set (e.g. space in the alphabet) 
  or null reduction operator</td>
 <td align=right valign=top><a href="APL1.htm#null_element"><img src="APLimg/link.bmp"></a></td>
 </tr>
</table>
<br>



<a name="s.3"></a>
<p><b>S.3 Relations</b></p>

<table>
<tr><td nowrap>Equality</td><td nowrap>&nbsp; &nbsp;</td><td nowrap><i>a</i> = <i>b</i></td>
 <td nowrap>&nbsp; &nbsp; &nbsp;</td><td><i>a</i> and <i>b</i> are identical</td>
 <td>&nbsp;</td><td align=right><a href="APL1.htm#relation"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td>Membership</td><td>&nbsp;</td><td><i>a</i> &epsilon; <b><i>b</i></b></td>
 <td>&nbsp;</td><td><i>a</i> = <b><i>b</i></b><sub><i>i</i></sub> for some <i>i</i></td>
 <td>&nbsp;</td><td align=right><a href="APL1.htm#membership"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td valign=top>Inclusion</td><td>&nbsp;</td><td><b><i>b</i></b> <tt>&supe;</tt> <b><i>a</i></b>
 <br><b><i>a</i></b> <tt>&sube;</tt> <b><i>b</i></b></td>
 <td>&nbsp;</td><td valign=top><b><i>a</i><sub><i>j</i></sub></b> = <b><i>b</i></b> for all <i>j</i></td>
 <td>&nbsp;</td>
 <td valign=top align=right><sup>&nbsp;</sup><a href="APL1.htm#inclusion"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td valign=top>Strict inclusion</td><td>&nbsp;</td><td><b><i>b</i></b> <tt>⊃</tt> <b><i>a</i></b>
 <br><b><i>a</i></b> <tt>⊂</tt> <b><i>b</i></b></td>
 <td>&nbsp;</td><td valign=top><b><i>b</i></b> <tt>&supe;</tt> <b><i>a</i></b> and <b><i>a</i></b> <img src="APLimg/notsupe.bmp"> <b><i>b</i></b></td>
 <td>&nbsp;</td>
 <td valign=top align=right><sup>&nbsp;</sup><a href="APL1.htm#strict_inclusion"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td valign=top>Similarity</td><td>&nbsp;</td><td><b><i>b</i></b> <tt>≡</tt> <b><i>a</i></b></td>
 <td>&nbsp;</td><td valign=top><b><i>b</i></b> <tt>&supe;</tt> <b><i>a</i></b> and <b><i>a</i></b> <tt>&supe;</tt> <b><i>b</i></b></td>
 <td>&nbsp;</td><td align=right><a href="APL1.htm#similarity"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td valign=top>Complementary relations</td><td>&nbsp;</td><td align=center valign=top><img src="APLimg/notrel.bmp"></td>
 <td>&nbsp;</td><td>The relation which holds if and only if <font face="Script">R</font> does not.
 Examples of complementary pairs: 
 <nobr>&epsilon;, <img src="APLimg/noteps.bmp">;</nobr>
 <nobr><tt>⊃</tt>, <img src="APLimg/notsup.bmp">;</nobr> 
 <nobr>&gt;, <img src="APLimg/notgt.bmp">.</nobr>
 </td></tr>
<tr><td valign=top>Combined (<i>or</i>ed) relations</td><td>&nbsp;</td><td>&nbsp;</td>
 <td>&nbsp;</td><td>A list of relations between two variables
 is construed as the <i>or</i> of the relations.  
 Thus <nobr><b><i>x</i></b> <tt>⊂ ⊃</tt> <b><i>y</i></b></nobr> is equivalent to
 <b><i>x</i></b> <tt>≢</tt> <b><i>y</i></b>.
 When equality occurs as one of the <i>or</i>ed relations,
 it is indicated by a single inferior line, e.g. &le; and<tt> ⊆ </tt>.</td></tr>
</table>
<br>



<a name="s.4"></a>
<p><b>S.4 Elementary Operations</b></p>

<table>
<tr><td>Negation</td><td>&nbsp;</td><td><i>w</i> &larr; <img src="APLimg/uoscore.bmp"></td>
 <td nowrap>&nbsp; &nbsp;</td><td><i>w</i> = 1<tt> ←→ </tt><i>u</i> = 0</td>
 <td align=right><sup>&nbsp;</sup><a href="APL1.htm#not"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td>And</td><td>&nbsp;</td><td><i>w</i> &larr; <i>u</i> &and; <i>v</i></td>
 <td>&nbsp;</td><td><i>w</i> = 1<tt> ←→ </tt><i>u</i> = 1 and <i>v</i> = 1</td>
 <td align=right><sup>&nbsp;</sup><a href="APL1.htm#and"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td>Or</td><td>&nbsp;</td><td><i>w</i> &larr; <i>u</i> &or; <i>v</i></td>
 <td>&nbsp;</td><td><i>w</i> = 1<tt> ←→ </tt><i>u</i> = 1 or <i>v</i> = 1</td>
 <td align=right><sup>&nbsp;</sup><a href="APL1.htm#or"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td>Relational statement</td><td>&nbsp;</td><td valign=top nowrap><i>w</i> &larr; <nobr>(<i>a</i> <font face="Script">R</font> <i>b</i>)</nobr></td>
 <td>&nbsp;</td><td valign=top><i>w</i> = 1<tt> ←→ </tt>
 the relation <nobr><i>a</i> <font face="Script">R</font> <i>b</i></nobr> holds</td>
 <td valign=top align=right><sup>&nbsp;</sup><a href="APL1.htm#relation"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td>&nbsp;</td></tr>
<tr><td>Sum</td><td>&nbsp;</td><td><i>z</i> &larr; <i>x</i> + <i>y</i></td>
 <td>&nbsp;</td><td><i>z</i> is the algebraic sum of <i>x</i> and <i>y</i></td> 
 <td align=right><sup>&nbsp;</sup><a href="APL1.htm#plus"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td>Difference</td><td>&nbsp;</td><td><i>z</i> &larr; <i>x</i> &ndash; <i>y</i></td>
 <td>&nbsp;</td><td><i>z</i> is the algebraic difference of <i>x</i> and <i>y</i></td>
 <td align=right><sup>&nbsp;</sup><a href="APL1.htm#minus"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td valign=top>Product</td><td>&nbsp;</td><td valign=top>
<i>z</i> &larr; <i>x</i> &times; <i>y</i><br>
<i>z</i> &larr; <i>xy</i><br>
<i>c</i> &larr; <i>a</i> &times; <i>u</i><br>
<i>c</i> &larr; <i>au</i></td>
 <td>&nbsp;</td><td valign=top><i>z</i> is the algebraic product of 
 numbers <i>x</i> and <i>y</i>,
 and <i>c</i> is the arbitrary character <i>a</i> or zero
 according to whether the logical variable <i>u</i> is one or zero.</td>
 <td valign=top align=right><sup>&nbsp;</sup><a href="APL1.htm#times"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td>Quotient</td><td>&nbsp;</td><td><i>z</i> &larr; <i>x</i> <tt>÷</tt> <i>y</i></td>
 <td>&nbsp;</td><td><i>z</i> is the quotient of <i>x</i> and <i>y</i></td>
 <td align=right><sup>&nbsp;</sup><a href="APL1.htm#divide"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td valign=top nowrap>Absolute value</td><td>&nbsp;</td><td valign=top><i>z</i> &larr; |<i>x</i>|</td>
 <td>&nbsp;</td>
 <td valign=top><i>z</i> = <i>x</i> &times; [(<i>x</i> <tt>&gt;</tt> 0) &ndash; (<i>x</i> <tt>&lt;</tt> 0)]</td>
 <td align=right><sup>&nbsp;</sup><a href="APL1.htm#abs"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td valign=top>Floor</td><td>&nbsp;</td><td valign=top><i>k</i> &larr; <tt>⌊</tt><i>x</i><tt>&rfloor;</tt></td>
 <td>&nbsp;</td>
 <td valign=top><i>k</i> &le; <i>x</i> &lt; <i>k</i> + 1</td>
 <td align=right><sup>&nbsp;</sup><a href="APL1.htm#floor"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td valign=top>Ceiling</td><td>&nbsp;</td><td valign=top><i>k</i> &larr; <tt>⌈</tt><i>x</i><tt>&rceil;</tt></td>
 <td>&nbsp;</td>
 <td valign=top><i>k</i> &ge; <i>x</i> &gt; <i>k</i> &ndash; 1</td>
 <td align=right><sup>&nbsp;</sup><a href="APL1.htm#ceiling"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td valign=top nowrap><i>j</i>-Residue mod <i>h</i></td><td>&nbsp;</td><td valign=top><i>k</i> &larr; <i>h</i>|<sub><i>&nbsp;j&nbsp;</i></sub><i>i</i></td>
 <td>&nbsp;</td>
 <td valign=top><i>i</i> = <i>hq</i> + <i>k</i>; <i>j</i> &le; <i>k</i> &lt; <i>j</i> + <i>h</i>;
 and <i>q</i> is integral.</td>
 <td align=right><sup>&nbsp;</sup><a href="APL1.htm#residue"><img src="APLimg/link.bmp"></a></td></tr>
</table>
<br>



<a name="s.5"></a>
<p><b>S.5 Vector Operations</b></p>

<table>
<tr><td>Component-by-component<br>extension of basic operation</td><td>&nbsp;</td>
 <td valign=top nowrap><b><i>c</i></b> &larr; <b><i>a</i></b> <img src="APLimg/circledot.bmp"> <b><i>b</i></b></td><td nowrap>&nbsp; &nbsp;</d>
 <td colspan=3 valign=top><b><i>c</i></b><sub><i>i</i></sub> &larr; <b><i>a</i></b><sub><i>i</i></sub> <img src="APLimg/circledot.bmp"> <b><i>b</i></b><sub><i>i</i></sub> .
 Examples: 
 <b><i>x</i></b>&nbsp;&times;&nbsp;<b><i>y</i></b>, 
 (<b><i>a</i></b>&nbsp;&ne;&nbsp;<b><i>b</i></b>),
 <b><i>h</i></b>|<sub><i>&nbsp;j&nbsp;</i></sub><b><i>i</i></b>,
 <b><i>u</i></b>&nbsp;&and;&nbsp;<img src="APLimg/vboscore.bmp">,
 <tt>⌈</tt><b><i>x</i></b><tt>&rceil;</tt>.</td>
 <td valign=top align=right><a href="APL1.htm#1.5"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td valign=top>Scalar multiple</td><td>&nbsp;</td><td nowrap>
 <b><i>z</i></b> &larr; <i>x</i> &times; <b><i>y</i></b><br>
 <b><i>z</i></b> &larr; <i>x</i><b><i>y</i></b><br>
 <b><i>c</i></b> &larr; <i>a</i> &times; <b><i>u</i></b><br>
 <b><i>c</i></b> &larr; <i>a</i><b><i>u</i></b></td><td>&nbsp;</td>
 <td colspan=3 valign=top><b><i>z</i></b><sub><i>&nbsp;i</i></sub> &larr; <i>x</i> &times; <b><i>y</i></b><sub><i>i</i></sub>, 
 and <b><i>c</i></b><sub><i>i</i></sub> &larr; <i>a</i> &times; <b><i>u</i></b><sub><i>i</i></sub></td>
 <td valign=top align=right><a href="APL1.htm#scalar_multiple"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td valign=top>Reduction</td><td>&nbsp;</td>
 <td valign=top><i>c</i> &larr; <img src="APLimg/circledot.bmp">/<b><i>a</i></b></td><td>&nbsp;</td>
 <td colspan=3><i>c</i> = (&#133;((<b><i>a</i></b><sub>1</sub> <img src="APLimg/circledot.bmp"> <b><i>a</i></b><sub>2</sub>)
 <img src="APLimg/circledot.bmp"> <b><i>a</i></b><sub>3</sub>)&#133;) <img src="APLimg/circledot.bmp"> <b><i>a</i></b><sub><i>&nu;</i></sub>),
 <td valign=top align=right><a href="APL1.htm#1.8"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td colspan=4>&nbsp;</td><td colspan=4>
 where <img src="APLimg/circledot.bmp"> is a binary operator
 or relation with a suitable domain.  Examples: 
 +/<b><i>x</i></b>, 
 &times;/<b><i>x</i></b>, 
 &ne;/<b><i>u</i></b>.
 Reduction of the null vector <tt><b>∊</b></tt>(0)
 is defined as the identity element 
 of the operator <img src="APLimg/circledot.bmp">.
 Examples:
 +/<tt><b>∊</b></tt>(0) = 0,
 &times;/<tt><b>∊</b></tt>(0) = 1,
 &or;/<tt><b>∊</b></tt>(0) = 0,
 &and;/<tt><b>∊</b></tt>(0) = 1.</td></tr>
<tr><td valign=top>Ranking</td><td colspan=6>&nbsp;</td>
 <td align=right><a href="APL1.htm#1.16"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td nowrap valign=top>&nbsp; <i>j</i>-origin <b><i>b</i></b>-index of <i>a</i></td><td>&nbsp;</td>
 <td nowrap valign=top><i>c</i> &larr; <b><i>b</i></b> <tt>⍳</tt><sub><i>j</i></sub> <i>a</i></td><td>&nbsp;</td>
 <td valign=top colspan=4><i>c</i> = <tt>∘</tt> if <i>a</i> <img src="APLimg/noteps.bmp"> <b><i>b</i></b>;
 otherwise <i>c</i> is the <i>j</i>-origin index 
 of the first occurrence of <i>a</i> in <b><i>b</i></b>.</td></tr>
<tr><td nowrap valign=top>&nbsp; <i>j</i>-origin <b><i>b</i></b>-index of <b><i>a</i></b></td><td>&nbsp;</td>
 <td nowrap valign=top><b><i>c</i></b> &larr; <b><i>b</i></b> <tt>⍳</tt><sub><i>j</i></sub> <b><i>a</i></b></td><td>&nbsp;</td>
 <td valign=top colspan=4><b><i>c</i></b><sub><i>i</i></sub> = <b><i>b</i></b> <tt>⍳</tt><sub><i>j</i></sub> <b><i>a</i></b><sub><i>i</i></sub></td></tr>
<tr><td valign=top>Left rotation</td><td>&nbsp;</td>
 <td valign=top><b><i>c</i></b> &larr; <i>k</i> <tt>↑</tt> <b><i>a</i></b></td><td>&nbsp;</td>
 <td nowrap colspan=3><b><i>c</i></b><sub><i>i</i></sub> = <b><i>a</i></b><sub><i>&nbsp;j</i></sub>,
 where <i>j</i> = <i>&nu;</i>(<b><i>a</i></b>) |<sub>1</sub> (<i>i</i> + <i>k</i>)</td>
 <td valign=top align=right><a href="APL1.htm#1.6"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td valign=top>Right rotation</td><td>&nbsp;</td>
 <td valign=top><b><i>c</i></b> &larr; <i>k</i> <tt>↓</tt> <b><i>a</i></b></td><td>&nbsp;</td>
 <td colspan=3><b><i>c</i></b><sub><i>i</i></sub> = <b><i>a</i></b><sub><i>&nbsp;j</i></sub>,
 where <i>j</i> = <i>&nu;</i>(<b><i>a</i></b>) |<sub>1</sub> (<i>i</i> &ndash; <i>k</i>)</td>
 <td valign=top align=right><a href="APL1.htm#right_rotation"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td valign=top>Base <b><i>y</i></b> value of <b><i>x</i></b></td><td>&nbsp;</td>
 <td valign=top><i>z</i> &larr; <b><i>y</i></b> <tt>⊥</tt> <b><i>x</i></b></td><td>&nbsp;</td>
 <td colspan=3><i>z</i> = +/(<b><i>p</i></b> &times; <b><i>x</i></b>), 
 where <b><i>p</i></b><sub><i>&nu;</i></sub> = 1, and
 <b><i>p</i></b><sub><i>i</i>&ndash;1</sub> = <br><b><i>p</i></b><sub><i>i</i></sub> &times; <b><i>y</i></b><sub><i>i</i></sub>
 <td valign=top align=right><a href="APL1.htm#base_value"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td>&nbsp;</td></tr>
<tr><td valign=top>Compression</td><td>&nbsp;</td>
 <td valign=top><b><i>c</i></b> &larr; <b><i>u</i></b>/<b><i>b</i></b></td><td>&nbsp;</td>
 <td colspan=3><b><i>c</i></b> is obtained from <b><i>b</i></b> by suppressing
 each <b><i>b</i></b><sub><i>i</i></sub> for which <b><i>u</i></b><sub><i>i</i></sub> = 0</td>
 <td valign=top align=right><a href="APL1.htm#1.9"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td valign=top>Expansion</td><td>&nbsp;</td>
 <td valign=top><b><i>c</i></b> &larr; <b><i>u</i></b>\<b><i>b</i></b></td><td>&nbsp;</td>
 <td colspan=3><img src="APLimg/uboscore.bmp">/<b><i>c</i></b> = 0,&nbsp;
 <b><i>u</i></b>/<b><i>c</i></b> = <b><i>b</i></b></td>
 <td valign=top align=right><a href="APL1.htm#expansion"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td valign=top>Mask</td><td>&nbsp;</td>
 <td nowrap valign=top><b><i>c</i></b> &larr; /<b><i>a</i></b>,<b><i>u</i></b<b>,<i>b</i></b>/</td><td>&nbsp;</td>
 <td colspan=3><img src="APLimg/uboscore.bmp">/<b><i>c</i></b> = <img src="APLimg/uboscore.bmp">/<b><i>a</i></b>,&nbsp;
 <b><i>u</i></b>/<b><i>c</i></b> = <b><i>u</i></b>/<b><i>b</i></b></td>
 <td valign=top align=right><a href="APL1.htm#mask"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td valign=top>Mesh</td><td>&nbsp;</td>
 <td nowrap valign=top><b><i>c</i></b> &larr; \<b><i>a</i></b>,<b><i>u</i></b>,<b><i>b</i></b>\</td><td>&nbsp;</td>
 <td colspan=3><img src="APLimg/uboscore.bmp">/<b><i>c</i></b> = <b><i>a</i></b>,&nbsp;
 <b><i>u</i></b>/<b><i>c</i></b> = <b><i>b</i></b></td>
 <td valign=top align=right><a href="APL1.htm#1.9.2"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td valign=top>Catenation</td><td>&nbsp;</td>
 <td nowrap valign=top><b><i>c</i></b> &larr; <b><i>a</i></b> <img src="APLimg/circleplus.bmp"> <b><i>b</i></b></td><td>&nbsp;</td>
 <td colspan=3><b><i>c</i></b> = (<b><i>a</i></b><sub>1</sub>, <b><i>a</i></b><sub>2</sub>,&#133; <b><i>a</i></b><sub><i>&nu;</i>(<b><i>a</i></b>)</sub>, 
 <b><i>b</i></b><sub>1</sub>, <b><i>b</i></b><sub>2</sub>,&#133; <b><i>b</i></b><sub><i>&nu;</i>(<b><i>b</i></b>)</sub>)<br>
 &nbsp; &nbsp;= \<b><i>a</i></b>, <tt><b>⍵</b></tt><sup><i>&nu;</i>(<b><i>b</i></b>)</sup>, <b><i>b</i></b>\</td>
 <td valign=top align=right><a href="APL1.htm#catenation"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td>&nbsp;</td></tr>
<tr><td valign=top>Characteristic of<br> <b><i>x</i></b> on <b><i>y</i></b></td><td>&nbsp;</td>
 <td valign=top><b><i>w</i></b> &larr; <tt><b>∊</b></tt><sub><b><i>y</i></b></sub><sup><b><i>x</i></b></sup></td><td>&nbsp;</td>
 <td valign=top colspan=3><b><i>w</i></b><sub><i>i</i></sub> = (<b><i>y</i></b><sub><i>i</i></sub> &epsilon; <b><i>x</i></b>); 
 <i>&nu;</i>(<b><i>w</i></b>) = <i>&nu;</i>(<b><i>y</i></b>)</td>
 <td align=right><a href="APL1.htm#characteristic_vector"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td valign=top><i>j</i>th unit vector</td><td>&nbsp;</td>
 <td valign=top><b><i>w</i></b> &larr; <tt><b>∊</b></tt><sup><i>&nbsp;j</i></sup>(<i>h</i>)</td><td>&nbsp;</td>
 <td valign=top><b><i>w</i></b><sub><i>i</i></sub> = (<i>i</i> = <i>j</i>)</td>
 <td rowspan=5><img src="APLimg/matrixr8.bmp"></td>
 <td>&nbsp;</td>
 <td valign=top align=right><a href="APL1.htm#unit_vector"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td valign=top>Full vector</td><td>&nbsp;</td>
 <td valign=top><b><i>w</i></b> &larr; <tt><b>∊</b></tt>(<i>h</i>)</td><td>&nbsp;</td>
 <td valign=top><b><i>w</i></b><sub><i>i</i></sub> = 1</td>
 <td>&nbsp;</td>
 <td valign=top align=right><a href="APL1.htm#full_vector"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td valign=top>Zero vector</td><td>&nbsp;</td>
 <td valign=top><b><i>w</i></b> &larr; <img src="APLimg/epsboscore.bmp">(<i>h</i>)<br>
 <b><i>w</i></b> &larr; 0</td><td>&nbsp;</td>
 <td valign=top><b><i>w</i></b><sub><i>i</i></sub> = 0</td>
 <td><i>&nu;</i>(<b><i>w</i></b>)=<i>h</i></td>
 <td valign=top align=right><a href="APL1.htm#zero_vector"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td valign=top>Prefix of weight <i>j</i></td><td>&nbsp;</td>
 <td valign=top><b><i>w</i></b> &larr; <tt><b>⍺</b></tt><sup><i>&nbsp;j</i></sup>(<i>h</i>)</td><td>&nbsp;</td>
 <td valign=top>First <i>k</i> of <b><i>w</i></b><sub><i>i</i></sub> are unity,<br>
 where <i>k</i> = min(<i>&nbsp;j</i>,<i>h</i>).</td> 
 <td>&nbsp;</td>
 <td valign=top align=right><a href="APL1.htm#prefix_vector"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td valign=top>Suffix of weight <i>j</i></td><td>&nbsp;</td>
 <td valign=top><b><i>w</i></b> &larr; <tt><b>⍵</b></tt><sup><i>&nbsp;j</i></sup>(<i>h</i>)</td><td>&nbsp;</td>
 <td valign=top>Last <i>k</i> of <b><i>w</i></b><sub><i>i</i></sub> are unity,<br>
 where <i>k</i> = min(<i>&nbsp;j</i>,<i>h</i>).</td>
 <td>&nbsp;</td>
 <td valign=top align=right><a href="APL1.htm#suffix_vector"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td valign=top>Maximum prefix</td><td>&nbsp;</td>
 <td valign=top><b><i>w</i></b> &larr; <tt>⍺</tt>/<b><i>u</i></b></td><td>&nbsp;</td>
 <td valign=top colspan=3><b><i>w</i></b> is the max length prefix in <b><i>u</i></b>.</td>
 <td align=right><a href="APL1.htm#maximum_prefix"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td colspan=4>&nbsp;<td colspan=4 valign=top>
 e.g. <tt>⍺/</tt>(1, 1, 0, 1, 0, 1) = (1, 1, 0, 0, 0, 0).</td></tr>
<tr><td valign=top>Maximum suffix</td><td>&nbsp;</td>
 <td valign=top><b><i>w</i></b> &larr; <tt>⍵</tt>/<b><i>u</i></b></td><td>&nbsp;</td>
 <td colspan=3 valign=top><b><i>w</i></b> is the max length suffix in <b><i>u</i></b>.</td>
 <td align=right><a href="APL1.htm#maximum_suffix"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td colspan=4>&nbsp;<td colspan=4 valign=top>
 e.g. <tt>⍵/</tt>(1, 1, 0, 1, 0, 1) = (0, 0, 0, 0, 0, 1).</td></tr>
<tr><td valign=top>Forward set<br>selector</td><td>&nbsp;</td>
 <td valign=top><b><i>w</i></b> &larr; <i>&sigma;</i>/<b><i>a</i></b></td><td>&nbsp;</td>
 <td colspan=3 valign=top><b><i>w</i></b><sub><i>i</i></sub> = 1 if <b><i>a</i></b><sub><i>&nbsp;j</i></sub> 
 &ne; <b><i>a</i></b><sub><i>&nbsp;i</i></sub> for all <i>j</i> &lt; <i>i</i></td>
 <td align=right><a href="APL1.htm#forward_set_selector"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td valign=top>Backward set<br>selector</td><td>&nbsp;</td>
 <td valign=top><b><i>w</i></b> &larr; <i>&tau;</i>/<b><i>a</i></b></td><td>&nbsp;</td>
 <td colspan=3 valign=top><b><i>w</i></b><sub><i>i</i></sub> = 1 if <b><i>a</i></b><sub><i>&nbsp;j</i></sub> 
 &ne; <b><i>a</i></b><sub><i>&nbsp;i</i></sub> for all <i>j</i> &gt; <i>i</i></td>
 <td align=right><a href="APL1.htm#backward_set_selector"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td valign=top>Maximum selector</td><td>&nbsp;</td>
 <td valign=top><b><i>w</i></b> &larr; <b><i>u</i></b><tt>⌈</tt><b><i>x</i></b></td><td>&nbsp;</td>
 <td valign=top colspan=3><b><i>w</i></b><sub><i>i</i></sub> = <b><i>u</i></b><sub><i>i</i></sub>
 &and; (<b><i>x</i></b><sub><i>i</i></sub> = <i>m</i>) where
 <i>m</i> = max(<b><i>u</i></b>/<b><i>x</i></b>)<sub><i>j</i></sub><br>
 <tt>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </tt>&nbsp;<sup><i>j</i></sup></td>
 <td valign=top align=right><a href="APL1.htm#maximum_selector"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td valign=top>Minimum selector</td><td>&nbsp;</td>
 <td valign=top><b><i>w</i></b> &larr; <b><i>u</i></b><tt>⌊</tt><b><i>x</i></b></td><td>&nbsp;</td>
 <td colspan=3 valign=top><b><i>w</i></b><sub><i>i</i></sub> = <b><i>u</i></b><sub><i>i</i></sub>
 &and; (<b><i>x</i></b><sub><i>i</i></sub> = <i>m</i>) where
 <i>m</i> = min(<b><i>u</i></b>/<b><i>x</i></b>)<sub><i>j</i></sub><br>
 <tt>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </tt>&nbsp;<sup><i>j</i></sup></td>
 <td valign=top align=right><a href="APL1.htm#minimum_selector"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td valign=top>Interval or <i>j</i>-origin identity permutation vector</td><td>&nbsp;</td>
 <td valign=top><b><i>k</i></b> &larr; <tt><b>⍳</b></tt><sup><i>j</i></sup>(<i>h</i>)</td><td>&nbsp;</td>
 <td valign=top colspan=3><b><i>k</i></b> = (<i>j</i>, <i>j</i>+1, &#133;, <i>j</i>+<i>h</i>&ndash;1)</td>
 <td valign=top align=right><a href="APL1.htm#interval_vector"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td valign=top><i>j</i>-origin identity permutation vector</td><td>&nbsp;</td>
 <td valign=top><b><i>k</i></b></td><td>&nbsp;</td>
 <td valign=top colspan=3><b><i>k</i></b> = <tt><b>⍳</b></tt><sup><i>j</i></sup>(<i>&nu;</i>(<b><i>k</i></b>))</td>
 <td valign=top align=right><a href="APL1.htm#identity_permutation"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td valign=top><i>j</i>-origin mapping</td><td>&nbsp;</td>
 <td valign=top><b><i>c</i></b> &larr; <b><i>a</i></b><sub><b><i>b</i></b></sub><br>
  <b><i>c</i></b> &larr; <b><i>b</i></b>&int;<sub><i>j</i></sub><b><i>a</i></b></td><td>&nbsp;</td>
 <td colspan=3 valign=top><b><i>c</i></b><sub><i>i</i></sub> = <tt>∘</tt> 
 if <b><i>b</i></b><sub><i>i</i></sub> <img src="APLimg/noteps.bmp">
 <tt><b>⍳</b></tt><sup><i>j</i></sup>(<i>&nu;</i>(<b><i>a</i></b>));
 otherwise <b><i>c</i></b><sub><i>i</i></sub> = 
 <b><i>a</i></b><sub><b><i>b</i></b><sub><i>i</i></sub></sub>
 in a <i>j</i>-origin system for <b><i>a</i></b>.
 In the first form (that is, <b><i>c</i></b> &larr; <b><i>a</i></b><sub><b><i>b</i></b></sub>),
 the origin cannot be specified directly.</td>
 <td valign=top align=right><a href="APL1.htm#1.17.2"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td valign=top><i>j</i>-origin ordering</td><td>&nbsp;</td>
 <td valign=top><b><i>k</i></b> &larr; &theta;<sub><i>j</i></sub>/<b><i>x</i></b></td><td>&nbsp;</td>
 <td colspan=3><b><i>y</i></b> = <b><i>k</i></b>&nbsp;&int;<sub><i>j</i>&nbsp;</sub><b><i>x</i></b>
 is in ascending order and original relative ordering
 is maintained among equal components,
 that is, either 
 <b><i>y</i></b><sub><i>i</i></sub> &lt; <b><i>y</i></b><sub><i>i</i>+1</sub> or
 <b><i>y</i></b><sub><i>i</i></sub> = <b><i>y</i></b><sub><i>i</i>+1</sub> and
 <b><i>k</i></b><sub><i>i</i></sub> &lt; <b><i>k</i></b><sub><i>i</i>+1</sub></td>
 <td valign=top align=right><a href="APL1.htm#1.17.4"><img src="APLimg/link.bmp"></a></td></tr>
</table>
<br>



<a name="s.6a"></a>
<p><b>S.6a Row Generalizations of Vector Operations</b></p>

<table>
<tr><td nowrap><b><i>Z</i></b> &larr; <b><i>X</i></b> <img src="APLimg/circledot.bmp">
 <b><i>Y</i></b><sup>&nbsp;</sup><sub>&nbsp;</sup></td>
 <td nowrap>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
 <td nowrap colspan=2><b><i>Z</i></b><sub><i>&nbsp;j</i></sub><sup><i>&nbsp;i</i></sup> = 
 <b><i>X</i></b><sub><i>&nbsp;j</i></sub><sup><i>&nbsp;i</i></sup> <img src="APLimg/circledot.bmp">
 <b><i>Y</i></b><sub><i>&nbsp;j</i></sub><sup><i>&nbsp;i</i></sup></td>
 <td width=300>&nbsp;</td>
 <td align=right><a href="APL1.htm#1.5.2"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td><b><i>z</i></b> &larr; <img src="APLimg/circledot.bmp">/<b><i>X</i></b> 
 <sub>&nbsp;</sub><sup>&nbsp;</sup></td>
 <td>&nbsp;</td>
 <td colspan=2><b><i>z</i></b><sub><i>&nbsp;i</i></sub> = 
 <img src="APLimg/circledot.bmp">/<b><i>X</i></b><sup><i>&nbsp;i</i></sup></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#reduce_row"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td><b><i>C</i></b> &larr; <img src="APLimg/circletimes.bmp">/<b><i>A</i></b> 
 <sup>&nbsp;</sup><sub>&nbsp;</sup></td>
 <td>&nbsp;</td>
 <td nowrap colspan=2><b><i>C</i></b> = <b><i>A</i></b><sub><i>1</i></sub>
 <img src="APLimg/circletimes.bmp"> <b><i>A</i></b><sub><i>2</i></sub>
 <img src="APLimg/circletimes.bmp"> &#133; <img src="APLimg/circletimes.bmp"> 
 <b><i>A</i></b><sub><i>&nu;</i></sub></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#cp_reduce"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td nowrap><b><i>M</i></b> &larr; <b><i>B</i></b> <tt>⍳</tt><sub><i>h</i></sub>
 <b><i>A</i></b><sup>&nbsp;</sup><sub>&nbsp;</sup></td>
 <td>&nbsp;</td>
 <td colspan=2><b><i>M</i></b><sup><i>&nbsp;i</i></sup> = 
 <b><i>B</i></b><sup><i>&nbsp;i</i></sup> <tt>⍳</tt><sub><i>h</i></sub>
 <b><i>A</i></b><sup><i>&nbsp;i</i></sup></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#iota_row"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td nowrap><b><i>C</i></b> &larr; <b><i>k</i></b> &uarr;
 <b><i>A</i></b><sup>&nbsp;</sup><sub>&nbsp;</sup></td>
 <td>&nbsp;</td>
 <td colspan=2><b><i>C</i></b><sup><i>&nbsp;i</i></sup> = 
 <b><i>k</i></b><sub><i>&nbsp;i</i></sub> &uarr;
 <b><i>A</i></b><sup><i>&nbsp;i</i></sup></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#rotate_row"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td nowrap><b><i>C</i></b> &larr; <b><i>k</i></b> &darr;
 <b><i>A</i></b><sup>&nbsp;</sup><sub>&nbsp;</sup></td>
 <td>&nbsp;</td>
 <td colspan=2><b><i>C</i></b><sup><i>&nbsp;i</i></sup> = 
 <b><i>k</i></b><sub><i>&nbsp;i</i></sub> &darr;
 <b><i>A</i></b><sup><i>&nbsp;i</i></sup></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#rotate_row"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td nowrap><b><i>z</i></b> &larr; <b><i>Y</i></b> <tt>⊥</tt> 
 <b><i>X</i></b><sup>&nbsp;</sup><sub>&nbsp;</sup></td>
 <td>&nbsp;</td>
 <td colspan=2><b><i>z</i></b><sub><i>&nbsp;i</i></sub> = 
 <b><i>Y</i></b><sup><i>&nbsp;i</i></sup> <tt>⊥</tt>
 <b><i>X</i></b><sup><i>&nbsp;i</i></sup></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#1.14"><img src="APLimg/link.bmp"></td>
 </tr>
<tr><td>&nbsp;</td></tr>
<tr><td nowrap><b><i>C</i></b> &larr; 
 <b><i>A</i></b><sub><b><i>b</i></b></sub></td>
 <td>&nbsp;</td>
 <td colspan=2><b><i>C</i></b><sub><i>&nbsp;j</i></sub> = 
 <b><i>A</i></b><sub><b><i>b</i></b><sub><i>j</i></sub></sub></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#sub_row"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td nowrap><b><i>C</i></b> &larr; 
 <b><i>B</i></b> &int;<sub><i>h</i></sub> <b><i>A</i></b><sup>&nbsp;</sup></td>
 <td>&nbsp;</td>
 <td colspan=2><b><i>C</i></b><sup><i>&nbsp;i</i></sup> = 
 <b><i>B</i></b><sup><i>&nbsp;i</i></sup> &int;<sub><i>h</i></sub> 
 <b><i>A</i></b><sup><i>&nbsp;i</i></sup></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#index_row"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td nowrap><b><i>K</i></b> &larr; 
 <i>&theta;</i><sub><i>h</i></sub>/<b><i>X</i></b><sup>&nbsp;</sup></td>
 <td>&nbsp;</td>
 <td colspan=2><b><i>K</i></b><sup><i>&nbsp;i</i></sup> = 
 <i>&theta;</i><sub><i>h</i></sub>/<b><i>X</i></b><sup><i>&nbsp;i</i></sup></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#1.17.4"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td>&nbsp;</td></tr>
<tr><td nowrap><b><i>C</i></b> &larr; <b><i>A</i></b>
 <img src="APLimg/circleplus.bmp"> <b><i>B</i></b><sup>&nbsp;</sup></td>
 <td>&nbsp;</td>
 <td colspan=2><b><i>C</i></b><sup><i>&nbsp;i</i></sup> = <b><i>A</i></b><sup><i>&nbsp;i</i></sup>
 <img src="APLimg/circleplus.bmp"> <b><i>B</i></b><sup><i>&nbsp;i</i></sup></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#catenation"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td nowrap><b><i>C</i></b> &larr; 
 <b><i>u</i></b>/<b><i>B</i></b><sup>&nbsp;</sup></td>
 <td>&nbsp;</td>
 <td colspan=2><b><i>C</i></b><sup><i>&nbsp;i</i></sup> = 
 <b><i>u</i></b>/<b><i>B</i></b><sup><i>&nbsp;i</i></sup></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#compress_row"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td nowrap><b><i>c</i></b> &larr; 
 <b><i>U</i></b>/<b><i>B</i></b><sup>&nbsp;</sup></td>
 <td>&nbsp;</td>
 <td nowrap colspan=2><b><i>c</i></b> = <b><i>U</i></b><sup>1</sup>/<b><i>B</i></b><sup>1</sup>
 <img src="APLimg/circleplus.bmp"> &#133; <img src="APLimg/circleplus.bmp">
 <b><i>U</i></b><sup><i>&nbsp;&mu;</i></sup>/<b><i>B</i></b><sup><i>&nbsp;&mu;</i></sup></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#compress_rowrow"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td nowrap><b><i>C</i></b> &larr; 
 <b><i>u</i></b>\<b><i>B</i></b><sup>&nbsp;</sup></td>
 <td>&nbsp;</td>
 <td><img src="APLimg/uboscore.bmp">/<b><i>C</i></b> = 0,</td>
 <td><b><i>u</i></b>/<b><i>C</i></b> = <b><i>B</i></b></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#expand_row"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td nowrap><b><i>C</i></b> &larr; 
 <b><i>U</i></b>\<b><i>b</i></b><sup>&nbsp;</sup></td>
 <td>&nbsp;</td>
 <td><img src="APLimg/ucapboscore.bmp">/<b><i>C</i></b> = 0,</td>
 <td><b><i>U</i></b>/<b><i>C</i></b> = <b><i>b</i></b></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#1.9.2"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td nowrap><b><i>C</i></b> &larr; 
 \<b><i>A</i></b>, <b><i>u</i></b>, <b><i>B</i></b>\</td>
 <td>&nbsp;</td>
 <td><img src="APLimg/uboscore.bmp">/<b><i>C</i></b> = <b><i>A</i></b>,</td>
 <td><b><i>u</i></b>/<b><i>C</i></b> = <b><i>B</i></b></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#1.9.2"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td nowrap><b><i>C</i></b> &larr; 
 \<b><i>a</i></b>, <b><i>U</i></b>, <b><i>b</i></b>\</td>
 <td>&nbsp;</td>
 <td><img src="APLimg/ucapboscore.bmp">/<b><i>C</i></b> = <b><i>a</i></b>,</td>
 <td><b><i>U</i></b>/<b><i>C</i></b> = <b><i>b</i></b></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#1.9.2"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td nowrap><b><i>C</i></b> &larr; 
 /<b><i>A</i></b>, <b><i>u</i></b>, <b><i>B</i></b>/</td>
 <td>&nbsp;</td>
 <td><img src="APLimg/uboscore.bmp">/<b><i>C</i></b> = <img src="APLimg/uboscore.bmp">/<b><i>A</i></b>,</td>
 <td><b><i>u</i></b>/<b><i>C</i></b> = <b><i>u</i></b>/<b><i>B</i></b></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#1.9.2"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td nowrap><b><i>C</i></b> &larr; 
 /<b><i>A</i></b>, <b><i>U</i></b>, <b><i>B</i></b>/</td>
 <td>&nbsp;</td>
 <td><img src="APLimg/ucapboscore.bmp">/<b><i>C</i></b> = <img src="APLimg/ucapboscore.bmp">/<b><i>A</i></b>,</td>
 <td><b><i>U</i></b>/<b><i>C</i></b> = <b><i>U</i></b>/<b><i>B</i></b></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#1.9.2"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td nowrap><b><i>C</i></b> &larr; 
 /<b><i>a</i></b>, <b><i>U</i></b>, <b><i>b</i></b>/</td>
 <td>&nbsp;</td>
 <td colspan=2><b><i>C</i></b> = /<font face=Arial><b><i>E</i></b></font>\<b><i>a</i></b>,
 <b><i>U</i></b>, 
 <font face=Arial><b><i>E</i></b></font>\<b><i>b</i></b>/</td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#1.9.2"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td>&nbsp;</td></tr>
<tr><td><b><i>W</i></b> &larr; <tt>⍺</tt>/<b><i>U</i></b><sup>&nbsp;</sup></td>
 <td>&nbsp;</td>
 <td colspan=2><b><i>W</i></b><sup><i>&nbsp;i</i></sup> = <tt>⍺</tt>/<b><i>U</i></b><sup><i>&nbsp;i</i></sup></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#prefix_row"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td><b><i>W</i></b> &larr; <tt>⍵</tt>/<b><i>U</i></b><sup>&nbsp;</sup></td>
 <td>&nbsp;</td>
 <td colspan=2><b><i>W</i></b><sup><i>&nbsp;i</i></sup> = <tt>⍵</tt>/<b><i>U</i></b><sup><i>&nbsp;i</i></sup></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#prefix_row"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td><b><i>W</i></b> &larr; <i>&sigma;</i>/<b><i>U</i></b><sup>&nbsp;</sup></td>
 <td>&nbsp;</td>
 <td colspan=2><b><i>W</i></b><sup><i>&nbsp;i</i></sup> = <i>&sigma;</i>/<b><i>U</i></b><sup><i>&nbsp;i</i></sup></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#set_selector_row"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td><b><i>W</i></b> &larr; <i>&tau;</i>/<b><i>U</i></b><sup>&nbsp;</sup></td>
 <td>&nbsp;</td>
 <td colspan=2><b><i>W</i></b><sup><i>&nbsp;i</i></sup> = <i>&tau;</i>/<b><i>U</i></b><sup><i>&nbsp;i</i></sup></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#set_selector_row"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td><b><i>W</i></b> &larr; <b><i>U</i></b><tt>⌈</tt><b><i>X</i></b><sup>&nbsp;</sup></td>
 <td>&nbsp;</td>
 <td colspan=2><b><i>W</i></b><sup><i>&nbsp;i</i></sup> = 
 <b><i>U</i></b><sup><i>&nbsp;i</i></sup><tt>⌈</tt><b><i>X</i></b><sup><i>&nbsp;i</i></sup></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#max_row"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td><b><i>W</i></b> &larr; <b><i>U</i></b><tt>⌊</tt><b><i>X</i></b><sup>&nbsp;</sup></td>
 <td>&nbsp;</td>
 <td colspan=2><b><i>W</i></b><sup><i>&nbsp;i</i></sup> = 
 <b><i>U</i></b><sup><i>&nbsp;i</i></sup><tt>⌊</tt><b><i>X</i></b><sup><i>&nbsp;i</i></sup></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#max_row"><img src="APLimg/link.bmp"></a></td>
 </tr>
</table>
<br>



<a name="s.6b"></a>
<p><b>S.6b Column Generalizations of Vector Operations</b></p>

<table>
<tr><td nowrap><b><i>Z</i></b> &larr; <b><i>X</i></b> <img src="APLimg/circledot.bmp">
 <b><i>Y</i></b><sup>&nbsp;</sup><sub>&nbsp;</sup></td>
 <td nowrap>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
 <td nowrap colspan=2><b><i>Z</i></b><sub><i>&nbsp;j</i></sub><sup><i>&nbsp;i</i></sup> = 
 <b><i>X</i></b><sub><i>&nbsp;j</i></sub><sup><i>&nbsp;i</i></sup> <img src="APLimg/circledot.bmp">
 <b><i>Y</i></b><sub><i>&nbsp;j</i></sub><sup><i>&nbsp;i</i></sup></td>
 <td width=300>&nbsp;</td>
 <td align=right><a href="APL1.htm#1.5.2"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td><b><i>z</i></b> &larr; <img src="APLimg/circledot.bmp">//<b><i>X</i></b> 
 <sub>&nbsp;</sup></td>
 <td>&nbsp;</td>
 <td colspan=2><b><i>z</i></b><sub><i>&nbsp;j</i></sub> = 
 <img src="APLimg/circledot.bmp">/<b><i>X</i></b><sub><i>&nbsp;j</i></sub></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#reduce_col"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td><b><i>C</i></b> &larr; <img src="APLimg/circletimes.bmp">//<b><i>A</i></b> 
 <sup>&nbsp;</sup><sub>&nbsp;</sup></td>
 <td>&nbsp;</td>
 <td nowrap colspan=2><b><i>C</i></b> = <b><i>A</i></b><sup><i>1</i></sup>
 <img src="APLimg/circletimes.bmp"> <b><i>A</i></b><sup><i>2</i></sup>
 <img src="APLimg/circletimes.bmp"> &#133; <img src="APLimg/circletimes.bmp"> 
 <b><i>A</i></b><sup><i>&mu;</i></sup> </td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#cp_reduce"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td nowrap><b><i>M</i></b> &larr; <b><i>B</i></b> <tt>⍳⍳</tt><sub><i>h</i></sub>
 <b><i>A</i></b><sub>&nbsp;</sup></td>
 <td>&nbsp;</td>
 <td colspan=2><b><i>M</i></b><sub><i>&nbsp;j</i></sub> = 
 <b><i>B</i></b><sub><i>&nbsp;j</i></sub> <tt>⍳</tt><sub><i>h</i></sub>
 <b><i>A</i></b><sub><i>&nbsp;j</i></sub></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#iota_col"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td nowrap><b><i>C</i></b> &larr; <b><i>k</i></b> <img src="APLimg/uarr.bmp">
 <b><i>A</i></b><sub>&nbsp;</sup></td>
 <td>&nbsp;</td>
 <td colspan=2><b><i>C</i></b><sub><i>&nbsp;j</i></sub> = 
 <b><i>k</i></b><sub><i>&nbsp;j</i></sub> &uarr;
 <b><i>A</i></b><sub><i>&nbsp;j</i></sub></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#rotate_col"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td nowrap><b><i>C</i></b> &larr; <b><i>k</i></b> <img src="APLimg/darr.bmp">
 <b><i>A</i></b><sub>&nbsp;</sup></td>
 <td>&nbsp;</td>
 <td colspan=2><b><i>C</i></b><sub><i>&nbsp;j</i></sub> = 
 <b><i>k</i></b><sub><i>&nbsp;j</i></sub> &darr;
 <b><i>A</i></b><sub><i>&nbsp;j</i></sub></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#rotate_col"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td nowrap><b><i>z</i></b> &larr; <b><i>Y</i></b> <img src="APLimg/decode2.bmp"> 
 <b><i>X</i></b><sub>&nbsp;</sup></td>
 <td>&nbsp;</td>
 <td colspan=2><b><i>z</i></b><sub><i>&nbsp;j</i></sub> = 
 <b><i>Y</i></b><sub><i>&nbsp;j</i></sub> <tt>⊥</tt>
 <b><i>X</i></b><sub><i>&nbsp;j</i></sub></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#1.20"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td>&nbsp;</td></tr>
<tr><td nowrap><b><i>C</i></b> &larr; 
 <b><i>A</i></b><sup><b><i>b</i></b></sup></td>
 <td>&nbsp;</td>
 <td colspan=2><b><i>C</i></b><sup><i>&nbsp;i</i></sup> = 
 <b><i>A</i></b><sup><b><i>b</i></b><sub><i>i</i></sub></sup></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#sub_col"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td nowrap><b><i>C</i></b> &larr; 
 <b><i>B</i></b> &int;&int;<sub><i>h</i></sub> <b><i>A</i></b><sup>&nbsp;</sup>
 <td>&nbsp;</td>
 <td colspan=2><b><i>C</i></b><sub><i>&nbsp;j</i></sub> = 
 <b><i>B</i></b><sub><i>&nbsp;j</i></sub> &int;<sub><i>h</i></sub> 
 <b><i>A</i></b><sub><i>&nbsp;j</i></sub></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#index_col"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td nowrap><b><i>K</i></b> &larr; 
 <i>&theta;</i><sub><i>h</i></sub>//<b><i>X</i></b><sup>&nbsp;</sup></td>
 <td>&nbsp;</td>
 <td colspan=2><b><i>K</i></b><sub><i>&nbsp;j</i></sub> = 
 <i>&theta;</i><sub><i>h</i></sub>/<b><i>X</i></b><sub><i>&nbsp;j</i></sub></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#theta_col"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td>&nbsp;</td></tr>
<tr><td nowrap><b><i>C</i></b> &larr; <b><i>A</i></b>
 <img src="APLimg/circleplus.bmp"><img src="APLimg/circleplus.bmp"> 
 <b><i>B</i></b><sub>&nbsp;</sub></td>
 <td>&nbsp;</td>
 <td colspan=2><b><i>C</i></b><sub><i>&nbsp;j</i></sub> = <b><i>A</i></b><sub><i>&nbsp;j</i></sub>
 <img src="APLimg/circleplus.bmp"> <b><i>B</i></b><sub><i>&nbsp;j</i></sub></td>
 </tr>
<tr><td nowrap><b><i>C</i></b> &larr; 
 <b><i>u</i></b>//<b><i>B</i></b><sub>&nbsp;</sub></td>
 <td>&nbsp;</td>
 <td colspan=2><b><i>C</i></b><sub><i>&nbsp;j</i></sub> = 
 <b><i>u</i></b>/<b><i>B</i></b><sub><i>&nbsp;j</i></sub></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#compress_col"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td nowrap><b><i>c</i></b> &larr; 
 <b><i>U</i></b>//<b><i>B</i></b><sub>&nbsp;</sub></td>
 <td>&nbsp;</td>
 <td nowrap colspan=2><b><i>c</i></b> = <b><i>U</i></b><sub>1</sub>/<b><i>B</i></b><sub>1</sub>
 <img src="APLimg/circleplus.bmp"> &#133; <img src="APLimg/circleplus.bmp">
 <b><i>U</i></b><sub><i>&nbsp;&nu;</i></sub>/<b><i>B</i></b><sub><i>&nbsp;&nu;</i></sub></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#compress_colcol"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td nowrap><b><i>C</i></b> &larr; 
 <b><i>u</i></b>\\<b><i>B</i></b><sup>&nbsp;</sup></td>
 <td>&nbsp;</td>
 <td><img src="APLimg/uboscore.bmp">//<b><i>C</i></b> = 0,</td>
 <td><b><i>u</i></b>//<b><i>C</i></b> = <b><i>B</i></b></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#expand_col"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td nowrap><b><i>C</i></b> &larr; 
 <b><i>U</i></b>\\<b><i>b</i></b><sup>&nbsp;</sup></td>
 <td>&nbsp;</td>
 <td><img src="APLimg/ucapboscore.bmp">//<b><i>C</i></b> = 0,</td>
 <td><b><i>U</i></b>//<b><i>C</i></b> = <b><i>b</i></b></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#1.9.2"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td nowrap><b><i>C</i></b> &larr; 
 \\<b><i>A</i></b>, <b><i>u</i></b>, <b><i>B</i></b>\\</td>
 <td>&nbsp;</td>
 <td><img src="APLimg/uboscore.bmp">//<b><i>C</i></b> = <b><i>A</i></b>,</td>
 <td><b><i>u</i></b>//<b><i>C</i></b> = <b><i>B</i></b></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#1.9.2"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td nowrap><b><i>C</i></b> &larr; 
 \\<b><i>a</i></b>, <b><i>U</i></b>, <b><i>b</i></b>\\</td>
 <td>&nbsp;</td>
 <td><img src="APLimg/ucapboscore.bmp">//<b><i>C</i></b> = <b><i>a</i></b>,</td>
 <td><b><i>U</i></b>//<b><i>C</i></b> = <b><i>b</i></b></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#1.9.2"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td nowrap><b><i>C</i></b> &larr; 
 //<b><i>A</i></b>, <b><i>u</i></b>, <b><i>B</i></b>//</td>
 <td>&nbsp;</td>
 <td nowrap><img src="APLimg/uboscore.bmp">//<b><i>C</i></b> = <img src="APLimg/uboscore.bmp">//<b><i>A</i></b>,</td>
 <td><b><i>u</i></b>//<b><i>C</i></b> = <b><i>u</i></b>//<b><i>B</i></b></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#1.9.2"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td nowrap><b><i>C</i></b> &larr; 
 //<b><i>A</i></b>, <b><i>U</i></b>, <b><i>B</i></b>//</td>
 <td>&nbsp;</td>
 <td nowrap><img src="APLimg/ucapboscore.bmp">//<b><i>C</i></b> = <img src="APLimg/ucapboscore.bmp">//<b><i>A</i></b>,</td>
 <td nowrap><b><i>U</i></b>//<b><i>C</i></b> = <b><i>U</i></b>//<b><i>B</i></b></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#1.9.2"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td nowrap><b><i>C</i></b> &larr; 
 //<b><i>a</i></b>, <b><i>U</i></b>, <b><i>b</i></b>//</td>
 <td>&nbsp;</td>
 <td colspan=2><b><i>C</i></b> = /<font face=Arial><b><i>E</i></b></font>\\<b><i>a</i></b>,
 <b><i>U</i></b>, 
 <font face=Arial><b><i>E</i></b></font>\\<b><i>b</i></b>/</td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#1.9.2"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td>&nbsp;</td></tr>
<tr><td><b><i>W</i></b> &larr; <tt>⍺</tt>//<b><i>U</i></b><sub>&nbsp;</sub></td>
 <td>&nbsp;</td>
 <td colspan=2><b><i>W</i></b><sub><i>&nbsp;j</i></sub> = <tt>⍺</tt>/<b><i>U</i></b><sub><i>&nbsp;j</i></sub></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#prefix_col"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td><b><i>W</i></b> &larr; <tt>⍵</tt>//<b><i>U</i></b><sub>&nbsp;</sub></td>
 <td>&nbsp;</td>
 <td colspan=2><b><i>W</i></b><sub><i>&nbsp;j</i></sub> = <tt>⍵</tt>/<b><i>U</i></b><sub><i>&nbsp;j</i></sub></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#prefix_col"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td><b><i>W</i></b> &larr; <i>&sigma;</i>//<b><i>U</i></b><sub>&nbsp;</sub></td>
 <td>&nbsp;</td>
 <td colspan=2><b><i>W</i></b><sub><i>&nbsp;j</i></sub> = <i>&sigma;</i>/<b><i>U</i></b><sub><i>&nbsp;j</i></sub></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#set_selector_col"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td><b><i>W</i></b> &larr; <i>&tau;</i>//<b><i>U</i></b><sub>&nbsp;</sub></td>
 <td>&nbsp;</td>
 <td colspan=2><b><i>W</i></b><sub><i>&nbsp;j</i></sub> = <i>&tau;</i>/<b><i>U</i></b><sub><i>&nbsp;j</i></sub></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#set_selector_col"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td><b><i>W</i></b> &larr; <b><i>U</i></b><tt>⌈⌈</tt><b><i>X</i></b><sub>&nbsp;</sub></td>
 <td>&nbsp;</td>
 <td colspan=2><b><i>W</i></b><sub><i>&nbsp;j</i></sub> = 
 <b><i>U</i></b><sub><i>&nbsp;j</i></sub><tt>⌈</tt><b><i>X</i></b><sub><i>&nbsp;j</i></sub></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#max_col"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td><b><i>W</i></b> &larr; <b><i>U</i></b><tt>⌊⌊</tt><b><i>X</i></b><sup>&nbsp;</sup></td>
 <td>&nbsp;</td>
 <td colspan=2><b><i>W</i></b><sub><i>&nbsp;j</i></sub> = 
 <b><i>U</i></b><sub><i>&nbsp;j</i></sub><tt>⌊</tt><b><i>X</i></b><sub><i>&nbsp;j</i></sub></td>
 <td>&nbsp;</td>
 <td align=right><a href="APL1.htm#max_col"><img src="APLimg/link.bmp"></a></td>
 </tr>
</table>
<br>



<a name="s.7"></a>
<p><b>S.7 Special Matrices</b></p>

<table>
<tr><td>Full matrix</td>
 <td><b><i>W</i></b> &larr; <font face=Arial><b><i>E</i></b></font>(<i>p</i>, <i>q</i>)</td><td>&nbsp;</td>
 <td colspan=3><b><i>W</i></b><sub><i>j</i></sub><sup><i>i</i></sup> = 1</td>
 <td rowspan=9><img src="APLimg/bracketsx7a.bmp"></td>
 <td rowspan=9>
  <i>&mu;</i>(<b><i>W</i></b>) = <i>p</i><br>
  <i>&nu;</i>(<b><i>W</i></b>) = <i>q</i>,<br>
  for <i>p</i> and <i>q</i> integers.
  Elision of <i>p</i> and <i>q</i> if dimensions
  determined by compatibility.</td> 
 <td valign=top align=right><sup>&nbsp;</sup><a href="APL1.htm#full_matrix"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td>Zero matrix</td>
 <td><b><i>W</i></b> &larr; <img src="APLimg/ecapboscore.bmp">(<i>p</i>, <i>q</i>)</td><td>&nbsp;</td>
 <td colspan=3><b><i>W</i></b><sub><i>j</i></sub><sup><i>i</i></sup> = 0</td>
 <td valign=top align=right><sup>&nbsp;</sup><a href="APL1.htm#zero_matrix"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td>&nbsp;</td>
 <td><b><i>W</i></b> &larr; 0</td></tr>
<tr><td>Superdiagonal&nbsp;</td>
 <td nowrap><b><i>W</i></b> &larr; <sup><i>k</i></sup><font face=Arial><b><i>I</i></b></font>(<i>p</i>, <i>q</i>)</td><td>&nbsp;</td>
 <td colspan=3 nowrap><b><i>W</i></b><sub><i>j</i></sub><sup><i>i</i></sup> = (<i>i</i> + <i>k</i> = <i>j</i>)</td>
 <td valign=top align=right><sup>&nbsp;</sup><a href="APL1.htm#superdiagonal_matrix"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td>Identity</td>
 <td nowrap><b><i>W</i></b> &larr; <font face=Arial><b><i>I</i></b></font>(<i>p</i>, <i>q</i>)</td><td>&nbsp;</td>
 <td colspan=3 nowrap><b><i>W</i></b> = <sup>0</sup><font face=Arial><b><i>I</i></b></font>(<i>p</i>, <i>q</i>)<sub>&nbsp;</sub></td>
 <td valign=top align=right><sup>&nbsp;</sup><a href="APL1.htm#identity_matrix"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td>Upper left (triangle)</td>
 <td valign=top nowrap><b><i>W</i></b> &larr; <img src="APLimg/quadnw.bmp">(<i>p</i>, <i>q</i>)</td><td>&nbsp;</td>
 <td valign=top><b><i>W</i></b><sub><i>j</i></sub><sup><i>i</i></sup></td>
 <td rowspan=4><img src="APLimg/bracketsx7b.bmp"></td>
 <td rowspan=4>=&nbsp;(<i>i</i>&nbsp;+&nbsp;<i>j</i>&nbsp;&le;&nbsp;<i>m</i>),<br><i>m</i>&nbsp;=&nbsp;min(<i>p</i>,&nbsp;<i>q</i>)</td>
 <td valign=top align=right><sup>&nbsp;</sup><a href="APL1.htm#triangular_matrix"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td valign=top>Upper right</td>
 <td valign=top><b><i>W</i></b> &larr; <img src="APLimg/quadne.bmp">(<i>p</i>, <i>q</i>)</td><td>&nbsp;</td>
 <td><img src="APLimg/sx7a.bmp"></td>
 <td valign=top align=right><sup>&nbsp;</sup><a href="APL1.htm#triangular_matrix"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td>Lower left</td>
 <td valign=top><b><i>W</i></b> &larr; <img src="APLimg/quadsw.bmp">(<i>p</i>, <i>q</i>)</td><td>&nbsp;</td>
 <td><img src="APLimg/sx7b.bmp"></td>
 <td valign=top align=right><sup>&nbsp;</sup><a href="APL1.htm#triangular_matrix"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td valign=top>Lower right</td>
 <td valign=top><b><i>W</i></b> &larr; <img src="APLimg/quadse.bmp">(<i>p</i>, <i>q</i>)</td><td>&nbsp;</td>
 <td><img src="APLimg/sx7c.bmp"></td>
 <td valign=top align=right><sup>&nbsp;</sup><a href="APL1.htm#triangular_matrix"><img src="APLimg/link.bmp"></a></td></tr>
</table>
<br>



<a name="s.8"></a>
<p><b>S.8 Transposition</b></p>

<table cellpadding=5>
<tr><td valign=top>Diagonal</td><td>&nbsp;</td><td>
 <b><i>C</i></b> &larr; <img src="APLimg/btilde.bmp"></td>
 <td>&nbsp; &nbsp; &nbsp; </td>
 <td valign=top nowrap><b><i>C</i></b><sub><i>i</i></sub><sup><i>&nbsp;j</i></sup> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;=</td>
 <td rowspan=5><img align=middle src="APLimg/bracketsx8.bmp"> &nbsp; <b><i>B</i></b><sub><i>j&nbsp;</i></sub><sup><i>i</i></sup></td>
 <td width=135 align=right valign=top><a href="APL1.htm#b_tilde"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>
 <b><i>C</i></b> &larr; <img src="APLimg/bnwarr.bmp"></td>
 <td>&nbsp;</td>
 <td>&nbsp;</td>
 <td align=right valign=top><a href="APL1.htm#1.12"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td>Counter diagonal</td><td>&nbsp;</td><td>
 <b><i>C</i></b> &larr; <img src="APLimg/bnearr.bmp"></td>
 <td>&nbsp;</td>
 <td><img align=middle src="APLimg/sx8a.bmp"></td>
 <td align=right valign=top><a href="APL1.htm#1.12"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td>Horizontal</td><td>&nbsp;</td><td>
 <b><i>C</i></b> &larr; <img src="APLimg/brarr.bmp"></td>
 <td>&nbsp;</td>
 <td><img align=middle src="APLimg/sx8b.bmp"></td>
 <td align=right valign=top><a href="APL1.htm#1.12"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td>Vertical</td><td>&nbsp;</td><td>
 <b><i>C</i></b> &larr; <img src="APLimg/buarr.bmp"></td>
 <td>&nbsp;</td>
 <td><img align=middle src="APLimg/sx8c.bmp"></td>
 <td align=right valign=top><a href="APL1.htm#1.12"><img src="APLimg/link.bmp"></a></td></tr>
<tr><td valign=top>Vector</td><td>&nbsp;</td><td>
 <b><i>y</i></b> &larr; <img src="APLimg/xrarr.bmp"><br>
 <b><i>y</i></b> &larr; <img src="APLimg/xuarr.bmp"></td>
 <td>&nbsp;</td>
 <td valign=top><b><i>y</i></b> &larr; <b><i>x</i></b><sub><i>&nu;</i> + 1 &ndash; <i>i</i></sub></td>
 <td>&nbsp;</td>
 <td align=right valign=top><a href="APL1.htm#reversal"><img src="APLimg/link.bmp"></a></td>
 </tr>
</table>
<br>



<a name="s.9"></a>
<p><b>S.9 Set Operations</b></p>

<table>
<tr><td nowrap>Intersection <sup>&nbsp;</sup><sub>&nbsp;</sub></td><td>&nbsp;</td>
 <td valign=top><b><i>c</i></b> &larr; <b><i>b</i></b> <tt>∩</tt> <b><i>a</i></b> <sup>&nbsp;</sup><sub>&nbsp;</sub></td>
 <td>&nbsp;</td>
 <td valign=top><b><i>c</i></b> = <tt><b>∊</b></tt><sub><b><i>b</i></b></sub><sup><b><i>a</i></b></sup>/<b><i>b</i></b></td>
 <td>&nbsp;</td>
 <td valign=top align=right><sup>&nbsp;</sup><sub>&nbsp;</sub><a href="APL1.htm#intersection"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td>Difference <sup>&nbsp;</sup><sub>&nbsp;</sub></td><td>&nbsp;</td>
 <td><b><i>c</i></b> &larr; <b><i>b</i></b> <tt>∆</tt> <b><i>a</i></b> <sup>&nbsp;</sup><sub>&nbsp;</sub></td><td>&nbsp;</td>
 <td><b><i>c</i></b> = <img src="APLimg/epsboscore.bmp"><sub><b><i>b</i></b></sub><sup><b><i>a</i></b></sup>/<b><i>b</i></b></td>
 <td>&nbsp;</td>
 <td valign=top align=right><sup>&nbsp;</sup><sub>&nbsp;</sub><a href="APL1.htm#difference"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td>Union <sup>&nbsp;</sup><sub>&nbsp;</sub></td><td>&nbsp;</td>
 <td><b><i>c</i></b> &larr; <b><i>b</i></b> <tt>∪</tt> <b><i>a</i></b> <sup>&nbsp;</sup><sub>&nbsp;</sub></td><td>&nbsp;</td>
 <td><b><i>c</i></b> = <b><i>b</i></b> <img src="APLimg/circleplus.bmp"> (<b><i>a</i></b> <tt>∆</tt> <b><i>b</i></b>)</td>
 <td>&nbsp;</td>
 <td valign=top align=right><sup>&nbsp;</sup><sub>&nbsp;</sub><a href="APL1.htm#union"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top>Cartesian<br>product</td><td>&nbsp;</td>
 <td valign=top nowrap><b><i>C</i></b> &larr; <b><i>b</i></b><sup>1</sup> <img src="APLimg/circletimes.bmp">
 &#133; <img src="APLimg/circletimes.bmp"> <b><i>b</i></b><sup><i>n</i></sup> <sub>&nbsp;</sub></td><td>&nbsp;</td>
 <td><b><i>C</i></b><sup>&nbsp;1 + <b><i>d</i></b> <tt>⊥</tt> (<b><i>k</i></b> &ndash; <tt><b>∊</b></tt>)</sup>
 = (<b><i>b</i></b><sub><b><i>k</i></b><sub>1</sub></sub><sup>1</sup>,
 <b><i>b</i></b><sub><b><i>k</i></b><sub>2</sub></sub><sup>2</sup>, &#133;,
 <b><i>b</i></b><sub><b><i>k</i></b><sub><i>n</i></sub></sub><sup><i>n</i></sup>); &nbsp;
 <b><i>d</i></b><sub><i>&nbsp;j</i></sub> = <i>&nu;</i>(<b><i>b</i></b><sup><i>&nbsp;j</i></sup>);
 1 &le; <b><i>k</i></b><sub><i>&nbsp;j</i></sub> &le; <b><i>d</i></b><sub><i>&nbsp;j</i></sub> <br>
 Clearly, <i>&nu;</i>(<b><i>C</i></b>) = <i>n</i>, and
 <i>&mu;</i>(<b><i>C</i></b>) = &times;/<b><i>d</i></b></tt></td>
 <td>&nbsp;</td>
 <td valign=top align=right><sup>&nbsp;</sup><sub>&nbsp;</sub><a href="APL1.htm#cartesian"><img src="APLimg/link.bmp"></a></td>
 </tr>
</table>
<br>



<a name="s.10"></a>
<p><b>S.10 Generalized Matrix Product</b></p>

<table>
<tr><td valign=top nowrap><b><i>C</i></b> &larr; <b><i>A</i></b> <img src="APLimg/circle1circle2.bmp"> 
 <b><i>B</i></b> <sup>&nbsp;</sup><sub>&nbsp;</sub></td>
 <td>&nbsp;</td>
 <td><b><i>C</i></b><sub><i>&nbsp;j</i></sub><sup><i>&nbsp;i</i></sup> = 
 <img src="APLimg/circledot.bmp"><sub>1</sub>/(<b><i>A</i></b><sup><i>&nbsp;i</i></sup>
 <img src="APLimg/circledot.bmp"><sub>2</sub> <b><i>B</i></b><sub><i>&nbsp;j</i></sub>),
 where <img src="APLimg/circledot.bmp"><sub>2</sub> produces a vector
 (i.e., is not the operator <tt>⊥</tt>), and 
 <img src="APLimg/circledot.bmp"><sub>1</sub> 
 is a reduction operator (and hence 
 <b><i>C</i></b><sub><i>&nbsp;j</i></sub><sup><i>&nbsp;i</i></sup> 
 is a scalar).</td>
 <td>&nbsp;</td>
 <td valign=top align=right><sup>&nbsp;</sup><sub>&nbsp;</sub><a href="APL1.htm#1.11"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top nowrap><b><i>C</i></b> &larr; <b><i>A</i></b> <img src="APLimg/jotcircle.bmp"> 
 <b><i>b</i></b> <sup>&nbsp;</sup><sub>&nbsp;</sub></td>
 <td>&nbsp;</td>
 <td><b><i>C</i></b><sup><i>&nbsp;i</i></sup> = 
 (<b><i>A</i></b><sup><i>&nbsp;i</i></sup>
 <img src="APLimg/circledot.bmp"> <b><i>b</i></b>),
 where <img src="APLimg/circledot.bmp"> is any operator
 which produces a vector of dimension <i>&nu;</i>(<b><i>b</i></b>).
 </td> 
 <td>&nbsp;</td>
 <td valign=top align=right><sup>&nbsp;</sup><a href="APL1.htm#gmp_mv"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top nowrap><b><i>C</i></b> &larr; <b><i>a</i></b> <img src="APLimg/jotcircle.bmp"> 
 <b><i>B</i></b> <sup>&nbsp;</sup><sub>&nbsp;</sub></td>
 <td>&nbsp;</td>
 <td><b><i>C</i></b><sub><i>&nbsp;j</i></sub> = 
 (<b><i>a</i></b>
 <img src="APLimg/circledot.bmp"> <b><i>B</i></b><sub><i>&nbsp;j</i></sub>),<sup>&nbsp;</sup>
 where <img src="APLimg/circledot.bmp"> is any operator
 which produces a vector of dimension <i>&nu;</i>(<b><i>a</i></b>).</td> 
 <td>&nbsp;</td>
 <td valign=top align=right><sup>&nbsp;</sup><a href="APL1.htm#gmp_vm"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top nowrap><b><i>C</i></b> &larr; <b><i>a</i></b> <img src="APLimg/jotcircle.bmp"> 
 <b><i>b</i></b> <sup>&nbsp;</sup><sub>&nbsp;</sub></td>
 <td>&nbsp;</td>
 <td><b><i>C</i></b><sub><i>&nbsp;j</i></sub><sup><i>&nbsp;i</i></sup> = 
 (<b><i>a</i></b><sub><i>&nbsp;i</i></sub>
 <img src="APLimg/circledot.bmp"> <b><i>b</i></b><sub><i>&nbsp;j</i></sub>).</td> 
 <td>&nbsp;</td>
 <td valign=top align=right><sup>&nbsp;</sup><sub>&nbsp;</sub><a href="APL1.htm#gmp_vv"><img src="APLimg/link.bmp"></a></td>
 </tr>
</table>
<br>



<a name="s.11"></a>
<p><b>S.11 Files</b></p>

<table>
<tr><td valign=top>File<sup>&nbsp;</sup><sub>&nbsp;</sub></td>
 <td>&nbsp;</td>
 <td valign=top><b>&Phi;</b><sub><i>&nbsp;j</i></sub><sup><i>&nbsp;i</i></sup></td>
 <td>&nbsp;</td>
 <td>A representation of <b><i>a</i></b> of the form<br>
  (<b><i>p</i></b><sub>1</sub>, <b><i>a</i></b><sub>1</sub>,
  <b><i>p</i></b><sub>2</sub>, <b><i>a</i></b><sub>2</sub>, &#133;,
  <b><i>a</i></b><sub><i>&nu;</i>(<b><i>a</i></b>)</sub>, 
  <b><i>p</i></b><sub><i>&nu;</i>(<b><i>a</i></b>)+1</sub>, <tt>∘</tt>,
  <b><i>p</i></b><sub><i>&nu;</i>(<b><i>a</i></b>)+2</sub>, &#133;,
  <b><i>p</i></b><sub><i>&nu;</i>(<b><i>p</i></b>)</sub>),
  where <b><i>p</i></b><sub><i>h</i></sub> is the partition
  at position <i>h</i>, <nobr><b><i>p</i></b><sub>1</sub> = 
  <b><i>p</i></b><sub><i>&nu;</i>(<b><i>p</i></b>)</sub> = <i>&lambda;</i>,</nobr>
  and <nobr>(<tt><b>⍺</b></tt><sup>1</sup> &and;
  <tt><b>⍵</b></tt><sup>1</sup>)/<b><i>p</i></b> <tt>&sube;</tt> <b>&lambda;</b>.</nobr></td>
 <td valign=top align=right><a href="APL1.htm#file_defn"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td nowrap valign=top>Position file<sup>&nbsp;</sup><sub>&nbsp;</sub></td>
 <td>&nbsp;</td>
 <td valign=top><i>&pi;</i>(<b>&Phi;</b><sub><i>&nbsp;j</i></sub><sup><i>&nbsp;i</i></sup>) 
  &larr; <i>h</i></td>
 <td>&nbsp;</td>
 <td>Set file to position <i>h</i>. Called <i>rewind</i> if <i>h</i> = 1,
  and <i>wind</i> if <i>h</i> = <i>&nu;</i>(<b><i>p</i></b>).</td>
 <td valign=top align=right><a href="APL1.htm#file_position"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td colspan=6>Record (from position <i>h</i>)</td></tr>
<tr><td valign=top>&nbsp; &nbsp;Forward<sup>&nbsp;</sup><sub>&nbsp;</sub></td>
 <td>&nbsp;</td>
 <td valign=top nowrap><sub>0</sub><b>&Phi;</b><sub><i>&nbsp;j</i></sub><sup><i>&nbsp;i</i></sup> &larr;
  <b><i>a</i></b>, <b>&lambda;</b><sub><i>k</i></sub></td>
 <td>&nbsp;</td>
 <td><b><i>a</i></b><sub><i>h</i></sub> &larr; <b><i>a</i></b>,
  <b><i>p</i></b><sub><i>h</i>+1</sub> &larr; <b>&lambda;</b><sub><i>k</i></sub>;
  stop at position <nobr><i>h</i> + 1.</nobr>
  Zero prescript may be elided and <b>&lambda;</b><sub>1</sub> may be elided.</td>
 <td valign=top align=right><a href="APL1.htm#forward_record"><img src="APLimg/link.bmp"></a></td>
 </tr>
  </tr>
<tr><td valign=top nowrap>&nbsp; &nbsp;Backward<sup>&nbsp;</sup><sub>&nbsp;</sub></td>
 <td>&nbsp;</td>
 <td valign=top nowrap><sub>1</sub><b>&Phi;</b><sub><i>&nbsp;j</i></sub><sup><i>&nbsp;i</i></sup> &larr;
  <b><i>a</i></b>, <b>&lambda;</b><sub><i>k</i></sub></td>
 <td>&nbsp;</td>
 <td><b><i>a</i></b><sub><i>h</i>&ndash;1</sub> &larr; <b><i>a</i></b>,
  <b><i>p</i></b><sub><i>h</i>&ndash;1</sub> &larr; <b>&lambda;</b><sub><i>k</i></sub>;
  stop at position <nobr><i>h</i> &ndash; 1.</nobr>
  <b>&lambda;</b><sub>1</sub> may be elided.</td>
 <td valign=top align=right><a href="APL1.htm#backward_record"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td colspan=6>Read (from position <i>h</i>)</td></tr>
<tr><td valign=top>&nbsp; &nbsp;Forward<sup>&nbsp;</sup><sub>&nbsp;</sub></td>
 <td>&nbsp;</td>
 <td valign=top nowrap><i>a</i>, <i>b</i> &larr; <sub>0</sub><b>&Phi;</b><sub><i>&nbsp;j</i></sub><sup><i>&nbsp;i</i></sup></td>
 <td>&nbsp;</td>
 <td><i>a</i> &larr; <b><i>a</i></b><sub><i>h</i></sub>;
  <i>b</i> &larr; <b><i>p</i></b><sub><i>h</i>+1</sub>;
  stop at position <nobr><i>h</i> + 1</nobr>.
  Associated branch is controlled by <b><i>p</i></b><sub><i>h</i>+1</sub>,
  and <i>b</i> may be elided. Zero prescript may be elided.</td>
 <td valign=top align=right><a href="APL1.htm#forward_read"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top>&nbsp; &nbsp;Backward<sup>&nbsp;</sup><sub>&nbsp;</sub></td>
 <td>&nbsp;</td>
 <td valign=top nowrap><i>a</i>, <i>b</i> &larr; <sub>1</sub><b>&Phi;</b><sub><i>&nbsp;j</i></sub><sup><i>&nbsp;i</i></sup></td>
 <td>&nbsp;</td>
 <td><i>a</i> &larr; <b><i>a</i></b><sub><i>h</i>&ndash;1</sub>;
  <i>b</i> &larr; <b><i>p</i></b><sub><i>h</i>&ndash;1</sub>;
  stop at position <nobr><i>h</i> &ndash; 1</nobr>.
  Associated branch is controlled by <b><i>p</i></b><sub><i>h</i>&ndash;1</sub>
  and <i>b</i> may be elided.</td>
 <td valign=top align=right><a href="APL1.htm#backward_read"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td colspan=6>File array</td></tr>
<tr><td valign=top>&nbsp; &nbsp;Full<sup>&nbsp;</sup><sub>&nbsp;</sub></td>
 <td>&nbsp;</td>
 <td valign=top><b>&Phi;</b><sup>&nbsp;</sup><sub>&nbsp;</sub></td>
 <td>&nbsp;</td>
 <td>Array of files <b>&Phi;</b><sub><i>&nbsp;j</i></sub><sup><i>&nbsp;i</i></sup>,
  for <nobr><i>i</i> <tt>∊</tt> <tt><b>⍳</b></tt><sup>1</sup>(<i>&mu;</i>(<b>&Phi;</b>)),</nobr>
  <nobr><i>j</i> <tt>∊</tt> <tt><b>⍳</b></tt><sup>1</sup>(<i>&nu;</i>(<b>&Phi;</b>)).</nobr></td>
 <td valign=top align=right><a href="APL1.htm#file_array"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top>&nbsp; &nbsp;Row<sup>&nbsp;</sup><sub>&nbsp;</sub></td>
 <td>&nbsp;</td>
 <td valign=top><b>&Phi;</b><sup><i>&nbsp;i</i></sup><sub>&nbsp;</sub></td>
 <td>&nbsp;</td>
 <td>Row of files <b>&Phi;</b><sub><i>&nbsp;j</i></sub><sup><i>&nbsp;i</i></sup>,
  for <nobr><i>j</i> <tt>∊</tt> <tt><b>⍳</b></tt><sup>1</sup>(<i>&nu;</i>(<b>&Phi;</b>)).</nobr></td>
 <td valign=top align=right><a href="APL1.htm#file_array"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top>&nbsp; &nbsp;Column<sup>&nbsp;</sup><sub>&nbsp;</sub></td>
 <td>&nbsp;</td>
 <td valign=top><b>&Phi;</b><sub><i>&nbsp;j</i></sub> <sup>&nbsp;</sup></td>
 <td>&nbsp;</td>
 <td>Column of files <b>&Phi;</b><sub><i>&nbsp;j</i></sub><sup><i>&nbsp;i</i></sup>,
  for <nobr><i>i</i> <tt>∊</tt> <tt><b>⍳</b></tt><sup>1</sup>(<i>&mu;</i>(<b>&Phi;</b>)).</nobr></td>
 <td valign=top align=right><a href="APL1.htm#file_array"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td colspan=6>Compression</td></tr>
<tr><td valign=top>&nbsp; &nbsp;Row</td>
 <td>&nbsp;</td>
 <td><b><i>u</i></b>/<b>&Phi;</b></td>
 <td>&nbsp;</td>
 <td rowspan=2 valign=top>Selection as in corresponding operations on matrices.</td>
 <td valign=top align=right><a href="APL1.htm#file_array"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top>&nbsp; &nbsp;Column</td>
 <td>&nbsp;</td>
 <td><b><i>u</i></b>//<b>&Phi;</b></td>
 </tr>
</table>
<br>


<a name="s.12"></a>
<p><b>S.12 Trees</b></p>

<table>
<tr><td valign=top nowrap>Path <b><i>i</i><sub>&nbsp;</sub><sup>&nbsp;</sup></b></td>
 <td>&nbsp;</td>
 <td valign=top nowrap><b><i>c</i></b> &larr; <b>A</b><sup><b><i>i</i></b></sup></td>
 <td>&nbsp;</td>
 <td valign=top><b><i>c</i></b><sub>1</sub> is the <b><i>i</i></b><sub>1</sub>th
  root of <b>A</b>; <b><i>c</i></b><sub><i>&nbsp;j</i></sub> is the
  <b><i>i</i></b><sub><i>&nbsp;j&nbsp;</i></sub>th node of the nodes on level <i>j</i>
  reachable from node <b><i>c</i></b><sub><i>&nbsp;j</i>&ndash;1</sub>.</td>
 <td valign=top align=right><sup>&nbsp;</sup><sub>&nbsp;</sub><a href="APL1.htm#path"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top nowrap>Node <b><i>i</i><sub>&nbsp;</sub><sup>&nbsp;</sup></b></td>
 <td>&nbsp;</td>
 <td valign=top nowrap><b><i>c</i></b> &larr; 
  (<b>A</b><sup><b><i>i</i></b></sup>)<sub><i>&nu;</i>(<b><i>i</i></b>)</sub></td>
 <td>&nbsp;</td>
 <td valign=top>The final node of path <b>A</b><sup><b><i>i</i></b></sup>.</td>
 <td valign=top align=right><sup>&nbsp;</sup><sub>&nbsp;</sub><a href="APL1.htm#node"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top nowrap>Subtree <b><i>i</i></b><sub>&nbsp;</sub></b></td>
 <td>&nbsp;</td>
 <td valign=top nowrap><b>C</b> &larr; <b>A</b><sub><b><i>&nbsp;i</i></b></sub></td>
 <td>&nbsp;</td>
 <td valign=top><b>C</b> is the subtree of <b>A</b> rooted in node <b><i>i</i></b>.</td>
 <td align=right><sub>&nbsp;</sub><a href="APL1.htm#subtree"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top>Component-by-<br>component</b></td>
 <td>&nbsp;</td>
 <td valign=top nowrap><b>C</b> &larr; <b>A</b> <img src="APLimg/circledot.bmp"> <b>B</b><sup>&nbsp;</sup></td>
 <td>&nbsp;</td>
 <td valign=top>(<b>C</b><sup>&nbsp;<b><i>i</i></b></sup>)<sub><i>&nu;</i>(<b><i>i</i></b>)</sub> 
  =
  (<b>A</b><sup>&nbsp;<b><i>i</i></b></sup>)<sub><i>&nu;</i>(<b><i>i</i></b>)</sub>
  <img src="APLimg/circledot.bmp">
  (<b>B</b><sup>&nbsp;<b><i>i</i></b></sup>)<sub><i>&nu;</i>(<b><i>i</i></b>)</sub>.</td>
 <td valign=top align=right><sup>&nbsp;</sup><sub>&nbsp;</sub><a href="APL1.htm#1.23.7"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top>Path reduction</b></td>
 <td>&nbsp;</td>
 <td valign=top nowrap><b>C</b> &larr; <img src="APLimg/circledot.bmp">/<b>A</b></td>
 <td>&nbsp;</td>
 <td valign=top>Reduction by operator or relation <img src="APLimg/circledot.bmp"> 
  on nodes in left list order.</td>
 <td valign=top align=right><sup>&nbsp;</sup><sub>&nbsp;</sub><a href="APL1.htm#tree_reduction"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top>Level reduction</b></td>
 <td>&nbsp;</td>
 <td valign=top nowrap><b>C</b> &larr; <img src="APLimg/circledot.bmp">//<b>A</b></td>
 <td>&nbsp;</td>
 <td valign=top>Reduction by operator or relation <img src="APLimg/circledot.bmp"> 
  on nodes in right list order.</td>
 <td valign=top align=right><sup>&nbsp;</sup><sub>&nbsp;</sub><a href="APL1.htm#tree_reduction"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top nowrap><i>j</i>-origin <b><i>b</i></b>-index</b><sub>&nbsp;</sub></td>
 <td>&nbsp;</td>
 <td valign=top nowrap><b>B</b> &larr; <b><i>b</i></b> <tt><b>⍳</b></tt><sub><i>j</i></sub> <b>A</b></td>
 <td>&nbsp;</td>
 <td valign=top>(<b>B</b><sup>&nbsp;<b><i>i</i></b></sup>)<sub><i>&nu;</i>(<b><i>i</i></b>)</sub> = 
  <b><i>b</i></b> <tt><b>⍳</b></tt><sub><i>j</i></sub> ((<b>A</b><sup><b><i>i</i></b></sup>)<sub><i>&nu;</i>(<b><i>i</i></b>)</sub>)</td>
 <td valign=top align=right><sup>&nbsp;</sup><sub>&nbsp;</sub><a href="APL1.htm#tree_iota"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top nowrap><i>j</i>-origin mapping<sub>&nbsp;</sub></td>
 <td>&nbsp;</td>
 <td valign=top nowrap><b>C</b> &larr; <b><i>b</i></b> &int;<sub><i>j</i></sub> <b>A</b></td>
 <td>&nbsp;</td>
 <td valign=top>Rooted subtree <b>C</b><sub><i>i</i></sub> is a single null character node
  if <b><i>b</i></b><sub><i>i</i></sub> <tt>&notin;</tt> 
  <tt><b>⍺</b></tt><sup><i>j</i></sup>(<b>&mu;</b><sub>1</sub>(<b>A</b>));
  otherwise <b>C</b><sub>i</sub> = <b>A</b><sub><b><i>b</i></b><sub><i>i</i></sub></sub>,
  where <b>A</b> is treated in a <i>j</i>-origin system.</td>
 <td valign=top align=right><sup>&nbsp;</sup><sub>&nbsp;</sub><a href="APL1.htm#tree_map"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top>Full right list<br>matrix</td>
 <td>&nbsp;</td>
 <td valign=top nowrap><b><i>C</i></b> &larr; ]<b>A</b></td>
 <td rowspan=2><img align=left src="APLimg/matrixr4.bmp"></td>
 <td valign=top rowspan=2>The rows of the index matrix 
  <img src="APLimg/alphaboscore.bmp"><sup>2</sup>/<b><i>C</i></b>
  are the right (left) justified index vectors
  (with null fill to the common dimension <i>&nu;</i>(<b>A</b>))
  arranged in increasing order; 
  <b><i>C</i></b><sub>1</sub> and <b><i>C</i></b><sub>2</sub>
  are the corresponding degree and node vectors of <b>A</b>.</td>
 <td valign=top align=right rowspan=2><sup>&nbsp;</sup><sub>&nbsp;</sub><a href="APL1.htm#1.23.3"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top>Full left list<br>matrix</td>
 <td>&nbsp;</td>
 <td valign=top nowrap><b><i>C</i></b> &larr; [<b>A</b></td>
 </tr>
<tr><td valign=top>Right list matrix</td>
 <td>&nbsp;</td>
 <td valign=top nowrap><b><i>C</i></b> &larr; <tt><b>⍺</b></tt><sup>2</sup>/]<b>A</b></td>
 <td rowspan=2><img align=left src="APLimg/matrixr2.bmp"></td>
 <td valign=top rowspan=2>The degree and node vector columns 
  of the full right (left) list.</td>
 <td valign=top align=right rowspan=2><a href="APL1.htm#1.23.3"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top>Left list matrix</td>
 <td>&nbsp;</td>
 <td valign=top nowrap><b><i>C</i></b> &larr; <tt><b>⍺</b></tt><sup>2</sup>/[<b>A</b></td>
 </tr>
<tr><td valign=top>Tree compression</td>
 <td>&nbsp;</td>
 <td valign=top><b>C</b> &larr; <b>U</b>/<b>A</b></td>
 <td>&nbsp;</td>
 <td><b>C</b> is obtained from <b>A</b> by suppressing node <b><i>i</i></b>
  if node <b><i>i</i></b> of <b>U</b> is zero and reconnecting so that
  for each remaining pair of nodes,
  the one lies in the subtree rooted at the second
  if and only if it did so in <b>A</b>.</td>
 <td valign=top align=right><a href="APL1.htm#1.23.6"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top>Path compression</td>
 <td>&nbsp;</td>
 <td valign=top><b>C</b> &larr; <b><i>u</i></b>/<b>A</b></td>
 <td>&nbsp;</td>
 <td><b>C</b> is obtained from <b>A</b> by suppressing all nodes
  on level <i>j</i> if <nobr><b><i>u</i></b><sub><i>j</i></sub> = 0,</nobr>
  and reconnecting as in the compression <b>U</b>/<b>A</b>.</td>
 <td valign=top align=right><a href="APL1.htm#path_compression"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top>Level compression</td>
 <td>&nbsp;</td>
 <td valign=top><b>C</b> &larr; <b><i>u</i></b>//<b>A</b></td>
 <td>&nbsp;</td>
 <td><b>C</b> is obtained from <b>A</b> by suppressing rooted subtree <b>A</b><sub><i>j</i></sub>
  if <b><i>u</i></b><sub><i>j</i></sub> = 0.</td>
 <td valign=top align=right><sup>&nbsp;</sup><a href="APL1.htm#level_compression"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top>Level mesh</td>
 <td>&nbsp;</td>
 <td valign=top nowrap><b>C</b> &larr; \\<b>A</b>, <b><i>u</i></b>, <b>B</b>\\</td>
 <td>&nbsp;</td>
 <td><img src="APLimg/uboscore.bmp">//<b>C</b> = <b>A</b>; <b><i>u</i></b>//<b>C</b> = <b>B</b>.</td>
 </tr>
<tr><td valign=top>Level mask</td>
 <td>&nbsp;</td>
 <td valign=top nowrap><b>C</b> &larr; //<b>A</b>, <b><i>u</i></b>, <b>B</b>//</td>
 <td>&nbsp;</td>
 <td><img src="APLimg/uboscore.bmp">//<b>C</b> = <img src="APLimg/uboscore.bmp">//<b>A</b>; 
  <b><i>u</i></b>//<b>C</b> = <b><i>u</i></b>//<b>B</b>.</td>
 </tr>
<tr><td valign=top>Path catenation</td>
 <td>&nbsp;</td>
 <td valign=top nowrap><b>C</b> &larr; <b>A</b> <img src="APLimg/circleplus.bmp"> <b>B</b></td>
 <td>&nbsp;</td>
 <td><b>C</b> is obtained by connecting roots of <b>B</b> to leaves of <b>A</b>,
  allotting successive groups of at most 
  <tt>⌈</tt><b>&mu;</b><sub>1</sub>(<b>B</b>) <tt>÷</tt> 
  <i>&lambda;</i>(<b>A</b>)<tt>&rceil;</tt>
  roots of <b>B</b> to each successive leaf of <b>A</b>.</td>
 <td valign=top align=right><a href="APL1.htm#1.23"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top>Full tree</td>
 <td>&nbsp;</td>
 <td valign=top nowrap><b>W</b> &larr; <font face="Arial"><b>E</b></font></td>
 <td>&nbsp;</td>
 <td>Each node of <b>W</b> is unity and the structure of <b>W</b>
  is determined by compatibility.</td>
 <td valign=top align=right><a href="APL1.htm#full_tree"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top>&nbsp;</td>
 <td>&nbsp;</td>
 <td valign=top nowrap><b>W</b> &larr; <font face="Arial"><b>E</b></font>(<b><i>k</i></b>)</td>
 <td>&nbsp;</td>
 <td>Each node of <b>W</b> is unity; <b>W</b> is homogeneous
  (i.e., all nodes on any level have a common degree)
  and <b>&nu;</b>(<b>W</b>) = <b><i>k</i></b>.</td>
 <td valign=top align=right><a href="APL1.htm#full_tree_k"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top>Zero tree</td>
 <td>&nbsp;</td>
 <td valign=top nowrap><b>W</b> &larr; <img src="APLimg/0tree.bmp"><br>
  <b>W</b> &larr; 0</td>
 <td><img src="APLimg/bracketsx12.bmp"></td>
 <td>Each node of <b>W</b> is zero and the structure of <b>W</b>
  is determined by compatibility.</td>
 <td valign=top align=right><a href="APL1.htm#full_tree"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top>&nbsp;</td>
 <td>&nbsp;</td>
 <td valign=top nowrap><b>W</b> &larr; <img src="APLimg/0tree.bmp">(<b><i>k</i></b>)</font></td>
 <td>&nbsp;</td>
 <td>Each node of <b>W</b> is zero; <b>W</b> is homogeneous
  and <b>&nu;</b>(<b>W</b>) = <b><i>k</i></b>.</td>
 <td valign=top align=right><a href="APL1.htm#full_tree_k"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top>Path tree<sup>&nbsp;</sup></td>
 <td>&nbsp;</td>
 <td valign=top nowrap><b>W</b> &larr; <sup><b><i>u</i></b></sup><font face="Arial"><b>E</b></font></td>
 <td>&nbsp;</td>
 <td><img src="APLimg/uboscore.bmp">/<b>W</b> = 0; 
  <b><i>u</i></b>/<b>W</b> = <font face="Arial"><b>E</b></font>;
  structure of <b>W</b> determined by compatibility.</td>
 <td valign=top align=right><a href="APL1.htm#full_tree"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top>&nbsp;</td>
 <td>&nbsp;</td>
 <td valign=top nowrap><b>W</b> &larr; <sup><b><i>u</i></b></sup><font face="Arial"><b>E</b></font>(<b><i>k</i></b>)</td>
 <td>&nbsp;</td>
 <td><img src="APLimg/uboscore.bmp">/<b>W</b> = 0; 
  <b><i>u</i></b>/<b>W</b> = <font face="Arial"><b>E</b></font>;
  <b>W</b> is homogeneous and <b>&nu;</b>(<b>W</b>) = <b><i>k</i></b>.</td>
 <td valign=top align=right><a href="APL1.htm#full_tree_k"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top>Level tree<sub>&nbsp;</sub></td>
 <td>&nbsp;</td>
 <td valign=top nowrap><b>W</b> &larr; <sub><b><i>u</i></b></sub><font face="Arial"><b>E</b></font></td>
 <td>&nbsp;</td>
 <td><img src="APLimg/uboscore.bmp">//<b>W</b> = 0; 
  <b><i>u</i></b>//<b>W</b> = <font face="Arial"><b>E</b></font>;
  structure of <b>W</b> determined by compatibility.</td>
 <td valign=top align=right><a href="APL1.htm#full_tree"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top>&nbsp;</td>
 <td>&nbsp;</td>
 <td valign=top nowrap><b>W</b> &larr; <sub><b><i>u</i></b></sub><font face="Arial"><b>E</b></font>(<b><i>k</i></b>)</td>
 <td>&nbsp;</td>
 <td><img src="APLimg/uboscore.bmp">//<b>W</b> = 0; 
  <b><i>u</i></b>//<b>W</b> = <font face="Arial"><b>E</b></font>;
  <b>W</b> is homogeneous and <b>&nu;</b>(<b>W</b>) = <b><i>k</i></b>.</td>
 <td valign=top align=right><a href="APL1.htm#full_tree_k"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top>Maximization</td>
 <td>&nbsp;</td>
 <td valign=top nowrap><b>W</b> &larr; <b>U</b> <tt>⌈</tt> <b>A</b></td>
 <td rowspan=2><img src="APLimg/matrixr2.bmp"></td>
 <td rowspan=2><b>W</b> = <b>U</b> &and; (<b>A</b> = <i>m</i><font face="Arial"><b>E</b></font>),
  where <i>m</i> is the maximum (minimum) over all nodes of <b>U</b>/<b>A</b>.</td>
 <td valign=top align=right><a href="APL1.htm#tree_max"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top>Minimization</td>
 <td>&nbsp;</td>
 <td valign=top nowrap><b>W</b> &larr; <b>U</b> <tt>⌊</tt> <b>A</b></td>
 </tr>
<tr><td valign=top>Maximum path prefix</td>
 <td>&nbsp;</td>
 <td valign=top nowrap><b>W</b> &larr; <tt>⍺</tt>/<b>U</b></font></td>
 <td>&nbsp;</td>
 <td><b>W</b> is obtained from <b>U</b> by zeroing all nodes 
  of every subtree rooted in a zero node.</td>
 <td valign=top align=right><a href="APL1.htm#fig1.24"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top>Maximum path suffix</td>
 <td>&nbsp;</td>
 <td valign=top nowrap><b>W</b> &larr; <tt>⍵</tt>/<b>U</b></font></td>
 <td>&nbsp;</td>
 <td><b>W</b> is obtained from <b>U</b> by zeroing every node 
  which contains a zero node in its subtree.</td>
 <td valign=top align=right><a href="APL1.htm#fig1.24"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top>Forward path set selector</td>
 <td>&nbsp;</td>
 <td valign=top nowrap><b>W</b> &larr; <i>&sigma;</i>/<b>A</b></font></td>
 <td>&nbsp;</td>
 <td>(<b>W</b><sup>&nbsp;<b><i>i</i></b></sup>)<sub><i>&nu;</i>(<b><i>i</i></b>)</sub> = 1 if
  (<b>A</b><sup><b><i>i</i></b></sup>)<sub><i>&nu;</i>(<b><i>i</i></b>)</sub> 
  differs from all preceding nodes of path <b>A</b><sup><b><i>i</i></b></sup>.</td>
 <td valign=top align=right><sup>&nbsp;</sup><a href="APL1.htm#fig1.24"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top>Backward path set selector</td>
 <td>&nbsp;</td>
 <td valign=top nowrap><b>W</b> &larr; <i>&tau;</i>/<b>A</b></font></td>
 <td>&nbsp;</td>
 <td>(<b>W</b><sup>&nbsp;<b><i>i</i></b></sup>)<sub><i>&nu;</i>(<b><i>i</i></b>)</sub> = 1 if
  (<b>A</b><sup><b><i>i</i></b></sup>)<sub><i>&nu;</i>(<b><i>i</i></b>)</sub> 
  differs from all other nodes in its subtree.</td>
 <td valign=top align=right><sup>&nbsp;</sup><a href="APL1.htm#fig1.24"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top>Maximum level<sup>&nbsp;</sup> prefix</td>
 <td>&nbsp;</td>
 <td valign=top nowrap><b>W</b> &larr; <tt>⍺</tt>//<b>U</b></font> <sup>&nbsp;</sup></td>
 <td>&nbsp;</td>
 <td valign=top><tt><b>∊</b></tt><sup><i>&nbsp;j</i></sup>/<b>W</b> = 
  <tt>⍺</tt>/<tt><b>∊</b></tt><sup><i>&nbsp;j</i></sup>/<b>U</b></td>
 <td valign=top align=right><sup>&nbsp;</sup><a href="APL1.htm#fig1.24"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top>Maximum level<sup>&nbsp;</sup> suffix</td>
 <td>&nbsp;</td>
 <td valign=top nowrap><b>W</b> &larr; <tt>⍵</tt>//<b>U</b></font> <sup>&nbsp;</sup></td>
 <td>&nbsp;</td>
 <td valign=top><tt><b>∊</b></tt><sup><i>&nbsp;j</i></sup>/<b>W</b> = 
  <tt>⍵</tt>/<tt><b>∊</b></tt><sup><i>&nbsp;j</i></sup>/<b>U</b></td>
 <td valign=top align=right><sup>&nbsp;</sup><a href="APL1.htm#fig1.24"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top>Forward level<sup>&nbsp;</sup><br> set selector</td>
 <td>&nbsp;</td>
 <td valign=top nowrap><b>W</b> &larr; <i>&sigma;</i>//<b>A</b></font> <sup>&nbsp;</sup></td>
 <td>&nbsp;</td>
 <td valign=top><tt><b>∊</b></tt><sup><i>&nbsp;j</i></sup>/<b>W</b> = 
  <i>&sigma;</i>/<tt><b>∊</b></tt><sup><i>&nbsp;j</i></sup>/<b>U</b></td>
 <td valign=top align=right><sup>&nbsp;</sup><a href="APL1.htm#fig1.24"><img src="APLimg/link.bmp"></a></td>
 </tr>
<tr><td valign=top>Backward level<sup>&nbsp;</sup> set selector</td>
 <td>&nbsp;</td>
 <td valign=top nowrap><b>W</b> &larr; <i>&tau;</i>//<b>A</b></font> <sup>&nbsp;</sup></td>
 <td>&nbsp;</td>
 <td valign=top><tt><b>∊</b></tt><sup><i>&nbsp;j</i></sup>/<b>W</b> = 
  <i>&tau;</i>/<tt><b>∊</b></tt><sup><i>&nbsp;j</i></sup>/<b>U</b></td>
 <td valign=top align=right><sup>&nbsp;</sup><a href="APL1.htm#fig1.24"><img src="APLimg/link.bmp"></a></td>
 </tr>
</table>
<br>



<br><hr>

<p><font size=-1>Originally appeared as <i>A Programming Language</i>, 
Wiley, 1962, available as a pdf file from
<a target=_parent href="http://www.softwarepreservation.org/projects/apl/book/APROGRAMMING%20LANGUAGE/view">here</a>.
<script src="apldisplay.js" type="text/javascript"></script>
</font></p>

<table>
<tr><td><font size=-1>created: &nbsp; &nbsp;</font></td><td><font size=-1>2009-10-13 21:35</font></td></tr>
<tr><td><font size=-1>updated:</font></td><td><font size=-1>2017-11-07 15:00</font></td></tr>
</table>


</td></tr></table>
<br>
</body>
</html>