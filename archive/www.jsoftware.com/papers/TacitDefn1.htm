<html>
<head><meta http-equiv="content-type" content="text/html;charset=utf-8">
<title>Tacit Definition</title>
<link href="adoc.css" rel=stylesheet>
</head>

<body>

<br>

<table width=520 align=center><tr><td>

<p align=center><font size=+2>Tacit Definition</font><br><b>
Roger K.W. Hui<br>
Kenneth E. Iverson<br>
Eugene E. McDonnell
</b>
<br>&nbsp;</p>



<a name="intro"></a>
<p><b>Introduction</b></p>

<p>The predominant form of function definition in APL is
explicit in the sense that the arguments are referred to
explicitly in the sentences that represent the function being
defined. For example, if<tt> M </tt>is the character matrix:</p>

<pre>
Z←SUM Y
Z←+/Y
</i></pre>

<p>then<tt> Y </tt>refers explicitly to the argument 
of the function<tt> SUM </tt>
established by<tt> ⎕FX M</tt>&nbsp;.</p>

<p>In the dialect J (defined in 
<acronym title=
"1. Hui, Roger K.W., Kenneth E. Iverson, Eugene E. McDonnell, and Arthur T. Whitney, APL\?, ACM Quote Quad, Volume 20, Number 4, 1990-07.
2. Iverson, Kenneth E., The Dictionary of J, Vector (Journal of the British APL Association), Volume 7, Number 2, 1990-07.
3. Iverson, Kenneth E., Tangible Math and the ISI Dictionary of J, 1990-10.">
References 1 to 3</acronym>, 
and summarized in Appendix A), 
the list<tt> m=.'+/y.' </tt>
represents the same function 
in the sense that<tt> m&nbsp;:&nbsp;'' </tt>
provides a function that may be applied directly, 
as in<nobr><tt> m : '' 2 3 4</tt>&nbsp;,</nobr><tt> </tt>
or may be assigned a name, 
as in<nobr><tt> sum=. m : ''</tt>&nbsp;.</nobr><tt> </tt>
Again the argument is referred to
explicitly in the representation.</p>

<p>Because the operator<tt> / </tt>in the expression<tt> +/ </tt>produces a
derived function, the expression<tt> +/ </tt>is a tacit definition of
summation that involves no explicit reference to the
argument. Moreover, in some dialects (including J), a name
can be assigned to the resulting function, as in<tt> sum=.+/</tt>&nbsp;.</p>

<p>The present paper provides an inductive argument that a
wide class of explicit definitions can be expressed in tacit
form using the facilities of J, and discusses a translator to
tacit form that itself occurs as a primitive in J.</p>

<p>The paper concludes with two sections that illustrate the
use of tacit programming. Section C shows the relation to
traditional APL by providing annotated translations of the
first ten items in the FinnAPL Idiom Library 
<acronym title=
"FinnAPL Idiom Library, Finnish APL Association, 1982.">[4]</acronym>. 
Section D
provides definitions for a general inner product and for
orthogonal systems. It may be compared with the notation
used by McConnell 
<acronym title=
"McConnell, A.J., Applications of the Absolute Differential Calculus, Blackie and Son, 1931.">
[5]</acronym>, 
and with the APL treatment of them in Iverson 
<acronym title=
"Iverson, Kenneth E., The Derivative Operator, ACM Quote Quad, Volume 9, Number 4, 1979-06.">
[6]</acronym>.</p>

<p>In J (and in the present paper), we replace the APL terms
<i>function</i>, <i>operator with one argument</i>, 
and <i>operator with two arguments</i> 
by <i>verb</i>, <i>adverb</i>, and <i>conjunction</i>,
respectively.
<br>&nbsp;</p>



<a name="a"></a>
<p><b>A. Tacit Programming</b></p>

<p>In simple cases, a tacit definition is easy to write, and its
convenience is evident. For example, a function for
summation would be defined tacitly 
by<tt> sum=.+/ </tt>and
explicitly by either<tt> <nobr>sum=. '+/y.' : ''</nobr> </tt>
or<nobr><tt> ⎕fx 2 7⍴'Z←SUM YZ←+/Y  '</tt>&nbsp;.</nobr></p>

<p>To appreciate the more general use of tacit definition, it is
necessary to understand three key notions of J: cells and
rank, forks 
<acronym title=
"Iverson, Kenneth E., and Eugene E. McDonnell, Phrasal Forms, APL Quote Quad, Volume 19, Number 4, 1989-08.">[7]</acronym>, 
and composition.</p>


<a name="a.0"></a>
<p><b>Cell and Rank</b>. A <i>k</i>-cell of an array is the sub-array
defined by its last k axes. For example, if<tt> b </tt>is the 2 by 3 by
4 array:</p>

<pre>
abed
efgh
ijkl

mnop
qrst
uvwx
</pre>


<p>then<tt> abed </tt>is a 1-cell of<tt> b</tt>&nbsp;,<tt> </tt>
the table from<tt> m </tt>to<tt> x </tt>is a 2-cell
of<tt> b</tt>&nbsp;,<tt> </tt>
and<tt> g </tt>is a 0-cell or <i>atom</i> of<tt> b</tt>.<tt> </tt>
A cell of rank one less
than the rank of b is called a <i>major cell</i> or <i>item</i> 
of<tt> b</tt>&nbsp;.</p>

<p>Each primitive function has an assigned rank, and applies
to each cell of that rank. For example, ravel has unbounded
rank and applies to the entire array:</p>

<pre>
   ,b
abcdefghijklmnopqrstuvwx
</pre>

<p>Moreover, the rank conjunction denoted by<tt> " </tt>
produces a verb whose rank is determined 
by the right argument of<tt> "</tt>&nbsp;.<tt> </tt> 
For example:</p>

<pre>
   ,"2 b
abcdefghijkl
mnopqrstuvwx
</pre>

<p>Finally, the treatment of reduction and scan differs
somewhat from earlier dialects:<tt> f/a </tt>applies the dyadic
case of f between the <i>items</i> of a, and<tt> f\a </tt>
applies the <i>monadic</i> case of<tt> f </tt>
to prefixes of one or more items of<tt> a</tt>&nbsp;.<tt> </tt>
For example, if<tt> <nobr>a=.i. 2 3 4</tt>&nbsp;,</nobr><tt> </tt>then:</p>

<pre>
   +/1 2 3 4 5
15
   +/\1 2 3 4 5
1 3 6 10 15

   a
 0  1  2  3
 4  5  6  7
 8  9 10 11

12 13 14 15
16 17 18 19
20 21 22 23

   +/a
12 14 16 18
20 22 24 26
28 30 32 34
   +/"2 a
12 15 18 21
48 51 54 57
   +/"1 a
 6 22 38
54 70 86
</pre>

<a name="a.1"></a>
<p><b>Forks</b>. If<tt> f</tt>&nbsp;,<tt> g</tt>&nbsp;,<tt> </tt>
and<tt> h </tt>are verbs, then the (isolated)
sequence<tt> <nobr>f g h</nobr> </tt>
produces a verb, called <i>fork</i>, 
whose monadic and dyadic cases 
are defined by the following diagrams:</p>

<pre>
       g            g
      / \          / \
     f   h        f   h
     |   |       / \ / \
     y   y       x y x y
</pre>

<p>For example,<tt> a (+ * -) b </tt>is<tt> (a+b)*(a-b)</tt>&nbsp;.</p>

<p>Since<tt> % </tt>denotes division, and<tt> #y </tt>
the number of items of<tt> y</tt>&nbsp;,<tt> </tt>
then the arithmetic mean or average maybe defined tacitly
by<nobr><tt> mean=. +/ % #</tt>&nbsp;.</nobr><tt> </tt> 
Moreover, using the array<tt> <nobr>a=.i. 2 3 4</nobr> </tt>
shown earlier, mean maybe applied to
obtain the mean of the two tables, 
the mean of the rows for each of the two tables, 
and the means of each of the rows of the array:</p>

<pre>
   mean a
 6  7  8  9
10 11 12 13
14 15 16 17

   mean"2 a
 4  5  6  7
16 17 18 19

   mean"1 a
 1.5  5.5  9.5
13.5 17.5 21.5
</pre>

<p>Partitioned means may also be obtained. For example:</p>

<pre>
   mean\ 1 2 3 4 5 6
1 1.5 2 2.5 3 3.5
</pre>

<p>Moreover, each of the expressions such as<tt> mean"2 </tt>
and<tt> mean\ </tt>produces a derived verb, 
and can therefore be used
in further tacit definitions such as<tt> <nobr>m2=. mean"2</nobr> </tt>
and<nobr><tt> pm=. mean\</tt>&nbsp;.</nobr></p>

<p>The arithmetic mean was defined by a fork 
as<tt> mean=.+/%#</tt>&nbsp;.<tt> </tt>
The geometric mean is defined similarly
by<nobr><tt> gm=. */ %:~ #</tt>&nbsp;,<tt> </tt></nobr>
and may also be modified by rank
and partition conjunctions and adverbs. 
The verb<tt> %: </tt>is the
root (as in<tt> 3%:8 </tt>is<tt> 2</tt>)<tt> </tt>
and<tt> %:~ </tt>is the &ldquo;commuted&rdquo; root 
(as in<tt> <nobr>8 %:~ 3</nobr> </tt>is<tt> 2</tt>).</p>

<p>In some cases the effects of the rank conjunction and other
facilities of the tacit form are easily achieved in other
dialects. 
For example, the cases<tt> +/"k </tt>shown earlier can be
obtained as<tt> <nobr>+/[i] a</nobr> </tt>
for suitable values of<tt> i</tt>&nbsp;.<tt> </tt> 
However, this is not generally the case, 
as maybe seen in trying to
mimic cases such as<tt> mean"k </tt>
and<tt> mean\ </tt>and<tt> gm"k </tt>in
other dialects. 
To appreciate the convenience of tacit definition, 
the reader might reproduce in other dialects each
of the definitions discussed here.</p>

<a name="a.2"></a>
<p><b>Compositions</b>. The conjunction<tt> &amp; </tt>
is called <i>with</i>, and
applies to nouns (variables)<tt> a </tt>and<tt> b </tt>
as well as to verbs<tt> f </tt>
and<tt> g </tt>as follows:</p>

<pre>
     a&g y   is   a g y
     f&b y   is   x f y
     f&g y   is   f g y
   x f&g y   is   (g x) f (g y)
</pre>

<p>For example, since<tt> ^ </tt>and<tt> ^. </tt>
denote power and log,
respectively, then<tt> ^&3 </tt>is the cube, 
and<tt> 10&^. </tt>is the
base-10 logarithm, and<tt> 0&< </tt>
is a proposition to identify
positive arguments.</p>

<p>Such compositions can be particularly fruitful in forks. 
For example (since<tt> +. </tt>and<tt> *. </tt>and<tt> <. </tt>
denote <i>or</i> and <i>and</i> and <i>floor</i>):</p>

<table>
<tr><td><tt>q=. 0&< *. <&100 &nbsp; &nbsp;</tt></td><td>test for the interval 0 to 100</td></tr>
<tr><td><tt>r=. ] = <.      </tt></td> <td>test for integers</td></tr>
<tr><td><tt>s=. q *. r      </tt></td> <td>test for integer from O to 100</td></tr>
<tr><td><tt>t=. <: = < +. = </tt></td> <td>tautology<tt> </tt>(<tt><: </tt>is lessor equal)</td></tr>
<tr><td><tt>ld=. ^.&f % f   </tt></td> <td>log<tt> f </tt>over<tt> f</tt></td></tr>
</table>

<a name="a.3"></a>
<p><b>Other</b>. A number of other constructs in J similarly enhance
the utility of tacit definitions. The more important are the
<i>under</i> (or <i>dual</i>), <i>atop</i> 
(a second form of composition), 
the power conjunction<tt> ^:</tt>&nbsp;,<tt> </tt>
and further forms of partitions.</p>

<p>We conclude this section with a few less trivial examples.
The<tt> !n </tt>rows 
of the table<tt> <nobr>r=. (n-i.n)#:i.!n</nobr> </tt>
are all distinct, and therefore provide a possible representation
(called the <i>reduced</i> representation) of permutations 
of order<tt> n</tt>&nbsp;.<tt> </tt>
The following tacit definitions of<tt> dfr </tt>
(<i>direct from reduced</i>) 
and<tt> rfd </tt>provide transformations between
reduced and direct representations:</p>

<pre>
   dfr=. /:^:2@,/"1
   rfd=. +/@({.>}.)\."1
   r=. (n-i.n)#:i.!n=.3

  r        dfr r      rfd dfr r
0 0 0    0 1 2      0 0 0
0 1 0    0 2 1      0 1 0
1 0 0    1 0 2      1 0 0
1 1 0    1 2 0      1 1 0
2 0 0    2 0 1      2 0 0
2 1 0    2 1 0      2 1 0
</pre>

<p>Since the elements of the reduced representation indicate
the number of transpositions needed 
to effect a permutation<tt> p</tt>&nbsp;,<tt> </tt>
the parity of a permutation is<tt> _1^+/rfd p</tt>&nbsp;,<tt> </tt>
and:</p>

<pre>
   par=. ([-:/:^:2) * _1&^@(+/)@rfd
</pre>

<p>yields the parity of its argument if it is a permutation, and
<i>zero</i> if it is not.</p>

<p>We will call an array of shape<tt> n#n </tt>
a solid of order<tt> n</tt>&nbsp;.<tt> </tt>
The indices of such a solid are given 
by<tt> (n#n)#:i.n#n</tt>&nbsp;,<tt> </tt>and
their parity is given 
by<tt> sks=. par"1@((##:i.@#)~)</tt>&nbsp;.<tt> </tt>
McConnell 
<acronym title=
"McConnell, A.J., Applications of the Absolute Differential Calculus, Blackie and Son, 1931.">[5]</acronym>
calls the result of<tt> sks </tt>a <i>skew</i> system of
order<tt> n</tt>&nbsp;;<tt> </tt>
interchanging any pair of axes results in a change
of sign; 
for example,<nobr><tt> (0 2 1|:b)-:-b=.sks 3</tt>&nbsp;.</nobr></p>

<p>Skew systems will be used further in Section D, but we will
here show McConnell&rsquo;s procedure for the determinant of a
matrix<tt> m</tt>&nbsp;,<tt> </tt>
that is,<tt> +/"1^:(#m) (*//m) * sks #m</tt>&nbsp;,<tt> </tt>
based on the fact that the outer product of its 
rows<tt> (*//m) </tt>
contains all of the products 
that occur in the computation of
the determinant. For example:</p>

<pre>
   [m=.?3 3$10 
1 7 4
5 2 0
6 6 9

   +/"1^:(#m) (*//m)*sks #m
_225
</pre>

<p>Details of the calculation are shown below 
(with the tables boxed to provide a compact display):</p>

<pre>
   <"2 *//m
┌────────┬───────────┬───────────┐
│30 30 45│210 210 315│120 120 180│
│12 12 18│ 84  84 126│ 48  48  72│
│ 0  0  0│  0   0   0│  0   0   0│
└────────┴───────────┴───────────┘
   <"2 sks #m
┌──────┬──────┬──────┐
│0  0 0│0 0 _1│ 0 1 0│
│0  0 1│0 0  0│_1 0 0│
│0 _1 0│1 0  0│ 0 0 0│
└──────┴──────┴──────┘
   <"2 (*//m) * sks #m
┌──────┬────────┬─────────┐
│0 0  0│0 0 _315│  0 120 0│
│0 0 18│0 0    0│_48   0 0│
│0 0  0│0 0    0│  0   0 0│
└──────┴────────┴─────────┘
</pre>

<p>The product<tt> (*//m)*sks #m </tt>followed by summation on
all axes is a special case of McConnell&rsquo;s generalized inner
product to be introduced for handling the vector product in
Section D.
<br>&nbsp;</p>



<a name="b"></a>
<p><b>B. Translation from Explicit to Tacit Form</b></p>

<p>Suppose<tt> <b>s</b> </tt>is a sentence 
on nouns<tt> x. </tt>and<tt> y. </tt>that results
in a noun, ands makes no use of<tt> x. </tt>or<tt> y. </tt>
as argument to
an adverb or conjunction. 
We define an adverb<tt> T </tt>which
translates<tt> <b>s</b> </tt>into an equivalent tacit verb. 
Without loss of generality, 
assume that<tt> <b>s</b> </tt>contains no copulae; 
for if it does,<tt> d=.rhs </tt>(say), 
recursively replace instances of<tt> d </tt>
by<tt> (rhs)</tt>&nbsp;.</p>

<table>
<tr><td colspan=2>If<tt> <b>s</b> </tt>contains no verbs,<tt> <b>s</b>&nbsp;T </tt>is:</td></tr>
<tr><td><tt>[</tt></td><td>if<tt> <b>s</b> </tt>is<tt> x.</tt></td></tr>
<tr><td><tt>]</tt></td><td>if<tt> <b>s</b> </tt>is<tt> y.</tt></td></tr>
<tr><td valign=top><tt>a"_ &nbsp; &nbsp;</tt></td><td>if<tt> <b>s</b> </tt>is a noun<tt> a </tt>
which is neither<tt> x. </tt>nor<tt> y. </tt>(<tt>a"_ </tt>is
a constant verb with value<tt> a </tt>and infinite rank)</td></tr>
</table>

<p>Otherwise, let<tt> f </tt>be the root verb 
in<tt> <b>s</b></tt>&nbsp;;<tt> </tt>
so<tt> <b>s</b> </tt>is either<tt> f q </tt>
or<tt> p f q</tt>&nbsp;,<tt> </tt>
where<tt> p </tt>and<tt> q </tt>are sentences shorter than<tt> <b>s</b> </tt>
and are (by induction) translatable by<tt> T</tt>&nbsp;.<tt> </tt>
Thus<tt> <b>s</b>&nbsp;T </tt>is<tt> f@(q&nbsp;T) </tt>
if<tt> <b>s</b> </tt>
is<tt> f q</tt>&nbsp;,<tt> </tt>
and<tt> <b>s</b>&nbsp;T </tt>is<tt> (p&nbsp;T)f(q&nbsp;T) </tt>
if<tt> <b>s</b> </tt>is<tt> p&nbsp;f&nbsp;q</tt>&nbsp;.</p>

<p>In J Version 3.1,<tt> T </tt>is expressed as a case of the 
colon<tt> </tt>(<tt>:</tt>)<tt> </tt>
conjunction. The argument is a string. For example:</p>

<pre>
   '((i.#y.)=i.~y.)#y.' T =. : 11
┌───────────────────────────────┬─┬─┐
│┌──────────────┬─┬────────────┐│#│]│
││┌──┬─┬───────┐│=│┌──────┬─┬─┐││ │ │
│││i.│@│┌─┬─┬─┐││ ││┌──┬─┐│@│]│││ │ │
│││  │ ││#│@│]│││ │││i.│~││ │ │││ │ │
│││  │ │└─┴─┴─┘││ ││└──┴─┘│ │ │││ │ │
││└──┴─┴───────┘│ │└──────┴─┴─┘││ │ │
│└──────────────┴─┴────────────┘│ │ │
└───────────────────────────────┴─┴─┘
</pre>

<p>The translator is a straightforward adaptation of the parser.
The idea is to parse the sentence as usual, but also apply a
set of parallel actions to produce the tacit verb. As
described in the dictionary 
<acronym title=
"Iverson, Kenneth E., The Dictionary of J, Vector (Journal of the British APL Association), Volume 7, Number 2, 1990-07.">[2]</acronym>, 
parsing proceeds from right to left, 
moving successive elements 
(or their values in the case of names) 
of the sentence from a queue onto a stack.
An eligible portion of the stack is executed and replaced by
the result of execution. 
Eligibility for execution is defined
by the rules in Appendix B 
(reproduced from Table 2 of
<acronym title=
"Iverson, Kenneth E., The Dictionary of J, Vector (Journal of the British APL Association), Volume 7, Number 2, 1990-07.">[2]</acronym>), 
and is completely determined by the classes of the first
four elements of the stack. 
The translator maintains a parallel stack. 
Actions on the stack have parallel actions on
corresponding objects on the parallel stack. 
In particular, when the rules call for applying 
a verb to its argument(s),
resulting in a noun<tt> n</tt>&nbsp;,<tt> </tt> 
the parallel action is to compose the
verb with tacit verbs that produced the arguments, 
resulting in a new tacit verb 
(which, when applied to the original
arguments<tt> x. </tt>and<tt> y.</tt>&nbsp;,<tt> </tt>
produces<tt> n</tt>).</p>

<p>The following example illustrates the process. Like the
parsing example in Section II E of the dictionary, it uses a
line for each step in the parse. Successive columns show
the index of the line, the queue, the stack, 
and the parallel stack. 
The name<tt> y. </tt>has value<tt> 'aba'</tt>&nbsp;.</p>

<pre>
1  ((i.#y.)=i.~y.)#y.
2  ((i.#y.)=i.~y.)#         'aba'             ]
3  ((i.#y.)=i.~y.)         #'aba'            #]
4  ((i.#y.)=i.~y.         )#'aba'           )#]
5  ((i.#y.)=i.~      'aba')#'aba'          ])#]

6  ((i.#y.)=i.      ~'aba')#'aba'         ~])#]
7  ((i.#y.)=      i.~'aba')#'aba'       i.~])#]
8  ((i.#y.)      =i.~'aba')#'aba'       =i~])#]
9  ((i.#y.)      =f1 'aba')#'aba'       =g1])#]
10 ((i.#y.)         =0 1 0)#'aba'        =g2)#]

11 ((i.#y.         )=0 1 0)#'aba'       )=g2)#]
12 ((i.#      'aba')=0 1 0)#'aba'      ])=g2)#]
13 ((i.      #'aba')=0 1 0)#'aba'     #])=g2)#]
14 ((      i.#'aba')=0 1 0)#'aba'   i.#])=g2)#]
15 ((           i.3)=0 1 0)#'aba'   i.g3)=g2)#]

16 (           (i.3)=0 1 0)#'aba'  (i.g3)=g2)#]
17 (         (0 1 2)=0 1 0)#'aba'    (g4)=g2)#]
18 (           0 1 2=0 1 0)#'aba'      g4=g2)#]
19            (0 1 2=0 1 0)#'aba'     (g4=g2)#]
20                  (1 1 0)#'aba'        (g5)#]

21                    1 1 0#'aba'          g5#]
22                           'ab'            g6
</pre>

<p>Notes on the indicated lines:</p>

<table>
<tr><td valign=top>1)</td><td>
Initially, the queue contains the sentence to be parsed,
and the stack and the parallel stack are empty.
 </td></tr>
<tr><td valign=top>2)</td><td>
The value of name<tt> y. </tt>is moved to the stack. The
parallel action moves<tt> ] </tt>(which produces<tt> y.</tt>)<tt> </tt>
onto the parallel stack.
 </td></tr>
<tr><td valign=top>3)</td><td>
The action moves<tt> # </tt>to the stack; 
the parallel action
moves<tt> # </tt>to the parallel stack.
 </td></tr>
<tr><td valign=top>4)</td><td>
The action moves<tt> ) </tt>to the stack; 
the parallel action
moves<tt> ) </tt>to the parallel stack.
 </td></tr>
<tr><td valign=top>9)</td><td>
When an adverb is executed (in this case<tt> ~</tt>), 
a temporary verb result is produced.
Here,<tt> f1=.g1=.i.~</tt>&nbsp;.
 </td></tr>
<tr><td valign=top nowrap>10) &nbsp;</td><td>
The action applies verb<tt> f1 </tt>to noun<tt> 'aba'</tt>&nbsp;,<tt> </tt>
that is,<tt> i.~'aba' </tt>or<tt> 'aba'i.'aba' </tt>
(<tt>'aba'⍳'aba' </tt>in earlier dialects), 
resulting in<tt> 0 1 0</tt>&nbsp;.<tt> </tt>
The parallel action
composes verb<tt> g1 </tt>
with the corresponding verb<tt> ]</tt>&nbsp;,<tt> </tt>
resulting in a verb<tt> g2=.g1@]</tt>&nbsp;.
 </td></tr>
<tr><td valign=top>15)</td><td>
The action applies the monad<tt> # </tt>to noun<tt> 'aba' </tt>
(the number of items of<tt> 'aba'</tt>),<tt> </tt>
resulting in<tt> 3</tt>&nbsp;;<tt> </tt>
the parallel action composes<tt> # </tt>
with the corresponding verb<tt> ]</tt>&nbsp;,<tt> </tt>
resulting in<tt> g3=.#@]</tt>&nbsp;.
 </td></tr>
<tr><td valign=top>17)</td><td>
The action applies the monad<tt> i. </tt>to noun<tt> 3 </tt>
(<tt>⍳3 </tt>in earlier dialects), 
resulting in<tt> 0 1 2</tt>&nbsp;;<tt> </tt>
the parallel action composes<tt> i. </tt>
with the corresponding verb<tt> g3</tt>&nbsp;,<tt> </tt>
resulting in<tt> g4=.i.@g3</tt>&nbsp;.
 </td></tr>
<tr><td valign=top>20)</td><td>
The action applies the dyad<tt> = </tt>
to nouns<tt> <nobr>0 1 2</nobr> </tt>
and<tt> <nobr>0 1 0</nobr></tt>&nbsp;,<tt> </tt>
resulting in<nobr><tt> 1 1 0</tt>&nbsp;;</nobr><tt> </tt>
the parallel action composes<tt> = </tt>
with the corresponding 
verbs<tt> g4 </tt>and<tt> g2</tt>&nbsp;,<tt> </tt>
using fork and resulting in<tt> g5=.g4=g2</tt>&nbsp;.
 </td></tr>
<tr><td valign=top>22)</td><td>
The action applies the dyad<tt> # </tt>
to nouns<tt> <nobr>1 1 0</nobr> </tt>and
<tt> 'aba' </tt>(replicate,<tt> <nobr>1 1 0/'aba'</nobr> </tt>
in earlier dialects),
resulting in<tt> 'ab'</tt>&nbsp;;<tt> </tt>
the parallel action composes<tt> # </tt>with
corresponding verbs<tt> g5 </tt>and<tt> ]</tt>&nbsp;,<tt> </tt>
using fork, 
resulting in<tt> g6=.g5#]</tt>&nbsp;.<tt> g6 </tt>
is a tacit verb equivalent to the original
sentence<tt> ((i.#y.)=i.~y.)#y.</tt>&nbsp;.
 </td></tr>
</table>

<p>The translator has other parallel actions not exercised by
the example. The complete set is:</p>

<table>
<tr><td valign=top nowrap>a) &nbsp;</td><td>
<p>The Monad and Dyad actions apply a verb to its
argument(s). The parallel action may compose the verb
with the corresponding objects on the parallel stack,
depending on whether they are functions of the original
argument (denoted<tt> f </tt>and<tt> g </tt>below) 
or not<tt> </tt>(<tt>a </tt>and<tt> b</tt>).</p>

<table>
<tr><td></td><td>Parallel Stack &nbsp;</td><td>Parallel Action</td></tr>
<tr><td>Monad &nbsp; &nbsp;</td><td><tt>&nbsp; v a</tt></td><td><tt>&nbsp; v a</tt></td></tr>
<tr><td>Monad</td><td><tt>&nbsp; v f</tt></td><td><tt>&nbsp; v@f</tt></td></tr>
<tr><td>Dyad</td><td><tt>&nbsp; a v b</tt></td><td><tt>&nbsp; a v b</tt></td></tr>
<tr><td>Dyad</td><td><tt>&nbsp; a v g</tt></td><td><tt>&nbsp; a&v@g</tt></td></tr>
<tr><td>Dyad</td><td><tt>&nbsp; f v b</tt></td><td><tt>&nbsp; v&b@f</tt></td></tr>
<tr><td>Dyad</td><td><tt>&nbsp; f v g</tt></td><td><tt>&nbsp; f v g</tt></td></tr>
</table>
<br>
 </td></tr>

<tr><td valign=top>b)</td><td>
<p>If an adverb or conjunction has a noun argument, and the
corresponding object on the parallel stack is not a noun,
then the original sentence cannot be translated to tacit form.
Otherwise proceed as usual.</p>

<p>When a sentences is not translatable, 
the result of<tt> <b>s</b>&nbsp;T </tt>
is the
verb<tt> <b>s</b> : '' </tt>(if monadic) 
or<tt> '' : <b>s</b> </tt>(if dyadic).
 <br>&nbsp;</p></td></tr>

<tr><td valign=top>c)</td><td>
<p>Both copulae and references to names are cognizant of
the corresponding objects on the parallel stack. Indirect
assignment is not permitted.
 <br>&nbsp;</p></td></tr>

<tr><td valign=top>d)</td><td>
<p>When an element<tt> <b>e</b> </tt>of the sentence is moved from the
queue to the stack, the parallel action moves<tt> [ </tt>or<tt> ] </tt>
or<tt> <b>e</b> </tt>to the parallel stack, 
according to whether<tt> <b>e</b> </tt>is<tt> x. </tt>or<tt> y. </tt>
or otherwise.
 </p></td></tr>
</table>

<p>This ready adaptation of the parser emphasizes its
simplicity and power. The derivation of the translator
makes clear that fork 
<acronym title=
"Iverson, Kenneth E., and Eugene E. McDonnell, Phrasal Forms, APL Quote Quad, Volume 19, Number 4, 1989-08.">[7]</acronym>
is essential. 
The composition
produced by<tt> @ </tt>also has a key role, 
but the alternative composition<tt> &amp; </tt>
on verbs is non-essential; in fact,<tt> f&amp;g </tt>can
be defined in terms of fork and<tt> @</tt>&nbsp;:</p>

<pre>
   f&g y.          f g y.              f@g. y.
x. f&g y.    (g x.)f(g y.)     x. (g@[ f g@])y.
</pre>

<p>A tacit verb can be re-executed without reparsing the
original sentence; therefore,<tt> T </tt>is a compiler.</p>

<p>We conclude this section with further examples of applying
the adverb<tt> T</tt>&nbsp;.<tt> </tt>
The following is an excerpt from a session
on the system on 1991&nbsp;4&nbsp;23. 
The verb result of<tt> T </tt>is
automatically displayed, and at the end of each example is
given a (manually constructed) verb which would have the
same display:</p>

<pre>
      '3+y.' T =. : 11
┌───────┬─┬─┐
│┌─┬─┬─┐│@│]│
││3│&│+││ │ │
│└─┴─┴─┘│ │ │
└───────┴─┴─┘
3&+@]

   '(+/y.)%#y.' T
┌───────────┬─┬───────┐
│┌─────┬─┬─┐│%│┌─┬─┬─┐│
││┌─┬─┐│@│]││ ││#│@│]││
│││+│/││ │ ││ │└─┴─┴─┘│
││└─┴─┘│ │ ││ │       │
│└─────┴─┴─┘│ │       │
└───────────┴─┴───────┘
+/@] % #@]

   
   'x.+y.' T
┌─┬─┬─┐
│[│+│]│
└─┴─┴─┘
[+]

   '%:(x.^2)+y.2' T   
┌──┬─┬───────────────────────────────┐
│%:│@│┌─────────────┬─┬─────────────┐│
│  │ ││┌───────┬─┬─┐│+│┌───────┬─┬─┐││
│  │ │││┌─┬─┬─┐│@│[││ ││┌─┬─┬─┐│@│]│││
│  │ ││││^│&│2││ │ ││ │││^│&│2││ │ │││
│  │ │││└─┴─┴─┘│ │ ││ ││└─┴─┴─┘│ │ │││
│  │ ││└───────┴─┴─┘│ │└───────┴─┴─┘││
│  │ │└─────────────┴─┴─────────────┘│
└──┴─┴───────────────────────────────┘
%:@(^&2@[ + ^&2@])

   't*t=.x.+y.' T
┌───────┬─┬───────┐
│┌─┬─┬─┐│*│┌─┬─┬─┐│
││[│+│]││ ││[│+│]││
│└─┴─┴─┘│ │└─┴─┴─┘│
└───────┴─┴───────┘
([+]) * [+]
</pre>

<p>A tacit verb is more clearly structured than its linear
explicit equivalent, and is therefore more amenable to
automatic manipulation. 
For example,<tt> Inv=. ^:_1 </tt>is an
adverb which inverts a verb, and:</p>

<pre>
   '32+1.8*y.' T
┌────────┬─┬───────────────┐
│┌──┬─┬─┐│@│┌─────────┬─┬─┐│
││32│&│+││ ││┌───┬─┬─┐│@│]││
│└──┴─┴─┘│ │││1.8│&│*││ │ ││
│        │ ││└───┴─┴─┘│ │ ││
│        │ │└─────────┴─┴─┘│
└────────┴─┴───────────────┘
32&+@(1.8&*@])

   '32+1.8*y.' T Inv
┌────────────────────┬─┬─────────┐
│┌─┬─┬──────────────┐│@│┌───┬─┬─┐│
││]│@│┌────────┬─┬─┐││ ││_32│&│+││
││ │ ││0.555556│&│*│││ │└───┴─┴─┘│
││ │ │└────────┴─┴─┘││ │         │
│└─┴─┴──────────────┘│ │         │
└────────────────────┴─┴─────────┘
]@(0.555556&*)@(_32&+)

   ffc =. '32+1.8*y.' T
   cff =. ffc T Inv
   
   ffc 0 20 100
32 68 212
   cff ffc 0 20 100
0 20 100

</pre>



<a name="c"></a>
<p><b>C. Ten FinnAPL Idioms</b></p>

<p>Each of the ten items will begin with an exact quotation
from the Library. One or more tacit definitions will then be
given, which may include a straightforward translation of
the APL expression, a translation that defines a verb that
may then be applied to appropriate arguments, and perhaps
a solution to an interesting related problem.</p>

<p>Notation of the form<tt> X←D1 </tt>occurring in each idiom
indicates limitations on the type and rank of the arguments
to which the solution 
applies:<tt> A,B,C,D, </tt>and<tt> I </tt>denote Any,
Boolean, Character, Any Numeric, and Integer. Unless
otherwise noted, the tacit solutions apply to arguments of
any rank and type. 
Moreover, any tacit solution<tt> f </tt>can be
applied to each of the rank-k cells of an argument 
by using<tt> f"k</tt>&nbsp;.</p>

<p>**********************************************************</p>

<table>
<tr><td>1 &nbsp;</td><td width=368><tt>⌊.5×(⍋⍋X)+⌽⍋⍋⌽X</tt></td><td><tt>X←D1</tt></td></tr>
<tr><td></td><td colspan=2>Ascending cardinal numbers (ranking, shareable)</td></tr>
</table>

<pre>
   X=. 67 70 68 72 67 67 70 65
   <.0.5*(/:/:x)+|./:/:|.X
2 5 4 7 2 2 5 0
   F1=. <.@-:@ (/:@/: + /:@/:&.|.)
   F1 X
2 5 4 7 2 2 5 0
</pre>

<p>Although<tt> F1 </tt>is an accurate translation of the idiom as
printed, note that (a) the result gives ascending <i>ordinal</i>
numbers (not <i>cardinal</i>) and (b) the rankings are incorrect.
An inspection of the argument shows that the lowest score
(65) has rank 0, as it should, but that the next lowest score
(67), which appears three times, has rank 2, whereas it
should have rank 1. 
A corrected algorithm is the 
fork<tt> F1a=./:~ i. ]</tt>&nbsp;,<tt> </tt>
in which the indices of the items of the
argument are looked for in the sorted argument.</p>

<pre>
   F1a X
1 5 4 7 1 1 5 0
</pre>

<p>Although both of these properly gives equal ranks to equal
items, the ranks might also be compressed to a dense
sequence, such as<nobr><tt> 1 3 2 4 1 1 3 0</tt>&nbsp;.</nobr><tt> </tt>
The solution to this modifies<tt> F1a </tt>
by looking for the indices of the
argument in the sorted nub of the argument:</p>

<pre>
   F1b=./:~@~. i. ]
   F1b s
1 3 2 4 1 1 3 0
</pre>

<p>**********************************************************</p>

<table>
<tr><td>2 &nbsp;</td><td width=368><tt>Y[A⍳⌈\A←⍋A[⍋(+\X)[A←⍋Y]]]</tt></td><td><tt>X←B1; Y←D1</tt></td></tr>
<tr><td></td><td colspan=2>Maximum scan<tt> </tt>(<tt>⌈\</tt>)<tt> </tt>
 over subvectors of<tt> Y </tt>indicated by<tt> X</tt></td></tr>
</table>

<p>The following sequence of definitions shows how the tacit
verb<tt> F2 </tt>may be developed:</p>

<pre>
   Y=. 3 1 4 9 8 2 7 1 0
   X=. 1 0 0 1 0 1 0 0 1
   cut=. <;.1
   x cut Y
┌─────┬───┬─────┬─┐
│3 1 4│9 8│2 7 1│0│
└─────┴───┴─────┴─┘
   maxsc=. >./\
   each=. &.>
   maxsc each X cut Y
┌─────┬───┬─────┬─┐
│3 3 4│9 9│2 7 7│0│
└─────┴───┴─────┴─┘
   ,. maxsc each x cut Y
3 3 4 9 9 2 7 7 0
   F2=. ,.@(maxsc each@cut)
   X F2 Y
3 3 4 9 9 2 7 7 0
   F2
┌──┬─┬───────────────────────────────────┐
│,.│@│┌──────────────────────┬─┬────────┐│
│  │ ││┌─┬─┬────────────────┐│@│┌─┬──┬─┐││
│  │ │││<│@│┌──────────┬─┬─┐││ ││<│;.│1│││
│  │ │││ │ ││┌──────┬─┐│&│>│││ │└─┴──┴─┘││
│  │ │││ │ │││┌──┬─┐│\││ │ │││ │        ││
│  │ │││ │ ││││>.│/││ ││ │ │││ │        ││
│  │ │││ │ │││└──┴─┘│ ││ │ │││ │        ││
│  │ │││ │ ││└──────┴─┘│ │ │││ │        ││
│  │ │││ │ │└──────────┴─┴─┘││ │        ││
│  │ ││└─┴─┴────────────────┘│ │        ││
│  │ │└──────────────────────┴─┴────────┘│
└──┴─┴───────────────────────────────────┘
</pre>

The display of<tt> F2 </tt>above illustrates the fact that tacit
definitions are &ldquo;compiled&rdquo;
in the sense that the definitions
of component verbs are substituted for them.</p>

<p>Alternatively,<tt> F2a=. ,.@(<&(>./\);.1)</tt>&nbsp;.<tt> </tt> 
The verbs<tt> F2 </tt>and<tt> F2a </tt>are, of course, 
limited to booleans and numbers, 
but apply to arguments<tt> Y </tt>of higher rank. 
For example:</p>

<pre>
   ]Y=. ?9 5$45         X F2 Y
44 32 33 29  3       44 32 33 29  3
28 39 12 19 34       44 39 33 29 34
21 10 12 16  7       44 39 33 29 34
21 40 40  2 40       21 40 40  2 40
22 23 14 44 22       22 40 40 44 40
11  4 42  3 22       11  4 42  3 22
17 12 41 23 20       17 12 42 23 22
42  2 34 34 37       42 12 42 34 37
 5  0 30 39 28        5  0 30 39 28
</pre>

<p>**********************************************************</p>

<p>3 &nbsp; This idiom differs from #2 only in using 
min<tt> </tt>(<tt><.</tt>)<tt> </tt>
for max<tt> </tt>(<tt>>.</tt>).
</p>

<p>**********************************************************</p>

<table>
<tr><td>4 &nbsp;</td><td width=368><tt>Y[⍋Y]∧.=X[⍋X]</tt></td><td><tt>X←D1; Y←D1</tt></td></tr>
<tr><td></td><td colspan=2>Test if<tt> X </tt>and<tt> Y </tt>are permutations of each other</td></tr>
</table>

<p>The verb<tt> /: </tt>differs from the dyadic grade in standard
APL; the left argument is sorted into an order specified by
the right argument. In particular, the form<tt> /:~ </tt>uses the
duplicate adverb<tt> ~ </tt>to permit a single right argument to be
used also as the left argument.</p>

<pre>
   sort=. /:~
   F4=. -:&sort
   3 1 4 2 F4 1 2 4 3
1
   3 1 4 2 F4 1 2 2 2
0
</pre>

<p>The verb<tt> F4 </tt>applies to either numeric or character
arguments, and to arguments of any rank. For example:</p>

<pre>
   Y=. 'rosy lips and cheeks'
   X=. 'or physics and leeks'

   X F4 Y
1
</pre>

<p>**********************************************************</p>

<table>
<tr><td>5 &nbsp;</td><td width=368><tt>X[A[⍋(+\(⍳⍴X)∊+\⎕io,Y)[A←⍋X]]]</tt></td><td><tt>X←D1; Y←I1</tt></td></tr>
<tr><td></td><td colspan=2>Sorting subvectors of lengths<tt> Y </tt></td></tr>
</table>

<pre>
   X=.1 6 4 4 1 0 6 6
   Y=.3 3 2
   box=.[ cut~ i.@#@[ e. +/\@(0&,)@]
</pre>

<p>The portion of<tt> box </tt>beginning at<tt> i. </tt>is a fork with central
verb<tt> e. </tt>and<tt> box </tt>itself is a fork 
with central verb<tt> cut~</tt>&nbsp;.</p>

<pre>
   X box Y
┌─────┬─────┬───┐
│1 6 4│4 1 0│6 6│
└─────┴─────┴───┘
   X (F5=. ,.@(sort each@box)) Y
1 4 6 0 1 4 6 6
</pre>

<p>**********************************************************</p>

<table>
<tr><td>6 &nbsp;</td><td width=368><tt>Y[A[X/(+\X)[A←⍋Y]]]</tt></td><td><tt>X←B1; Y←D1</tt></td></tr>
<tr><td></td><td colspan=2>Minima<tt> </tt>(<tt>⌊/</tt>)<tt> </tt>of elements of subvectors of<tt> Y </tt>indicated by<tt> X </tt></td></tr>
</table>

<pre>
   ]Y=. i.-#X=.1 0 0 1 0 1 0 0 1
8 7 6 5 4 3 2 1 0
   F6=. <./ ;. 1
   X F6 Y
6 4 1 0
</pre>

<p>**********************************************************</p>

<table>
<tr><td>7 &nbsp;</td><td width=368><tt>A[⍋(+\X)[A←⍋Y]]</tt></td><td><tt>X←B1; Y←D1</tt></td></tr>
<tr><td></td><td colspan=2>Grading up subvectors of<tt> Y </tt>indicated by<tt> X </tt>indicated by<tt> X </tt></td></tr>
</table>

<pre>
   X (F7=. ,.@(/:each@cut)) Y
2 1 0 1 0 2 1 0 0
</pre>

<p>**********************************************************</p>

<table>
<tr><td>8 &nbsp;</td><td width=368><tt>(⍴X)⍴(,X)[⎕io+A[⍋⌊A÷¯1↑X]] ∆ A←(⍋,X)-⎕io</tt></td><td><tt>X←D2</tt></td></tr>
<tr><td></td><td colspan=2>Sorting rows of matrix into ascending order</td></tr>
</table>

<pre>
   F8=. sort"1
</pre>

<p>**********************************************************</p>

<table>
<tr><td>9 &nbsp;</td><td width=368><tt>(⍴X)⍴(,X)[A[⍋(,⍉(⌽⍴X)⍴⍳1↑⍴X)[A←⍋,X]]]</tt></td><td><tt>X←D2</tt></td></tr>
<tr><td></td><td colspan=2>Sorting rows of matrix into ascending order</td></tr>
</table>

<pre>
   F9=. F8
</pre>

<p>**********************************************************</p>

<table>
<tr><td>10&nbsp;</td><td width=324><tt>(⍋⍋(G+1),⍳⍴⍴X)⍉(Y,⍴X)⍴X</tt></td><td><tt>G←I0; Y←I0; X←A</tt></td></tr>
<tr><td></td><td colspan=2>Adding a new dimension after 
(before in 0-origin, the case in J)<br>dimension<tt> G Y</tt>-fold</td></tr>
</table>

<pre>
   F10=. ] # ,:@[
   m= . ~:&0 { 9&,@-
   $X
2 2 2
   $ X F10 Y=. 3
3 2 2 2
   G=. 1
   $ X F10"(m G) Y
2 3 2 2
   G=.0
   $ x F10"(m G) Y
3 2 2 2
   m 0
9

</pre>



<a name="d"></a>
<p><b>D. Inner Product and Orthogonal Systems</b></p>

<p>The matrix (or <i>inner</i>) product 
on two matrices<tt> M </tt>and<tt> N </tt>can
be viewed as an outer product<tt> </tt>(<tt>M*/N</tt>)<tt> </tt>
in which the last axis
of the first argument is &ldquo;run together&rdquo;
with the first axis of
the last argument</p>

<pre>   0 2 2 1 |: M*/N</pre>

<p>and summation is performed over the resulting axis:</p>

<pre>   +/"1 (0 2 2 1 |: M*/N)</pre>

<p>Inner product as defined by McConnell 
<acronym title=
"McConnell, A.J., Applications of the Absolute Differential Calculus, Blackie and Son, 1931.">[5]</acronym>,
is a
generalization of inner product in which each of a list of
axes of the first argument may be paired with each of a
corresponding list of axes of the second argument, with
summation occurring over each axis that results from the
pairings. Such an inner product is provided by the
conjunction:</p>

<pre>
   S=. '+/"1^:n@(x.&|:@[*"(n=.#x.)/ y.&|:@])'
   IP=. S : 2
</pre>

<p>Thus:</p>

<pre>
   [M=.?3 3$20            [N=.?3 3$20
13 13 18               13  0  7
 7 10 16                1  8 13
0   1 10               11 18 16
   M +/ .* N              M 1 IP 0 N
380 428 548            380 428 548
277 368 435            277 368 435
111 188 173            111 188 173
   (*//M) 0 1 2 IP 0 1 2 (sks #M)
308
   +/^:3(*//M)*sks #M
308
</pre>

<p>The first example shows the use of the general inner
product to produce the matrix product the last examples
show its use to compute the determinant by the process
developed in Section A. 
It should be noted that the definition 
of the conjunction<tt> IP </tt>is explicit, 
but that it may be <i>used</i> in tacit definitions 
in the normal manner.</p>

<p>McConnell uses a number of interesting inner products
with the skew array<nobr><tt> e=. sks 3</tt>&nbsp;.</nobr><tt> </tt>
In the following
examples, the tables are boxed (by<tt> <"2</tt>)<tt> </tt>
to provide a compact display:</p>

<pre>
   e=. sks 3
   <"2 e 2 IP 2 e
┌──────┬──────┬──────┐
│0 0 0 │ 0 1 0│ 0 0 1│
│0 0 0 │_1 0 0│ 0 0 0│
│0 0 0 │ 0 0 0│_1 0 0│
├──────┼──────┼──────┤
│0 _1 0│0 0 0 │0  0 0│
│1  0 0│0 0 0 │0  0 1│
│0  0 0│0 0 0 │0 _1 0│
├──────┼──────┼──────┤
│0 0 _1│0 0  0│0 0 0 │
│0 0  0│0 0 _1│0 0 0 │
│1 0  0│0 1  0│0 0 0 │
└──────┴──────┴──────┘
   e 1 2 IP 1 2 e
2 0 0
0 2 0
0 0 2
   0 1 2 IP 0 1 2~ e
6
</pre>

<p>The <i>complete</i> inner product is defined as the inner product
over the last<tt> k </tt>axes of both arguments, where<tt> k </tt>is the
minimum of their ranks:</p>

<pre>
   S=. '+/"1^:(x. r y.) x.*"(x. r y.)/y.'
   cip=. '' :S
</pre>

<p>where<tt> r=. <.&(#@$)</tt>&nbsp;.<tt> </tt>For example:</p>

<pre>
   M r a=. 1 2 3
1
   M cip a
93 75 32
   M cip M
1168
</pre>

<p>The verb</p>

<pre>   orth=. sks@# cip ]</pre>

<p>provides a complete inner product with the skew solid, and</p>

<pre>   north=. !@#@$ %~ orth</pre>

<p>provides a <i>normalized</i> version with the following properties
which hold only if a is neither an atom nor a solid (in
which case<tt> north&nbsp;a </tt>is an atom):</p>

<p>1.<tt> b=. north a </tt>is orthogonal to<tt> a</tt>&nbsp;;<tt> </tt>
that is,<tt> b cip a </tt>
is <i>zero</i>.<br>
2.<tt> north </tt>is self-inverse when applied to any result 
of<tt> north</tt>&nbsp;.</p>

<p>For example</p>

<pre>
   a=.1 2 3
   b=.1 5 7
   ;north each ^: 0 1 2 3 4 < a */ b
┌─────────────┐
│1  5  7      │
│2 10 14      │
│3 15 21      │
├─────────────┤
│_0.5 _2 1.5  │
├─────────────┤
│   0 1.5    2│
│_1.5   0 _0.5│
│  _2 0.5    0│
├─────────────┤
│_0.5 _2 1.5  │
├─────────────┤
│   0 1.5    2│
│_1.5   0 _0.5│
│  _2 0.5    0│
└─────────────┘
</pre>

<p>The leading<tt> ; </tt>is merely to provide a vertical display since
the narrow column will not permit displaying the result in a
large enough type size.</p>

<pre>
   a cip north a*/b
0
   (a*/b) cip north (a*/b)
0 0 0
</pre>

<p>If<tt> skew=. orth@(*/)</tt>&nbsp;,<tt> </tt>
then<nobr><tt> a skew b </tt></nobr>is the <i>skew</i> or
<i>cross</i> product of vectors<tt> a </tt>and<tt> b</tt>&nbsp;;<tt> </tt>
it is perpendicular to their plane, 
and its length is the area of the parallelepipeds they embrace.</p>

<p>To obtain an approximation to the derivative of a rank-0
function<tt> f </tt>at a point<tt> y</tt>&nbsp;,<tt> </tt>
we choose a small &ldquo;delta&rdquo;<tt> dt=.1e_6 </tt>
and evaluate<nobr><tt> %&dt (f y+dt)-f y</tt>&nbsp;.</nobr><tt> </tt> 
To obtain the &ldquo;partial derivatives&rdquo; 
with respect to each element
of a higher-rank argument<tt> y</tt>&nbsp;,<tt> </tt>
we use the increment<tt> dt </tt>
times<tt> inc&nbsp;y</tt>&nbsp;,<tt> </tt> 
where<nobr><tt> inc=. =/&(i.@$)~</tt>&nbsp;.</nobr><tt> </tt>
For example:</p>

<pre>
   <"2 inc i. 3 3
┌─────┬─────┬─────┐
│1 0 0│0 1 0│0 0 1│
│0 0 0│0 0 0│0 0 0│
│0 0 0│0 0 0│0 0 0│
├─────┼─────┼─────┤
│0 0 0│0 0 0│0 0 0│
│1 0 0│0 1 0│0 0 1│
│0 0 0│0 0 0│0 0 0│
├─────┼─────┼─────┤
│0 0 0│0 0 0│0 0 0│
│0 0 0│0 0 0│0 0 0│
│1 0 0│0 1 0│0 0 1│
└─────┴─────┴─────┘
</pre>

<p>Thus the adverb</p>

<pre>   D=. '%&dt@(x.@(]+*&dt@inc)-x.)' : 1</pre>

<p>provides the derivatives of a function to which it is applied.
For example:</p>

<pre>
   a=.1 2 3

   linear=. +/ . * &(m=.?3 3$10)
   linear a 
21 5 27 
   linear D a
3 5 8
0 0 5
6 0 3

   rev=. |."1
   rev a
3 2 1
   rev D a
0 0 1
0 1 0
1 0 0
</pre>

<p>The derivative of the linear function is, of course, the value
of the matrix<tt> m </tt>that defines it.</p>

<p>The <i>curl</i> of a function is orthogonal to the derivative. 
For example if<tt> F11=.(]*|.)"1 </tt>
then<tt> orth F11 D a </tt>is<tt> 0 _2 0</tt>&nbsp;,<tt> </tt>
in agreement with the curl of the same function
in 
<acronym title=
"Iverson, Kenneth E., The Derivative Operator, ACM Quote Quad, Volume 9, Number 4, 1979-06.">[6]</acronym>. 
Consequently,<tt> curl=.'orth@(x. D)' : 1 </tt>
defines the curl of a function to which it is applied. 
Thus,<tt> F11 curl a </tt>is again<tt> 0 _2 0</tt>&nbsp;.
<br>&nbsp;</p>



<a name="ref"></a>
<p><b>References</b></p>

<table>
<tr><td valign=top>1.</td><td>&nbsp;<td>
Hui, Roger K.W., Kenneth E. Iverson, Eugene E. McDonnell, and Arthur T. Whitney,
<a target=_parent href="http://www.jsoftware.com/papers/J1990.htm">APL\?</a>, 
ACM <i>Quote Quad</i>, Volume 20, Number 4, 1990-07.
 </td></tr>
<tr><td valign=top>2.</td><td>&nbsp;<td>
Iverson, Kenneth E., The Dictionary of J, <i>Vector</i>
(Journal of the British APL Association), Volume 7, Number 2, 1990-07.
 </td></tr>
<tr><td valign=top>3.</td><td>&nbsp;<td>
Iverson, Kenneth E., <i>Tangible Math and the ISI Dictionary of J</i>, 1990-10.
 </td></tr>
<tr><td valign=top>4.</td><td>&nbsp;<td>
<i>FinnAPL Idiom Library</i>, Finnish APL Association, 1982.
 </td></tr>
<tr><td valign=top>5.</td><td>&nbsp;<td>
McConnell, A.J., <i>Applications of the Absolute Differential Calculus</i>,
Blackie and Son, 1931.
 </td></tr>
<tr><td valign=top>6.</td><td>&nbsp;<td>
Iverson, Kenneth E., The Derivative Operator, 
ACM <i>Quote Quad</i>, Volume 9, Number 4, 1979-06.
 </td></tr>
<tr><td valign=top>7.</td><td>&nbsp;<td>
Iverson, Kenneth E., and Eugene E. McDonnell,
<a target=_parent href="http://www.jsoftware.com/papers/fork.htm">Phrasal Forms</a>, 
<i>APL Quote Quad</i>, Volume 19, Number 4, 1989-08.
 </td></tr>
</table>
<br>



<a name="axa"></a>
<p><b>Appendix A</b></p>

<p>This is a brief summary of the J notation used
in this paper.
Iverson
<acronym title=
"Iverson, Kenneth E., Tangible Math and the ISI Dictionary of J, 1990-10.">[3]</acronym>
has a complete description.
Primitive words are spelled with one or two letters;
the second is a period or a colon.
In what follows,<tt> f </tt>and<tt> g </tt>are verbs,
and<tt> m</tt>&nbsp;,<tt> n</tt>&nbsp;,<tt> x</tt>&nbsp;,
and<tt> y </tt>are nouns.</p>

<table>
<tr><td colspan=2><a name="axa.0"></a><b>Monads</b></td></tr>
<tr><td><tt>$y</tt></td> <td>shape of<tt> y</tt></td></tr>
<tr><td><tt>#y</tt></td> <td>number of items in<tt> y</tt></td></tr>
<tr><td><tt>i.y</tt></td> <td><tt>y </tt>integers from 0</td></tr>
<tr><td><tt>~.y</tt></td> <td>nub<tt> y</tt></td></tr>
<tr><td><tt>,.y</tt></td> <td>itemize<tt> y </tt>(<tt>$,.y </tt>is<tt> 1,$y</tt>)</td></tr>
<tr><td><tt>;y</tt></td> <td>matrix of<tt> y</tt></td></tr>
<tr><td><tt>/:y</tt></td> <td>upgrade of<tt> y</tt></td></tr>
<tr><td><tt>{.y</tt></td> <td>head of<tt> y</tt></td></tr>
<tr><td><tt>}.y</tt></td> <td>behead of<tt> y</tt></td></tr>
<tr><td><tt>[y</tt></td> <td><tt>y</tt></td></tr>
<tr><td><tt>]y</tt></td> <td><tt>y</tt></td></tr>
<tr><td><tt><.y</tt></td> <td>floor of<tt> y</tt></td></tr>
<tr><td><tt>%</tt></td> <td>reciprocal<tt> y</tt></td></tr>
<tr><td><tt>^.y</tt></td> <td>natural log of<tt> y</tt></td></tr>
<tr><td><tt>-:y</tt></td> <td>half of<tt> y</tt></td></tr>
<tr><td><tt>|:y</tt></td> <td>transpose<tt> y</tt></td></tr>
<tr><td><tt>|.y</tt></td> <td>reverse<tt> y</tt></td></tr>

<tr><td colspan=2><a name="axa.1"></a><b>Dyads</b></td></tr>
<tr><td><tt>x$y</tt></td> <td>shape items of<tt> y </tt>by<tt> x</tt></td></tr>
<tr><td><tt>x,:y</tt></td> <td>append itemized<tt> x </tt>to itemized<tt> y</tt></td></tr>
<tr><td><tt>x[y</tt></td> <td><tt>x</tt></td></tr>
<tr><td><tt>x|:y</tt></td> <td>move axes<tt> x </tt>to tail end</td></tr>
<tr><td><tt>x e.y</tt></td> <td>1 if<tt> x </tt>in<tt> y</tt></td></tr>
<tr><td><tt>x-:y</tt></td> <td>1 if<tt> x </tt>matches<tt> y</tt></td></tr>
<tr><td><tt>x^y</tt></td> <td><tt> x </tt>to the<tt> y </tt>power</td></tr>
<tr><td><tt>x>.y</tt></td> <td>larger of<tt> x </tt>and<tt> y</tt></td></tr>
<tr><td><tt>x~:y</tt></td> <td>1 if<tt> x </tt>not equal to<tt> y</tt></td></tr>

<tr><td colspan=2><a name="axa.2"></a><b>Adverbs</b></td></tr>
<tr><td><tt>f~y</tt></td> <td><tt>y f y</tt></td></tr>
<tr><td><tt>f/y</tt></td> <td>insert<tt> f </tt>between the items of<tt> y</tt></td></tr>
<tr><td><tt>f\y</tt></td> <td>apply<tt> f </tt>to prefixes of<tt> y</tt></td></tr>
<tr><td><tt>f\.y</tt></td> <td>apply<tt> f </tt>to suffixes of<tt> y</tt></td></tr>
<tr><td><tt>x f/y</tt></td> <td><tt>f </tt>outer product of<tt> x </tt>with<tt> y</tt></td></tr>
<tr><td><tt>x f~y</tt></td> <td><tt>y f x</tt></td></tr>

<tr><td colspan=2><a name="axa.3"></a><b>Conjunctions</b></td></tr>
<tr><td><tt>f"n y</tt></td> <td>apply<tt> f </tt>to rank-<tt>n </tt>cells of<tt> y</tt></td></tr>
<tr><td><tt>f^:n y</tt></td> <td>apply<tt> f n </tt>times to<tt> y</tt></td></tr>
<tr><td><tt>f@g y</tt></td> <td><tt>f g y</tt></td></tr>
<tr><td><tt>x f@g y</tt></td> <td><tt>f x g y</tt></td></tr>
<tr><td><tt>f&amp;g y</tt></td> <td><tt>f g y</tt></td></tr>
<tr><td><tt>x f&amp;g y</tt></td> <td><tt>(g x) f g y</tt></td></tr>
<tr><td><tt>f&amp;.g y</tt></td> <td><tt>(g Inv) f&amp;g y</tt></td></tr>
<tr><td><tt>x f&amp;.g y</tt></td> <td><tt>(g Inv) x f&amp;g y</tt></td></tr>
<tr><td><tt>m&amp;f y</tt></td> <td><tt>m f y</tt></td></tr>
<tr><td><tt>f&amp;m y</tt></td> <td><tt>y f m</tt></td></tr>

<tr><td colspan=2><a name="axa.4"></a><b>Phrasal Form</b></td></tr>
<tr><td><tt>(f g h) y</tt></td>   <td><tt>(f y) g (h y)</tt></tr>
<tr><td nowrap><tt>x (f g h) y &nbsp;</tt></td> <td><tt>(x f y) g (x h y)</tt></tr>

<tr><td colspan=2><a name="axa.5"></a><b>Copula</b></td></tr>
<tr><td><tt>=.</tt></td> <td>local assignment</td></tr>

<tr><td colspan=2><a name="axa.6"></a><b>Other</b></td></tr>
<tr><td><tt>_</tt></td> <td>negative sign</td></tr>
</table>
<br>



<a name="axb"></a>
<p><b>Appendix B: Parsing Rules</b></p>

<table>
<tr><td>[=(av</td>         <td><b>v</b></td>           <td><b>n</b></td>           <td>&amp;</td>                          <td><i>Monad</i></td>    <td colspan=2>Legend</td></tr>
<tr><td>c</td>             <td>n</td>                  <td><b>v</b></td>           <td><b>n</b></td>                       <td><i>Monad</i></td>           <td>a &nbsp;</td><td>Adverb</td></tr>
<tr><td>[=(avn &nbsp;</td> <td><b>n</b></td>           <td><b>v</b></td>           <td><b>n</b></td>                       <td><i>Dyad</i></td>            <td>c &nbsp;</td><td>Conjunction</td></tr>
<tr><td>[=(avn</td>        <td><b>nv</b></td>          <td><b>a</b></td>           <td>&amp;</td>                          <td><i>Adverb</i></td>          <td>n &nbsp;</td><td>Noun</td></tr>
<tr><td>&nbsp;</td></tr>
<tr><td>[=(avn</td>        <td><b>nv</b></td>          <td><b>c</b></td>           <td><b>nv &nbsp; &nbsp; &nbsp;</b></td> <td><i>Conj</i></td>           <td>p &nbsp;</td><td>Pronoun</td></tr>
<tr><td>[=(avn</td>        <td><b>v</b></td>           <td><b>v</b></td>           <td><b>v</b></td>                       <td><i>Fork</i></td>           <td>v &nbsp;</td><td>Verb</td></tr>
<tr><td>[=(</td>           <td><b>v</b></td>           <td><b>v</b></td>           <td>&amp;</td>                          <td><i>Hook</i></td>           <td>[ &nbsp;</td><td>Left Marker</td></tr>
<tr><td><b>np</b></td>     <td><b>=</b></td>           <td><b>cavn</b> &nbsp;</td> <td>&amp;</td>                          <td><i>Is</i></td>             <td>= &nbsp;</td><td>Is</td></tr>
<tr><td>&nbsp;</td></tr>
<tr><td>[=(</td>           <td><b>c</b></td>           <td><b>nv</b></td>          <td>&amp;</td>                          <td><i>Conj</i></td>           <td>( &nbsp;</td><td>Left Paren</td></tr>
<tr><td>[=(</td>           <td><b>nv</b></td>          <td><b>c</b></td>           <td>&amp;</td>                          <td><i>Conj</i></td>           <td>) &nbsp;</td><td>Right Paren</td></tr>
<tr><td><b>(</b></td>      <td><b>cavn</b> &nbsp;</td> <td><b>)</b></td>           <td>&amp;</td>                          <td><i>Punct</i> &nbsp;</td>   <td>&amp; &nbsp;</td><td>Any</td></tr>
<tr><td>&amp;</td>         <td>&amp;</td>              <td>&amp;</td>              <td>&amp;</td>                          <td nowrap><i>Get Next</i> &nbsp; &nbsp; &nbsp;</td> </tr>
</table>



<br><hr>
<font size=-1>
<p>Originally appeared in APL91, APL Quote Quad, Volume 21, Number 4, 1991-08.</p>

<script src="apldisplay.js" type="text/javascript"></script>
</font></p>

<table>
<tr><td><font size="-1">created: &nbsp;</font></td><td><font size="-1">2012-12-30 20:50</font></td></tr>
<tr><td><font size="-1">updated:</font></td><td><font size="-1">2019-02-26 18:45</font></td></tr>
</table>

</td></tr></table>
<br><br><br>
</body>
</html>