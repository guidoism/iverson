<html>
<head><meta http-equiv="content-type" content="text/html;charset=utf-8">
<title>APL Syntax and Semantics</title>
<link href="adoc.css" rel=stylesheet>
</head>

<body>

<br>

<table width=520 align=center><tr><td>

<p align=center><font size=+2>APL Syntax and Semantics</font><br><br>
<b>Kenneth E. Iverson</b><br><br>
I.P. Sharp Associates<br>
Box 418, Exchange Tower<br>
2 First Canadian Place<br>
Toronto, Canada<br>
M5X 1E3</p>



<br><hr>

<a name="intro"></a>

<p>This paper presents a working model of APL syntax and semantics
that incorporates explicit representations of functions, operators, and
syntax, thus providing a basis for the clear and explicit statement of
extended facilities in the language, as well as a tool for experimentation
upon them. Use of the model is illustrated in the treatment of
the syntax of operators, and in the discussion of a number of new
or recently-proposed facilities including indirect assignment, 
the operators <i>axis</i>, <i>derivative</i>, <i>inverse</i>, 
and <i>til</i>, and the functions <i>link</i>, and <i>from</i>. 
The entire model is included in an appendix.</p>

<p>The model is expressed in SHARP APL as extended in 
<acronym title=
"R. Bernecky and K.E. Iverson, Operators and Enclosed Arrays, APL Users Meeting, I.P. Sharp Associates, October, 1980.">[1]</acronym> 
but, because it uses few special features 
(enclose, disclose, close composition,
and dual) it should translate easily into other systems 
(such as NARS 
<acronym title=
"Carl Cheney, APL*PLUS Nested Arrays Reference Manual, STSC Corporation, 1981.">[2]</acronym>
and APL2 
<acronym title=
"APL Language Manual, Form number SB21-3015, IBM Corporation, 1982.">[3]</acronym>) 
that provide some form of enclosed arrays.</p>

<p>We will begin with the overall behaviour of the model as seen in
the definition and use of the two outer 
functions<tt> APL </tt>and<tt> S </tt> 
(the &ldquo;stack manager&rdquo; that applies to the 
left stack<tt> L </tt>of the expression to be
evaluated, and a right stack<tt> R </tt>of intermediate results), 
and continue with the tabular definition of syntax, 
and the representations of functions
and operators. 
0-origin indexing is used throughout, and enclosed
arrays are normally displayed within enclosing vertical bars,
as determined by the setting<tt> <nobr>⎕ps← ¯1 ¯1 0 ¯3</nobr> </tt>
(see Reference 
<acronym title=
"P.K. Wooster, “Improved Display for Enclosed Arrays and a New System Variable ⎕ps”, Technical Supplement 37, I.P. Sharp Newsletter, Vol. 10, Number 2, 1982.">[4]</acronym>).</p>

<p>The function<tt> APL </tt>accepts literal input and executes the expression
entered, using definitions of extended functions and operators already
provided. For example:</p>

<table>
<tr><td width=228 valign=top><tt>&nbsp; &nbsp; &nbsp; APL</tt></td>
 <td></td></tr>
<tr><td valign=top><tt>&nbsp; &nbsp; q←3 2 4⍴⍳24</tt></td>
 <td valign=top>Reduced indent within the model.</td></tr>
<tr><td valign=top><pre>
    ,⍤1 2 q
 0  1  2  3  4  5  6  7
 8  9 10 11 12 13 14 15
16 17 18 19 20 21 22 23</pre></td>
 <td valign=top>Ravel along axes<tt> 1 2</tt></td></tr>
<tr><td valign=top><pre>
    f←,⍤1 2

    f q
 0  1  2  3  4  5  6  7
 8  9 10 11 12 13 14 15
16 17 18 19 20 21 22 23</pre></td>
 <td valign=top>Assign the name<tt> f </tt>to this ravel</td></tr>
<tr><td valign=top><tt>&nbsp; &nbsp; ⍝→</tt></td>
 <td valign=top>An expression preceded by<tt> ⍝ </tt>is<br>
executed in raw APL; this exits
 </td></tr>
</table>

<p>The function APL and its main supporting function are defined as
follows:</p>

<pre>
APL;Z;X;NORE;⎕ps
NORE←<< 0 2 3 5 7 ⍴0×⎕ps← ¯1 ¯1 0 3
L1:→(^/' '=X←⍞,⍞←'    ')/L1
→('⍝'≠1↑X←(+/∧\' '=X)↓X)/L2
⍎1↓X
→L1
L2:Z←(X←TK X) S ''
→('←'=''⍴,>1↑(N X)/X)/L1
→L1,0⍴⎕←⍎((0=⍴⍴>Z)/'>'),'>Z'

Z←L S R
Z←⍎,>ACT[''⍴AC R]
</pre>

<p>The main action is the application 
of the stack manager<tt> S </tt>to an
empty right stack and a left stack of enclosed individual tokens
(names, primitives, constants, etc.) 
produced by the tokenizing function<tt> TK</tt>&nbsp;.<tt> </tt>
The function<tt> S </tt>simply executes one of a set of actions
represented in the vector<tt> ACT</tt>&nbsp;,<tt> </tt>
selection from<tt> ACT </tt>being determined
by the <i>action and classes</i> 
function<tt> AC</tt>&nbsp;,<tt> </tt>
which in turn depends on the
syntax table<tt> ST</tt>&nbsp;.<tt> </tt>
The following display of<tt> ACT </tt>appears in enclosing
bars because of<nobr><tt> ⎕ps←¯1 ¯1 0 ¯3</tt>&nbsp;:</nobr></p>

<pre>
      ⍉,¨&lt;ACT

|(>''⍴Z)S(1↓Z←L LE 4=1↑,⍴⍤>⍴¨>R),R|
|L S((>>R[0]) IS R[2]),3↓R|
|L S(2↑R),(R[2]RE R[,3]),4↓R|
|L S(1↑R),(R[1]RE R[,2],3↓R|
|L S(1↑R),(R[2]RE E R[1 3]),4↓R|
|L S(1↑R),(R[2]RE R[,1]),3↓R|
|⍎'R[1]',(2&lt;⍴R)/'R not clear∘'|
</pre>

<p>In order to provide convenient tracing of the execution we
incorporate in<tt> S </tt>
three uses of a <i>trace</i> function<tt> TR </tt>
as follows:</p>

<pre>
Z←L S R
Z←⍎,>ACT[''⍴' ACS' TR AC 'r: ' TR R],0⍴'l: ' TR L
</pre>

<p>The display produced by<tt> TR </tt>
consists of its left argument followed by
its right, except that the number of rows displayed is limited by the
magnitude of the trace control variable<tt> t0</tt>&nbsp;;<tt> </tt>
if<tt> t0 </tt>is positive, the
display is suppressed (except for a blank line) 
if the left argument of<tt> TR </tt>
begins (as it does in the first occurrence of<tt> TR</tt>)<tt> </tt>
with a space.
Finally, the display of a function is limited to its primary part, 
the body and axes. Thus:</p>

<pre>
      APL
    ⍝t0←1
    (÷4)+5
l:  |(| |÷| |4| |)| |+| |5|
r:
l:  |(| |÷| |4| |)| |+|
r:  ||5||
l:  |(| |÷| |4| |)|
r:  |||⍝<<(>>⍺)+>>⍵|| ||⍝<<+>>⍵||| ||5||
l:  |÷| |4|
r:
l:  |÷|
r:  ||4||
l:
r:  |||⍝<<(>>⍺)÷>>⍵|| ||⍝<<÷>>⍵||| ||4||
l:
r:  |⍝| |||⍝<<(>>⍺)÷>>⍵|| ||⍝<<÷>>⍵||| ||4||
l:
r:  |⍝| ||0.25||
l:
r:  ||0.25|| |||⍝<<(>>⍺)+>>⍵|| ||⍝<<+>>⍵||| ||5||
l:
r:  |⍝| ||0.25|| |||⍝<<(>>⍺)+>>⍵|| ||⍝<<+>>⍵||| ||5||
l:
r:  |⍝| ||5.25||
5.25
</pre>

<p>The five segments of this example beginning 
with<tt> <nobr>l: |÷| |4|</nobr> </tt>
illustrate the recursive use of<tt> S </tt>
to handle parenthesized expressions.
The details of the representations 
of the functions<tt> ÷ </tt>and<tt> + </tt>
(whose first lines appear in the displays of the right stack) 
may be ignored for the moment.</p>

<p>The &ldquo;left evaluation&rdquo; function<tt> LE </tt> 
handles the transfer of successive
tokens from the input text to the righthand stack of intermediate
results. Because the evaluated result in the right stack has no
connection with the original names, 
the treatment of &ldquo;side-effects&rdquo; in
expressions such as<tt> (a←3)(a←+)a←4 </tt>is clearly defined. 
For example:</p>

<pre>
    ⍝t0←0
    (a←3)(a←+)a←4
0.75
    a
3
</pre>

<p>The example may be repeated with<tt> t0 </tt>
set to<tt> 1</tt>&nbsp;.</p>

<p>The function<tt> LE </tt>normally 
evaluates each token and transfers the
evaluated result to the right stack, 
but if the first element on the right
stack is an assignment arrow, 
the evaluation is suppressed. 
For example:</p>

<pre>
    a←'bcd'
    ⍝t0←1
    a←a,a

l:  |a| |←| |a| |,| |a|
r:
l:  |a| |←| |a| |,|
r:  ||bcd||
l:  |a| |←| |a|
r:  |||⍝<<(>>⍺),>>⍵|| ||⍝<<,>>⍵||| ||bcd||
l:  |a| |←|
r:  ||bcd|| |||⍝<<(>>⍺),>>⍵|| ||⍝<<,>>⍵||| ||bcd||
l:  |a|
r:  |←| ||bcd|| |||⍝<<(>>⍺),>>⍵|| ||⍝<<,>>⍵||| ||bcd||
l:  |a|
r:  |←| ||bcdbcd||
l:
r:  ||a|| |←| ||bcdbcd||
l:
r:  ||bcdbcd||
l:
r:  |⍝| ||bcdbcd||

    ⍝t0←1
    a
bcdbcd
    ⍝→

</pre>



<a name="a"></a>
<p><b>A. Syntax</b></p>

<p>APL syntax questions may be characterized as 
<i>old</i> or <i>new</i>, the
latter referring to the new questions raised by the general treatment
of operators, and the former to old problems introduced by anomalies
such as the treatment of brackets and semicolons in indexing, in axis
operators, and in mixed output.</p>

<p>The old questions will here be treated as obsolescent, that is,
nothing will be done to disturb existing definitions, 
either to invalidate
their use in existing programs, or to extend them and encourage their
use. The use of semicolons and brackets is therefore ignored in the
model; in an actual implementation they could either be treated by
established ad hoc mechanisms, or they could be eliminated by a
&ldquo;preprocessing&rdquo; translation 
to equivalent normal expressions.</p>

<p>The new questions are addressed in the model 
by the <i>action and classes</i> 
function<tt> AC</tt>&nbsp;,<tt> </tt>
which examines the stack of intermediate results
to determine what action is to be taken next. In the syntax proposed
here, this function depends only on the first four elements of the
intermediate results, 
and depends only on the <i>class</i> of each 
of these elements.</p>

<p>The classes and their numeric encodings are as follows:</p>

<table>
<tr><td valign=top>0 &nbsp;</td><td>Variable</td></tr>
<tr><td valign=top>1 &nbsp;</td><td>Monadic operator</td></tr>
<tr><td valign=top>2 &nbsp;</td><td>Dyadic operator</td></tr>
<tr><td valign=top>3 &nbsp;</td><td>Function</td></tr>
<tr><td valign=top>4 &nbsp;</td><td>Assignment arrow</td></tr>
<tr><td valign=top>5 &nbsp;</td><td>Left filler (exhaustion of the 
left stack, denoted in a trace by<tt> ⍝</tt>)</td></tr>
<tr><td valign=top>6 &nbsp;</td><td>Right filler (exhaustion of the right stack)</td></tr>
</table>

<p>The encodings of the first four correspond to the valences of the
entities represented (allowing 3 as the sum of the potential valences
of a function). They also correspond to the ranks of the arrays whose
enclosures represent the entities. 
Consequently the expression<tt> ⍴⍤&gt;⍴¨&gt;⍵ </tt>
occurring in the function<tt> AC </tt>
determines the class of each
element of the argument<tt> ⍵</tt>&nbsp;.</p>

<p>The syntax rules are, in effect, the manner in which the next action
is chosen according to the classes of the intermediate result. 
This choice is made by the 
function<tt> AC </tt>(Action and Classes) in two steps:</p>

<table>
<tr><td valign=top>1. &nbsp;</td><td>
The classes of the first four elements of<tt> R </tt>
(completed by the filler code 6) are matched with the rows 
of the first four columns of the
symbol table<tt> ST</tt>&nbsp;,<tt> </tt>
each individual comparison being negated if the
element of<tt> ST </tt>is negative; 
thus an entry<tt> ¯2 </tt>designates anything
<i>except</i> a dyadic operator.
 <br>&nbsp;</td></tr>
<tr><td valign=top>2. &nbsp;</td><td>
The first matching row selects the corresponding element of the
last column of<tt> ST </tt>to be used (in<tt> S</tt>)<tt> </tt>
as an index to the table of actions<tt> ACT</tt>&nbsp;.<tt> </tt>
The classes are included in the result of the function<tt> AC </tt>only
for use in tracing.
 </td></tr>
</table>

<p>The proposed syntax table is defined as follows:</p>

<pre>
    ST
¯7  4 ¯7  6  1
 1  3  0 ¯7  3
 3  3  0 ¯7  3
 5  3  0 ¯7  3
 4  3  0 ¯7  3
 2  0  3  0  2
¯2  0  3  0  4
¯2 ¯1  2 ¯7  4
¯2 ¯1  1 ¯7  5
 5 ¯5 ¯7 ¯7  6
¯7 ¯7 ¯7 ¯7  0
</pre>

<p>However, it can be studied more easily in a display 
(produced by the function<tt> syntax</tt>)<tt> </tt>
which substitutes for each numeric code a more
mnemonic representation, 
and appends the corresponding action
chosen from the table<tt> ACT</tt>&nbsp;.<tt> </tt>
Thus:</p>

<pre>
      ⎕ps←-1 1 0 0
      i←((-7 5 3 2 1),⍳7)⍳0 ¯1↓ST
      c←11 7↑'aLFDMvmdf←lr'[i]
      c,⍕ACT[ST[;,4]]
a←ar   L S((>>R[0]) IS R[2]),3↓R
mfva   L S(1↑R),(R[1]RE R[,2]),3↓R
ffva   L S(1↑R),(R[1]RE R[,2]),3↓R
lfva   L S(1↑R),(R[1]RE R[,2]),3↓R
←fva   L S(1↑R),(R[1]RE R[,2]),3↓R
dvfv   L S(2↑R),(R[2]RE R[,3]),4↓R
Dvfv   L S(1↑R),(R[2]RE R[1 3]),4↓R
DMda   L S(1↑R),(R[2]RE R[1 3]),4↓R
DMma   L S(1↑R),(R[2]RE R[,1]),3↓R
lLaa   ⍎'R[1]',(2<⍴R)/'R not clear∘'
aaaa   (>''⍴Z)S(1↓Z←L LE 4=1↑,⍴⍤>⍴¨>R),R
</pre>

<p>The action and class codes produced by<tt> AC </tt>
are displayed if the trace
control is set to a negative value. For example:</p>

<pre>
      to←¯1
      APL
    a←3×4
l: |a| |←| |3| |×| |4|
r:
 acs|0| |6| |6| |6| |6|
l: |a| |←| |3| |×| 
r: ||4||
 acs|0| |0| |6| |6| |6|
l: |a| |←| |3|
r: |||⍝<<(>>⍺)×>>⍵|| ||⍝<<×>>⍵||| ||4||
 acs|0| |3| |0| |6| |6|
l: |a| |←|
r: ||3|| |||⍝<<(>>⍺)×>>⍵|| ||⍝<<×>>⍵||| ||4||
 acs|0| |0| |3| |0| |6|
l: |a|
r: |←| ||3|| |||⍝<<(>>⍺)×>>⍵|| ||⍝<<×>>⍵||| ||4||
 acs|4| |4| |0| |3| |0|
l: |a|
r: |←| ||12||
 acs|0| |4| |0| |6| |6|
l:
r: ||a|| |←| ||12||
 acs|1| |0| |4| |0| |6|
l:
r: ||12||
 acs|0| |0| |6| |6| |6|
l:
r: |⍝| ||12||
 acs|6| |5| |0| |6| |6|
    ⍝t0←0
    ⍝→
</pre>

<p>The proposed syntax is that embodied 
in the table<tt> ST</tt>&nbsp;,<tt> </tt>
the selection function<tt> AC</tt>&nbsp;,<tt> </tt>
and the list of actions<tt> ACT</tt>&nbsp;.<tt> </tt>
Experiments with different
syntax rules can be made by changes in any or all of these. 
Such changes can affect the number of elements<tt> R </tt>examined, 
or can even affect the classes and number of elements 
produced by the actions.
Thus, an action could produce 0 or 2 or 3 results 
rather than 1 as
proposed here, 
and the results could be operators as well as functions
and variables. 
The table<tt> ST </tt>may be compared 
with the syntax table of 
<acronym title=
"Third Working Draft of the International Standard for the Programming Language APL, International Standards Organization, ISO TC97/SC5/WG6-N28, 1982.">[5]</acronym>, 
which covers the obsolescent syntax, 
but not the syntax of operators.</p>

<p>As stated in the introduction, parentheses are handled by an
immediate recursive application of the model to 
the enclosed subexpression.
With this premise, the remaining detailed syntax rules can
be read directly from the display produced by the 
function<tt> syntax</tt>&nbsp;.<tt> </tt>
However, the new features that extend the syntax to
operators can be summarized as follows:</p>

<blockquote>Operators take precedence 
over functions and have long left scope; 
that is, an operator applies to the result produced by
the entire operator sequence to the left of it.
<br>&nbsp;</blockquote>



<a name="b"></a>
<p><b>B. Representation of Functions and Operators</b></p>

<p>The primary definition of a function concerns the specification of
what result it produces when applied to an individual array of the
lowest rank upon which it is properly defined. 
However, the complete
definition of a function also concerns certain <i>attributes</i> which
determine the effects of applying various operators to the function.
For example, the axis (or axes) of application is an attribute of a
function which determines how the function applies to a higher-rank
array, an attribute which is modified 
by an axis operator, as in<tt> ⌽[i]a</tt>&nbsp;;<tt> </tt> 
the identity element of a function is an attribute that
determines the result of the reduction operator in certain cases, 
as in<tt> +/⍳0 </tt>or<tt> ×/⍳0</tt>&nbsp;.</p>

<p>The representation of functions adopted in the present model
accommodates thirty attributes (of which 25 are actually used). 
The cases used are apparent from the following display 
of<tt> PF</tt>&nbsp;,<tt> </tt> 
the enclosed array (of shape<tt> 5&nbsp;2&nbsp;3</tt>)<tt> </tt> 
representing the <i>prototype function</i>:</p>

<pre>
      ⎕ps← -1 1 0 3
      >PF
|dbody|      |mbody|      |∘|
||7.237e75|| ||7.237e75|| ||7.237e75||

|loparg|     |roparg|     |∘|
|||⍺|||      |||⍵|||      |||⍵|||

||||         ||||         |∘|
|idf a¨∆|    |idf ∆¨a|    |idf ∆|

|dcase a¨∆|  |dcase ∆¨a|  |∘|
|a¨∆ ⍙|      |∆ ¨a⍙|      |∆⍙|

|variant0|   |variant1|   |∘|
|a¨∆*¯1|     |∆¨a*¯1|     |∆*¯1|
</pre>

<p>The significance of each of the positions 
in<tt> PF </tt>will be made clear
in the discussion of the corresponding attribute.</p>

<p>The first plane of<tt> >PF </tt>is the primary definition, 
that is, the bodies
of the dyadic and monadic cases, and the application axes. 
Bodies are represented in the direct definition form defined in 
<acronym title=
"K.E. Iverson and P.K. Wooster, A Function Definition Operator, APL Quote Quad, Vol. 12 Number 1, ACM 1981.">[6]</acronym>, 
with three modifications:</p>

<table>
<tr><td valign=top>1. &nbsp;</td><td>
A leading<tt> ⍝ </tt>
indicates that what follows is to be executed
in raw (i.e., conventional) APL rather than in the APL of
the model. Comments are normally allowed in any segment
of a direct definition, but because of the special use of the
symbol<tt> ⍝ </tt>they are excluded from use in the model.
 <br>&nbsp;</td></tr>

<tr><td valign=top>2. &nbsp;</td><td>
A label is assigned a vector value consisting of the indices
of all segments from the location of the label to the end of
the definition.
 <br>&nbsp;</td></tr>

<tr><td valign=top>3. &nbsp;</td><td>
A name is localized only if it is <i>immediately</i> adjacent to
an assignment arrow (and the mechanism for declaring
globals is therefore not used).
 </td></tr>
</table>

<p>The three axes accommodated are in the order left dyadic axis,
right dyadic axis, and right monadic axis. The specification of axes
is extended to include <i>negative indexing</i> 
(in which<tt> ¯1 </tt>denotes the
ultimate axis,<tt> ¯2 </tt>the penultimate, etc.) 
and <i>complementary</i> indexing,
in which a leading infinite value 
(denoted by the<nobr> constant<tt> ¯</tt>&nbsp;)</nobr><tt> </tt> 
designates all axes <i>except</i> those in the vector following it. 
Thus,<tt> <nobr>¯ 2 4 ¯1</nobr> </tt>
denotes all axes except 2,4, and the final axis, and<tt> ¯ </tt>
alone denotes all axes. 
It may be noted that the axes specified in the
prototype function are all of the latter type, 
making the standard, or
<i>default</i> axes of application unbounded.</p>

<p>The operator<tt> ⍫ </tt>(which will be discussed further in Section C),
applied in the form<tt> f⍫∘</tt>&nbsp;,<tt> </tt>
produces a function that selects any desired
section of the representation of a function<tt> f</tt>&nbsp;.</p>

<pre>
      APL
    d←+⍫∘
    d 0
||⍝<<(>>⍺)+>>⍵|| ||⍝<<+>>⍵|| |∘|
||||             ||||        ||||
    d 0 1
|||| |||| ||||
    +⍫∘ 0 0 0
||⍝<<(>>⍺)+>>⍵||
</pre>

<p>As seen in the foregoing, 
a single index selects a plane (the bodies and axes), 
two select a plane and a row, 
and three select a given element. 
Since a variable is represented by a double enclosure, 
the last display above shows that the dyadic definition 
of a function<tt> + </tt>is
the (raw) double enclosure of<tt> + </tt>
applied to the double disclosure of
the arguments.</p>

<p>A monadic operator must be defined for two cases, a valence 0
argument (variable) and a valence 3 argument (function); a dyadic
operator must be defined for four cases, two for each of its arguments.
A monadic operator is therefore represented by an enclosed two-element
vector, and a dyadic operator by an enclosed 2-by-2 matrix.
For example:</p>

<pre>
    ⍤
|⍝⍺CONST⍵|     ||
|⍝⍺AXIS⍵⋄⍵←⊃⍵| |⍝⍺COMP⍵|

    ⌿
|| |⍝RED⍵|

    ∇
|⍝⍺DEL⍵| |∘|
|∘|      |∘|
</pre>

<p>An example of the detailed definition of an operator may be seen
in the function<tt> DEL </tt> used in the direct definition 
operator<tt> ∇ </tt>above. Thus:</p>

<pre>
R←A DEL W
R←>PF
R[0;0; 0 1]←A,W
R[2;0; 0 1]←(<<LOC>>A),<<LOC,>>W
R←&lt;R
</pre>

<p>Briefly, the result of<tt> ∇ </tt>
is the prototype function with the bodies
replaced by the arguments of<tt> ∇</tt>&nbsp;,<tt> </tt>
and with the local names (in row 0 of plane 2) 
replaced by the names to be localized, as determined
by applying the function<tt> LOC </tt>to each 
of the arguments of<tt> ∇</tt>&nbsp;.<tt> </tt>
For example:</p>

<pre>
      APL
    f←b×b←a ←⍺+⍵'∇'c*c←d ←÷⍵'
    2 f 5
49
    a
7
    f 2
0.7071
    d
0.5
    f⍫∘0 0
||b×b←a ←⍺+⍵|| ||c*c←d ←÷⍵|| |∘|
    f⍫∘2 0
|||b||| |||c||| |∘|
    b
value error
LE[2]⍎ b
       ∧
</pre>

<p>The details of other operators may be examined in a similar
manner by displaying the supporting 
functions<tt> AXIS</tt>&nbsp;,<tt> COMP</tt>&nbsp;,<tt> </tt>etc. 
It may be noted that, although <i>some</i> of the definitions 
of operators must
resort to functions in raw APL, 
some of the definitions may also be
expressed in terms of operators defined only in the model. 
For example, the inverse operator <i>con</i> 
(denoted by<tt> ⊂</tt>)<tt> </tt>
is defined as follows:</p>

<pre>
      APL
    ⊂
|| |⍵⍫i⍫⍵⍫(⌽i←''⊃4 1 2)|

</pre>



<a name="c"></a>
<p><b>C. An Auxiliary Definition Operator</b></p>

<p>An auxiliary definition operator, 
denoted by<tt> ⍫ </tt>and used earlier in
the form<tt> f⍫∘i </tt>to display position<tt> i </tt>
of the representation of a function<tt> f</tt>&nbsp;,<tt> </tt>
is introduced for the purpose of modelling, and is not proposed
as an operator to be incorporated in the language in its present form.
Two further eases of it will be used in subsequent sections:</p>

<table>
<tr><td valign=top>a) &nbsp;</td><td>
If<tt> f </tt>and<tt> g </tt>are functions, then<tt> f⍫g </tt>
produces a function whose
representation (of shape<tt> 10&nbsp;2&nbsp;3</tt>)<tt> </tt> 
is the catenation of the
representations of<tt> f </tt>and<tt> g</tt>&nbsp;,<tt> </tt>
as shown by the function<tt> D11 </tt>that
produces it:

<pre>
    D11 ⋄ <(>⍺),[0]>⍵

</pre>
 </td></tr>

<tr><td valign=top>b) &nbsp;</td><td>
If<tt> i </tt>is a vector whose two elements 
are enclosed indices 
(full or abbreviated), and if<tt> h←f⍫g</tt>&nbsp;,<tt> </tt> 
then<tt> h⍫i </tt>is the function defined
by replacing the element (or sub-array) 
of the representation of<tt> f </tt>selected 
by the index<tt> >i[0]</tt>&nbsp;.<tt> </tt>
Thus<tt> f⍫g⍫(2⍴<0&nbsp;1) </tt>is the
function<tt> f </tt>with its axes replaced 
by the axes of<tt> g</tt>&nbsp;.<tt> </tt>
If<tt> h </tt>is a simple function 
(whose representation has shape<tt> 5&nbsp;2&nbsp;3</tt>),<tt> </tt> 
then<tt> h⍫i </tt>is
equivalent to<tt> h⍫h⍫i</tt>&nbsp;.
<br>&nbsp;</td></tr>
</table>



<a name="d"></a>
<p><b>D. Operator Arguments</b></p>

<p>Derived functions (resulting from the application of an operator)
are represented in the general form presented in Section B; thus, the
body and axes of<tt> ,⍤1&nbsp;2 </tt>
(ravel along axes 1 and 2) would appear
as in the last two lines of the following example:</p>

<pre>
    APL
    f←,⍤1 2
    q←2 3 4⍴⍳24
    f q
 0  1  2  3  4  5  6  7  8  9 10 11
12 13 14 15 16 17 18 19 20 21 22 23
    F⍫∘ 0
||⍺F⍵|| ||F⍵||  ||∘||
||1 2|| ||1 2|| ||1 2||
</pre>

<p>The definition of a derived function depends upon the arguments
of the operator which produced it, as well as upon the arguments to
which it is applied; the arguments of the operator are referred to in
the body by the 
names<tt> F </tt>and<tt> G</tt>&nbsp;,<tt> </tt>
and are stored in locations<tt> 1&nbsp;0&nbsp;0 </tt>
and<tt> 1&nbsp;0&nbsp;1</tt>&nbsp;,<tt> </tt>
that is, in the locations denoted by<tt> loparg </tt>
and<tt> roparg </tt>
in the prototype function<tt> PF</tt>&nbsp;.<tt> </tt>
In the function<tt> f</tt>&nbsp;,<tt> </tt>
the location<tt> 1&nbsp;0&nbsp;0 </tt>(that is,<tt> f⍫1&nbsp;0&nbsp;0</tt>) 
is the ravel function itself. Thus,</p>

<pre>
    17↑ f⍫ 1 0 0 q
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
</pre>

<p>The following example illustrates the important fact that the
arguments of an operator are bound at the time of its execution, and
that subsequent reassignments to the names to which it applied do
not affect the derived function produced:</p>

<pre>
    r←,
    g←r⍤ 1 2
    r←⍴
    g q
 0  1  2  3  4  5  6  7  8  9 10 11
12 13 14 15 16 17 18 19 20 21 22 23
    r⍤1 2 q
3 4
3 4
</pre>

<p>Because of the binding at execution time, the inverse function 
(in location<tt> 4&nbsp;1&nbsp;2</tt>&nbsp;,<tt> </tt>
and denoted by<tt> ∆*¯1 </tt>in<tt> PF</tt>)<tt> </tt>
must also appear explicitly
in the representation of a function and cannot, 
in general, consist of
a reference to the name of the inverse function. 
Since this inverse
function must likewise contain 
(in its location<tt> 4&nbsp;1&nbsp;2</tt>)<tt> </tt> 
an explicit inverse function, the scheme seems to imply 
an infinite regression of
explicit functions. However, because the inverse of the inverse is the
original function, this implied difficulty can be handled in the simple
manner shown in the following definition of an inverse operator:</p>

<pre>
    ⊂
|| |⍵⍫i⍫⍵⍫(⌽i←(<''),<4 1 2)|
</pre>

<p>The definition may be read as follows:<tt> ⍵⍫i </tt>
produces a function in
which the whole of the argument function<tt> ⍵ </tt>
(as selected by the empty
first element of<tt> i</tt>)<tt> </tt>
is replaced by element<tt> 4&nbsp;1&nbsp;2 </tt>
of the same function,
thus yielding the function inverse 
to<tt> ⍵</tt>&nbsp;.<tt> </tt> 
The further expression<tt> ⍵⍫i⍫⍵ </tt>
therefore &ldquo;catenates&rdquo;
the inverse of<tt> ⍵ </tt>with<tt> ⍵ </tt>itself, 
and the
final application of<tt> ⌽i </tt>
therefore inserts in location<tt> 4&nbsp;1&nbsp;2 </tt>of the
inverse function<tt> ⍵</tt>&nbsp;,<tt> </tt>
the original function. For example:</p>

<pre>
    l←* ⊂
    p←l ⊂
    l 3
1.099
    p⍫∘ 0 0 1
||⍝<<*>>⍵||
</pre>

<p>The analogous problem of explicitly representing successive
derivatives of a function does not yield to the method applied for
inverses, but can be handled by using the derivative 
location<tt> </tt>(<tt>3&nbsp;1&nbsp;2</tt>)<tt> </tt>
to represent a <i>dyadic</i> function whose left argument<tt> k </tt>
determines the order of the index; 
the index<tt> k </tt>will appear as the right operator
argument (in location<tt> 1&nbsp;0&nbsp;1</tt>&nbsp;,<tt> </tt>
and referred to by<tt> G</tt>)<tt> </tt>and will be
incremented on successive applications of the derivative operator.
<br>&nbsp;</p>



<a name="e"></a>
<p><b>E. Some New Functions</b></p>

<p>The convenience of the function representation employed will be
illustrated by showing the formal definitions of some new functions:</p>

<table>
<tr><td><tt>&nbsp; &nbsp; ⊢⍫∘0 &nbsp; &nbsp;</tt></td>
 <td>Dex<tt> </tt>(<tt>⊢</tt>)<tt> </tt>- monadic is the identity function.</td></tr>
<tr><td colspan=2><pre>
||⍵||        ||⍵||        |∘|
||7.237e75|| ||7.237e75|| ||7.237e75||</pre></td></tr>
<tr><td>&nbsp;</td></tr>
<tr><td><tt>&nbsp; &nbsp; ⊣⍫∘0</tt></td>
 <td>Lev<tt> </tt>(<tt>⊣</tt>)<tt> </tt>- monadic has no explicit result.</td></tr>
<tr><td colspan=2><pre>
||⍺||        ||||         |∘|
||7.237e75|| ||7.237e75|| ||7.237e75||</pre></td></tr>
</table>

<pre>
    z←'abc'
    z
abc
    z←⊣'abc'
syntax error
IS[1]⍎ no result∘
                ∧
</pre>

<p>In the case of more complex functions, the axes of application may
be seen even though the detailed definition of the body is subordinated
in raw APL functions:</p>

<pre>
      APL
    {⍫∘0
||⍝<<(>>⍺)FR2>>⍵|| ||⍝<<FR1>>⍵|| |∘|
||¯1||             ||7.237e75||  ||¯1||
</pre>

<p>In what follows we will use<tt> ⊃ </tt>
to denote a form of the <i>link</i> function
that encloses its left argument and catenates it to the right, 
first enclosing the right argument if it is simple.</p>

<p>The foregoing function (called <i>from</i>) 
is defined briefly as follows:<tt> i{a </tt>
is equivalent to inserting<tt> >i[j] </tt>
before the<tt> j</tt>th semicolon of an
expression of the form<tt> a[;;;&#133;]</tt>&nbsp;.<tt> </tt>
For example:</p>

<pre>
    m←4 4⍴⍳16
    (2 1⊃3){m
11 7
    (<2 1){m
 8  9 10 11
 4  5  6  7
    i←3 2⍴1 0 2 1 3 0
    i
1 0
2 1
3 0
    i{m
4 9 12
</pre>

<p>The final case of a simple array to provide 
&ldquo;scattered&rdquo; indexing
results from the definition of the left axis of application.</p>

<p>The monadic case of<tt> { is </tt>the cartesian product. 
For example:</p>

<pre>
    { 2 1⊃4⊃6 7
2 4 6
2 4 7

1 4 6
1 4 7
</pre>

<p>The relation between the monadic and dyadic cases 
of the function<tt> { </tt>
may be seen in the definition of the function<tt> FR2</tt>&nbsp;.
<br>&nbsp;</p>



<a name="f"></a>
<p><b>F. Some New Operators</b></p>

<p>We will discuss only two operators, the first 
(to be denoted by<tt> }</tt>&nbsp;)<tt> </tt>
because it is both powerful and relatively unknown, and the second
(denoted by<tt> ¨</tt>)<tt> </tt>because it motivates 
a number of attributes provided
for in the representation of functions.</p>

<p>The first operator was introduced in 
<acronym title=
"K.E. Iverson and A.T. Whitney, Practical Uses of a Model of APL, APL Quote Quad, Volume 13, Number 1, ACM September 1982.">[7]</acronym> 
under the name <i>til</i>. 
It is defined as follows:</p>

<pre>
    }
|∘| |∘|
|∘| |'(G⍵)F⍺'∇'⍵∆⍵'⍫⍺⍫(1 0 0⊃⍳0)⍫⍵⍫(1 0 1⊃⍳0)|
</pre>

<p>The main function is seen in the 
expression<tt> '(G⍵)F⍺'∇'⍵∆⍵'</tt>&nbsp;;<tt> </tt>
the rest simply inserts the function 
arguments<tt> ⍺ </tt>and<tt> ⍵ </tt>in the
&ldquo;operator argument&rdquo; 
locations<tt> <nobr>1 0 0</nobr> </tt>
and<tt> <nobr>1 0 1</nobr></tt>&nbsp;.</p>

<p>The utility of <i>til</i> is discussed in 
<acronym title=
"K.E. Iverson and A.T. Whitney, Practical Uses of a Model of APL, APL Quote Quad, Volume 13, Number 1, ACM September 1982.">[7]</acronym>; 
the main point is 
that<tt> <nobr>⍺ f}g}h ⍵</nobr> ←→ <nobr>(g⍺) f (h⍵)</nobr></tt>&nbsp;.</p>

<p>As defined in
<acronym title=
"R. Bernecky and K.E. Iverson, Operators and Enclosed Arrays, APL Users Meeting, I.P. Sharp Associates, October, 1980.">[1]</acronym>, 
the operator<tt> ¨ </tt>applied to one function and one
array produces a monadic function resulting from providing the array
as one argument to the dyadic function. 
For example,<tt> 10¨⍟ </tt>is the
base 10 logarithm function, and<tt> *¨.5 </tt>
is the square root function. 
As remarked in 
<acronym title=
"K.E. Iverson and A.T. Whitney, Practical Uses of a Model of APL, APL Quote Quad, Volume 13, Number 1, ACM September 1982.">[7]</acronym>, 
two interesting points arise:</p>

<table>
<tr><td valign=top>1. &nbsp;</td><td>
Each of the monadic functions<tt> a¨f </tt>and<tt> f¨a </tt>
may themselves
possess inverses and derivatives; 
provision is made for these
attributes in the locations 
labelled<tt> a¨∆*¯1</tt>&nbsp;,<tt> ∆¨a*¯1</tt>&nbsp;,<tt> a¨∆</tt>&nbsp;,<tt> </tt>
and<tt> ∆¨a </tt>in the prototype function<tt> PF</tt>&nbsp;.
 <br>&nbsp;</td></tr>
<tr><td valign=top>2. &nbsp;</td><td>
Because a derived function is ambivalent, provision is made (in
locations<tt> 3&nbsp;0&nbsp;0 </tt>and<tt> 3&nbsp;0&nbsp;1 </tt>
of the representation of a function<tt> f</tt>)<tt> </tt>
for representing the dyadic cases of the 
functions<tt> a¨f </tt>and<tt> f¨a</tt>&nbsp;.<tt> </tt>
The dyadic case of the selection function<tt> i¨{ </tt>
is particularly
important, being defined as follows:<br>

<blockquote>The result of<tt> b i¨{a </tt>
is the array<tt> a </tt>with<tt> b </tt>merged into the
portion selected by<tt> i</tt>&nbsp;.<tt> </tt>
This function obviates indexed assignment. 
In order to obtain the effect of indexed
assignment of<tt> a</tt>&nbsp;,<tt> </tt>
one would write<tt> a←b i¨{a</tt>&nbsp;.<tt> </tt>
Other dyadic
selection functions may be treated analogously.</blockquote>
 </td></tr>
</table>



<a name="g"></a>
<p><b>G. Indirect Addressing</b></p>

<p>In the normal execution of an APL expression, 
each of the vector of tokens of the expression 
(placed in the left stack<tt> L </tt>in the model)
is &ldquo;evaluated&rdquo; 
and the result of the evaluation is transferred to the
stack of intermediate results<tt> </tt>(<tt>R </tt>in the model). 
However, a token which immediately precedes an assignment arrow 
must be exempted from this rule, 
and must be transferred &ldquo;without evaluation&ldquo;. 
For example:</p>

<pre>
    a←'abc'
    ⌽a
cba
    a←5
    a
5
    abc
value error
</pre>

<p>Parentheses, however, 
imply that the enclosed expression is to be evaluated, 
and the result transferred to the stack of intermediate results. 
In an expression such as<tt> (a)←5 </tt>this rule conflicts with the
stated rule for assignment and, in conventional APL, such an
expression is treated as a syntax error.</p>

<p>The conflict can be resolved by prescribing an order for the
application of the two rules. In the present model, the rule for
parentheses is applied first, with the obvious and convenient
consequences illustrated by the following sequence:</p>

<pre>
      APL
    a←'abc'
    (a)←5
    a
abc
    abc
5
</pre>

<p>Since the result of evaluating an APL expression may be an array
of enclosed names, the notion can be extended as shown by the
following example:</p>

<pre>
    n←<⍤>'abcd'
    n
|a| |b| |c| |d|
    m←4 3⍴⍳12
    (n)←m
    a
0 1 2
    d
9 10 11
    ⍝→
</pre>

<p>The detailed definition of this <i>indirect assignment</i>
may be seen in the function<tt> IS</tt>&nbsp;:</p>

<pre>
W←A IS W;X;N1;B1
⍎(NORE≡W)/'no result∘'
→(1∊A∊<⍤>A)/L0
→0,0⍴A IS1 W
L0:A←(,A),[0.5],(>>W) NUC1(⍴⍴A)↓⍳⍴⍴>>W
L1:→(0=1↑⍴A)/0
X←A[0;]
A← 1 0 ↓A
→(1∊N1∊<⍤>N1←>X[0])/L2
→L1,0⍴N1 IS1 X[1]
L2:→L1,0⍴N1 IS X[1]
</pre>

<p>The auxiliary function<tt> IS1 </tt>is simple assignment, 
except for the fact
that it handles assignments to graphic symbols as well as to names
that are legitimate in raw APL. 
The function<tt> NUC1 </tt>encloses the
&ldquo;nuclei&rdquo; determined by the axes specified 
by its right argument.</p>

<p>Some interesting consequences of the definition of<tt> IS </tt>
are illustrated
by the following sequence in which<tt> j </tt>
is assumed to be predefined (as shown):</p>

<pre>
      APL
    b←<4 5 6
    b
|4 5 6|
    (<'c')←b
    c
4 5 6
    ⍝⎕ps←-2/1 3
    j
|¯¯¯¯¯¯¯¯¯| |¯¯¯|
||¯¯¯| |¯|| |bcd|
||abc| |b|| |___|
||___| |_||
|         |
||¯|   |¯||
||c|   |d||
||_|   |_||
|_________|

    (j)←j
    abc
abc
    d
d
</pre>

<p>Since expressions of the form used for indirect addressing proposed
here are invalid in conventional APL, their introduction would
produce no conflict. 
Their use would, however, conflict with a
different proposed use of parentheses to the left of assignment to
extend the use of indexed assignment to selection functions other than
&ldquo;bracket&rdquo; indexing
<acronym title=
"APL Language Manual, Form number SB21-3015, IBM Corporation, 1982.">[3]</acronym>. 
It should be noted that the dyadic &ldquo;merge&rdquo;
function<tt> i¨{ </tt>discussed in Section F 
illustrates a general scheme for
using the operator<tt> ¨ </tt>together 
with any selection function to provide
the effect of indexed assignment. 
It should also be noted that the
explicit result of the 
expression<tt> <nobr>b i¨} a</nobr> </tt>is the entire merged entity,
whereas the explicit result of<tt> a[i]←b </tt>
(or of corresponding extensions
to other functions) is simply<tt> b</tt>&nbsp;.
<br>&nbsp;</p>



<a name="h"></a>
<p><b>H. Index Origin</b></p>

<p>A number of people (among whom Professor Penfield is perhaps
the most persuasive) have long maintained that any benefits provided
by the choice of index origin in APL are outweighed by the burden
of controlling its effects. 
It is, of course, futile to propose that the
present use of index origin be changed in any way; 
however, in the
design of any new functions and operators 
one may choose to exclude
dependence upon index origin, 
just as the choice was made in the design of APL\360 
<acronym title=
"A.D. Falkoff and K.E. Iverson, APL\360, IBM Corp., November 1966.">[8]</acronym> 
to exclude dependence on index origin in the
definition of the residue function, 
even though the earlier definition in 
<acronym title=
"K.E. Iverson, A Programming Language, Wiley, 1962.">[9]</acronym> 
included it.</p>

<p>Problems due to index origin appear to be magnified in the case
of operators. For example, in<tt> g←f⍤i</tt>&nbsp;,<tt> </tt>
are the axes used in the
application of<tt> g </tt>
to depend upon the origin in effect at the time of
specifying<tt> g </tt>or at the time 
of applying<tt> g</tt>&nbsp;?<tt> </tt> 
Or should it perhaps depend upon the index origins 
localized within the definitions of<tt> f </tt>
and<tt> g </tt>as well?</p>

<p>In any case, the present proposal is 
to adopt a fixed index origin
for all new functions and operators 
and to make this origin <i>zero</i>.
<br>&nbsp;</p>



<a name="i"></a>
<p><b>I. Idiosyncracies of the Model</b></p>

<p>For practical reasons the model has not been made as general as
it could be, and any person using or modifying it should perhaps be
aware of some of the limitations and peculiarities, and some of the
reasons for them. Thus:</p>

<table>
<tr><td valign=top>1. &nbsp;</td><td>
Except for the name<tt> APL</tt>&nbsp;,<tt> </tt>
the names used within the model all
incorporate underscored letters [<i>ed. note</i>: uppercase letters in this text] 
or digits; the names that a user may
safely employ should be formed from the simple alphabet only.
 <br>&nbsp;</td></tr>

<tr><td valign=top>2. &nbsp;</td><td>
<p>Some of the definitions of functions and operators are couched
in expressions in raw APL, some in the extended APL provided
by the model, and some in a mixture of the two. The choice of
one or the other is rather arbitrary, except for the application of
the following criteria:</p>

<table><tr><td nowrap>&nbsp; &nbsp;</td><td>
<p>a) Some of the underlying functions <i>had</i> to be expressed in raw
APL in order to obtain a working model.</p>

<p>b) Illustrations of both uses were included as guides for anyone
attempting to add further definitions.</p>

<p>c) Use of raw APL leads to more efficient execution of the
model.</p>

<p>d) Use of the extended functions was very helpful in exercising
the model and ensuring its correct behaviour.</p>
</td></tr></table>
  <br></td></tr>

<tr><td valign=top>3. &nbsp;</td><td>
The main criteria applied in the design of the model were
clarity and flexibility; increased efficiency can, if required, be
attained by rewriting a number of the auxiliary functions.
 <br>&nbsp;</td></tr>

<tr><td valign=top>4. &nbsp;</td><td>
The definitions of the primitive functions provided in the model
are incomplete in the sense that many of the meaningful attributes
are left unspecified. However, the discussion and the examples
(such as the inverse specified for the function<tt> *</tt>)<tt> </tt>
should provide sufficient guidance for completing 
the definitions as desired. 
 <br>&nbsp;</td></tr>

<tr><td valign=top>5. &nbsp;</td><td>
<p>The prototype function<tt> PF </tt>shown in Section B 
shows some attributes which have not been discussed. 
They should be considered as tentative.</p>

<p>For example, positions<tt> 1&nbsp;0 </tt>show the argument names used, and
an operator for changing them would allow a choice of the
argument names to be used in the direct definitions. Similarly,
positions<tt> 2&nbsp;0&nbsp;0 </tt>and<tt> 2&nbsp;0&nbsp;1 </tt>
may be used to directly specify the
names local to the dyadic and monadic cases.</p>

<p>Positions<tt> 2&nbsp;1 </tt>provide 
for the specification of identity functions (as
a generalization of identity elements) for the monadic function
itself<tt> </tt>(<tt>∆</tt>)<tt> </tt>
and for each of the derived monadic eases<tt> a¨∆ </tt>
and<tt> ∆¨a</tt>&nbsp;.<tt> </tt>
Positions<tt> 4&nbsp;0&nbsp;0 </tt>and<tt> 4&nbsp;0&nbsp;1 </tt>
provide for possible inclusion of
<i>variants</i> of the type discussed in
<acronym title=
"K.E. Iverson, Operators and Functions, Research Report RC 7091, Research Division, IBM Corp., 1978.">[10]</acronym>.</p>

<p>In specifying the inverse of any function it should be remembered
that the specification is <i>formal</i> in the sense that it merely
determines the function that results from the application of the
inverse operator; the function may in fact be only a partial inverse
(as in<tt> ¯1○⍵ </tt>and<tt> 1○⍵</tt>)<tt> </tt>
or it could even be a function that is not inverse at all. 
Similar remarks apply to derivatives.
 <br>&nbsp;</p></td></tr>
</table>



<a name="ack"></a>
<p><b>Acknowledgements</b></p>

<p>I am indebted to a number of my colleagues 
at I.P. Sharp Associates, 
particularly to Arthur Whitney 
for material adapted from his earlier model, 
and to Roland Pesch for comments arising 
from his use of the model.
<br>&nbsp;</p>


<a name="ref"></a>
<p><b>References</b></p>

<table>
<tr><td valign=top>1.</td><td>
R. Bernecky and K.E. Iverson, 
<a target=_parent href="http://www.jsoftware.com/papers/opea.htm"><i>Operators and Enclosed Arrays</i></a>, 
APL Users Meeting, I.P. Sharp Associates, October, 1980.
 </td></tr>
<tr><td valign=top>2.</td><td>
Carl Cheney, <i>APL*PLUS Nested Arrays Reference Manual</i>,
STSC Corporation, 1981.
 </td></tr>
<tr><td valign=top>3.</td><td>
<i>APL Language Manual</i>, 
Form number SB21-3015, IBM Corporation, 1982.
 </td></tr>
<tr><td valign=top>4.</td><td>
P.K. Wooster, &ldquo;Improved Display for Enclosed Arrays and a
New System Variable<tt> ⎕ps</tt>&rdquo;, 
Technical Supplement 37, 
<i>I.P. Sharp Newsletter</i>, Vol. 10, Number 2, 1982.
 </td></tr>
<tr><td valign=top>5.</td><td>
Third Working Draft of the International Standard for the
Programming Language APL, 
International Standards Organization, 
ISO TC97/SC5/WG6-N28, 1982.
 </td></tr>
<tr><td valign=top>6.</td><td>
K.E. Iverson and P.K. Wooster, 
<i>A Function Definition Operator</i>, 
APL Quote Quad, Vol. 12 Number 1, ACM 1981.
 </td></tr>
<tr><td valign=top>7.</td><td>
K.E. Iverson and A.T. Whitney, 
<a target=_parent href="http://www.jsoftware.com/papers/APLModel.htm"><i>Practical Uses of a Model of APL</i></a>, 
APL Quote Quad, Volume 13, Number 1, ACM
September 1982.
 </td></tr>
<tr><td valign=top>8.</td><td>
A.D. Falkoff and K.E. Iverson, 
<a target=_parent href="http://keiapl.org/archive/APL360_UsersMan_Aug1968.pdf"><i>APL\360</i></a>, 
IBM Corp., November 1966.
 </td></tr>
<tr><td valign=top>9.</td><td>
K.E. Iverson,
<a target=_parent href="http://www.jsoftware.com/papers/APL.htm"><i>A Programming Language</i></a>, 
Wiley, 1962.
 </td></tr>
<tr><td valign=top nowrap>10. &nbsp;</td><td>
K.E. Iverson,
<a target=_parent href="http://www.jsoftware.com/papers/opfns.htm"><i>Operators and Functions</i></a>, 
Research Report RC 7091, Research Division, IBM Corp., 1978.
 </td></tr>
</table>
<br>



<a name="ax"></a>
<p><b>Appendix</b></p>

<p>See the body of the paper for 
functions<tt> APL</tt>&nbsp;,<tt> S</tt>&nbsp;,<tt> DEL</tt>&nbsp;,<tt> D11</tt>&nbsp;,<tt> </tt>
and<tt> IS</tt>&nbsp;,<tt> </tt>
for variables<tt> ST</tt>&nbsp;,<tt> ACT</tt>&nbsp;,<tt> </tt>
and<tt> PF</tt>&nbsp;,<tt> </tt>
for operators<tt> ⍤</tt>&nbsp;,<tt> +</tt>&nbsp;,<tt> </tt>
and<tt> ∇</tt>&nbsp;,<tt> </tt>
and for descriptions of variables<tt> P </tt>and<tt> t0</tt>&nbsp;.</p>

<a name="axv"></a>
<p><b>&#149; Variables</b></p>

<pre>
      M
Z1←DE DEX Q;SC;SG;FS;J;Z;AR;⎕trap
⎕trap←'∇ 8 c →L0',0⍴Z←>DE[2]
⍎(>>''⍴⌽AR←>DE[1]),'←''''⍴⌽Q',(⍴Z) SLB Z
⍎(1≠⍴Q)/(>>''⍴AR),'←''''⍴Q'
SC←¯1⌽⍳⍴SG←>''⍴DE
L0:→(0=SC)/L4
SC←1↓SC,0⍴FS←>SG[''⍴SC]
→(∧/' '=FS)/L0
→('⍝'=1↑FS←(J←'→'=1↑FS)↓FS)/L1
→J↓L2,L3,0⍴Z←(TK FS) S ''
L1:→J↓L2,L3,0⍴Z←⍎1↓FS
L2:→L0,0⍴Z1←Z
L3:→L0,SC←,>>Z
L4:⎕trap←'∇ 6 C →0,0⍴Z1←NORE'
Z1←Z1

      CN
abcdefghijklmnopqrstuvwxyzABCDEFG
HIJKLMNOPQRSTUVWXYZ0123456789⎕¯.a
</pre>

<a name="axf"></a>
<p><b>&#149; Functions</b></p>

<pre>
AC⋄(1↑(∧/0>Z)≠(|Z)=(⍴Z←0 ¯1↓ST)⍴X)⌿ST[;4]),X←4↑(,⍴⍤>⍴¨⍵),4⍴6

z←f AXIS i;j
z←>''⍴PF,0⍴j←(<<'⍺F⍵'),(<<'F⍵'),(<<'∘')
z[0;;]← 2 3 ⍴j,<¨>3⍴>>i
z[1;0;0]←f
z←&lt;z

CF⋄0≠⍴⍵,0⍴⎕ps←1⋄''⋄(⍎(⍺/'<,⍕'),',>1↑W'),(~⍺)CF 1↓⍵

CO⋄(1↑L)CF(L←'∧/⎕vi ⍵'ONA⍵)ENC⍵←⍵

z←a COMP b;q;j
q←>''⍴b,0⍴z←>PF
q[0;1;]←3⍴<⌊/0⍴j←(<<'(G⍺)F G⍵'),(<<'F G⍵')
z[1;0; 0 1]←a,<q
z[0;;]← 2 3 ⍴j,(<<'∘'),(>b)[0;1;]
z←&lt;z

<font color=red>more stuff here</font>

TA⋄'(2×~(IQ ⍵)∨⍵∊CN)ENC ⍵'ONA(IQ⍵)ENC⍵

r←a TR r;k;l;z
→(0=k←|l←>>t0)/0
z←(¯2↑1,⍴z)⍴z←⍕(t←, 0 1 ↓m←(s∊⍴¨>PF)⌽(<1,
  2⌊k),2),[0.5] s←⍴¨>r)↑¨>r
((0>l)∨' '≠1↑a)/((k,⍴,a)⍴a),((k←k⌊1↑⍴z),¯1↑⍴z)↑z

z←a UPON b;q
z←>PF
q←(b←>b)[0;1;]
b[0;1;]←3⍴&lt;&lt;⌊/⍳0
z[1;0; 0 1]←a,&lt;b
z[0;;]← 2 3 ⍴(&lt;'F⍺G⍵'),(&lt;'F G⍵'),(&lt;&lt;'∘'),q
z←&lt;z
</pre>

<a name="axo"></a>
<p><b>&#149; Operators</b></p>

<pre>
      ⍫
||       |⍝⍺D01⍵|
|⍝⍺D10⍵| |⍝⍺D11⍵|

      ⍥
|∘| |∘|
|∘| |⍝⍺UPON⍵|
</pre>



<br><hr>
<font size=-1>
<p>Originally appeared in the APL83 Conference Proceedings, 
APL Quote Quad, Volume 13, Number 3, 1983-03.</p>

<p><script src="apldisplay.js" type="text/javascript"></script></p>
</font>

<table>
<tr><td><font size="-1">created: &nbsp;</font></td><td><font size="-1">2010-01-22 09:30</font></td></tr>
<tr><td><font size="-1">updated:</font></td><td><font size="-1">2013-09-30 07:30</font></td></tr>
</table>

</td></tr></table>
<br><br><br>

</body>
</html>
