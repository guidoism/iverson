<html>
<head><meta http-equiv="content-type" content="text/html;charset=utf-8">
<title>The APL\360 Terminal System</title>
<link href="adoc.css" rel=stylesheet>
</head>

<body>

<br>

<table width=520 align=center><tr><td>

<p align=center><font size=+2>The APL\360 Terminal System</font><br><br>
<b>A.D. Falkoff<br>
K.E. Iverson<br><br>

IBM Watson Research Center<br>
Yorktown Heights, New York</b>
<br>&nbsp;</p>

<a name="abs"></a>
<p><b>ABSTRACT</b>:
This paper discusses the salient features of the system,
and its relation to mathematics, 
primarily from the point of view
of a scientifically oriented user.
<br>&nbsp;</p>

<img src="img/APL360cover.jpg" width=510 height=383>

<blockquote><font size=-1>
The cover is designed from an example
of an interaction between computers
and the physical and mathematical sciences.
The design depicts ion trajectories
in a type of mass spectrometer used
for chemical analysis of residual gases
in ultrahigh vacuum system.
These ion trajectories represent
solutions of Mathieu&rsquo;s differential equation.
They are generated by numerical integration
of the equation using a high speed computer,
and are plotted automatically
from an output tape as part 
of the Research Center computing service.
</font></blockquote>

<br><hr>



<a name="intro"></a>
<p><b>INTRODUCTION</b></p>

<p>APL\360 is an experimental interactive system,
programmed for IBM System/360 computers,
which uses typewriter terminals connected
to the central machine by telephone lines
for both input and output.
The basis of the system is APL 
[<acronym title="K.E. Iverson, A Programming Language. 
Wiley, New York, 1962.">1</acronym>,
<acronym title="A.D. Falkoff, K.E. Iverson, and E.H. Sussenguth, 
“A Formal Description of System/360”,
IBM Systems Journal, Vol. 3, No. 3, 1964. ">2</acronym>,
<acronym title="K.E. Iverson, Elementary Functions. 
SRA, Chicago, 1966.">3</acronym>,
<acronym title="A.D. Falkoff and K.E. Iverson, 
“The APL Terminal System: Instructions for Operation”. 
IBM Research, Yorktown Heights, N.Y., 1966.">4</acronym>],
a truly machine-free<a href="APL360TerminalSystem1.htm#note1">*</a> 
programming language which leans heavily
on mathematical notions, 
but does not slavishly follow
classical mathematical notation.
Correspondingly, the running system,
which is completely interpretive,
makes no significant concessions
to implementation problems.</p>

<p>This paper will discuss the salient features
of the system,
and its relation to mathematics,
primarily from the point of view 
of a scientifically oriented user.
The structure of the implementation 
is described in a companion paper. 
<acronym title="L.M. Breed and R.H. Lathwell, 
“The Implementation of APL\360”. (To be published.)">[5]</acronym></p>

<a name="note1"></a>
<blockquote><font size=-1>* That is,
the primitive operations in APL are defined
without reference to the representation
of the arguments.</font>
<br>&nbsp;</blockquote>



<a name="lang"></a>
<p><b>LANGUAGE CHARACTERISTICS</b></p>

<p>The primitive objects of APL are symbols and (real) numbers,
and functions defined on these domains.
Functions are either monadic or dyadic,
and in accordance with usual practice,
the former have their single argument
to the right, while the latter
have an argument on each side.
The syntactic limitation to a maximum
of two arguments &mdash;
which arises in an obvious way 
with a linear notation &mdash;
is not a significant restriction,
since any argument may, in fact, be an array.</p>

<p>Complete definitions of primitive APL functions
are given in the APL\360 manual
<acronym title="A.D. Falkoff and K.E. Iverson, 
“The APL Terminal System: Instructions for Operation”. 
IBM Research, Yorktown Heights, N.Y., 1966.">[4]</acronym>.
However, <a href="APL360TerminalSystem1.htm#tab1">Tables 1</a> and <a href="APL360TerminalSystem1.htm#tab2">2</a>
(which lists the functions implemented
as of the date of this paper,
together with a descriptive phrase for each)
provide a basis for a number of observations
on the characteristics of the language.
<br>&nbsp;</p>



<a name="scalar"></a>
<p><b>Scalar Functions</b></p>

<p>Most of the symbols do double duty,
as both monadic and dyadic functions &mdash;
a versatility usually found only in the minus sign.
The rule for deciding the valence 
of a function symbol is simple:
A function is dyadic if it is immediately 
preceded by a constant or a variable
(or a parenthesized expression).
Thus, there is no confusion
between<tt> a+÷b </tt>and<tt> a÷b </tt>
(assuming that<tt> a </tt>
and<tt> b </tt>are variables);
or between<tt> 7+4⌊3.14 </tt>
and<tt> 7+⌊3.14</tt>&nbsp;,<tt> </tt>
which evaluate, respectively,
to<tt> 10.14 </tt>and<tt> 10</tt>&nbsp;.</p>

<p>The last example raises a question
regarding the sequence in which operations
in a compound statement are to be executed,
since<tt> 7+4⌊3.14 </tt>might have been evaluated
(taking the sum first) 
as<tt> 3.14</tt>&nbsp;.<tt> </tt>
The rule here is again a simple one:
There is no hierarchy among functions,
and every function takes as its right-hand argument
the entire expression to its right.
Parentheses are used to delimit expressions,
and therefore indicate, in the usual way,
departures from the order of execution
otherwise determined by the structure
of a compound statement.</p>

<p>For a sequence of monadic functions
such as<tt> h&nbsp;g&nbsp;f&nbsp;x</tt>&nbsp;,<tt> </tt>
this rule gives the usual interpretation:<tt> f&nbsp;x </tt>
is evaluated 
first,<tt> g </tt>takes that result as its argument
and<tt> h </tt>operates 
on the result of<tt> g</tt>&nbsp;.<tt> </tt>
That is, the execution sequence
is from right to left
although the expression is usually
spoken from left to right.
Thus, &ldquo;the reciprocal of the absolute value
of the floor of minus<tt> 3.14</tt>&rdquo;<tt> </tt>
is written as<tt> ÷|⌊-3.14</tt>&nbsp;,<tt> </tt>
and evaluates to<tt> 0.25</tt>&nbsp;.</p>

<p>The right-to-left order of execution
allows certain important functions involving
non-associative operators to be written 
more simply than other rules would allow.
For example,<tt> a-b-c-d-e </tt>is the alternating 
sum<tt> </tt>(<tt>a+c+e </tt>less<tt> b+d</tt>),<tt> </tt>
and<tt> a÷b÷c÷d÷e </tt>is the alternating 
product<tt> </tt>(<tt>a×c×e </tt>divided by<tt> b×d</tt>).<tt> </tt>
Also, the simple succession of exponentiations,<tt> a*b*c </tt>
means<tt> a </tt>raised to the<tt> b*c </tt>power.
(The other possibility,<tt> a*b </tt>raised
to the<tt> c </tt>power, 
is equivalent to<tt> a </tt>raised 
to the<tt> b×c </tt>power,
and may be written as<tt> a*b×c</tt>).<tt> </tt>
The factored form for a polynomial 
in<tt> z</tt>&nbsp;,<tt> </tt>
with coefficients<tt> a</tt>&nbsp;,<tt> b</tt>&nbsp;,<tt> c</tt>&nbsp;,<tt> </tt>
and<tt> d</tt>&nbsp;,<tt> </tt>
is written without parentheses,
as<tt> a+z×b+z×c+z×d</tt>&nbsp;;<tt> </tt>
and a continued fraction can be written
on one line, also without parentheses,
as<tt> a+÷b+÷c+÷d</tt>&nbsp;.
<br>&nbsp;</p>



<a name="numbers"></a>
<p><b>Numbers and Arrays</b></p>

<p>Numbers are written in decimal notation,
with two further conventions.
Constants involving a power of<tt> 10 </tt>
can be written using 
the<tt> </tt>&ldquo;<tt>e </tt>notation&ldquo;,
and a negative number is named
by a high horizontal bar,
as in<tt> ¯2</tt>&nbsp;.<tt> </tt>
Examples of both conventions
are<tt> 3e5</tt>&nbsp;,<tt> ¯2e3</tt>&nbsp;,<tt> 5.72e¯4</tt>&nbsp;,<tt> </tt>
and<tt> ¯1.4e¯3</tt>&nbsp;,<tt> </tt>
which could also be written
as<tt> 300000</tt>&nbsp;,<tt> ¯2000</tt>&nbsp;,<tt> 0.000572</tt>&nbsp;,<tt> </tt> 
and<tt> ¯0.0014</tt>&nbsp;.<tt> </tt>
Numbers so represented are distinguished
from expressions such 
as<tt> 3×10*5</tt>&nbsp;,<tt> ¯2×10*3</tt>&nbsp;,<tt> 5.72×10*¯4</tt>&nbsp;,<tt> </tt>
and<tt> ¯1.4×10*¯3</tt>&nbsp;,<tt> </tt>
which evaluate to the same results.</p>

<p>The distinction between constants and expressions
is carried over to arrays,
and a constant vector is written as a sequence
of numerical constants,
with no punctuation other than spaces between them,
as<tt> 3e5&nbsp;¯2&nbsp;4.1&nbsp;¯1.4e¯3</tt>&nbsp;.<tt> </tt>
The same vector could be formed 
by the process of catenation, 
using the operator<tt> </tt>&ldquo;<tt>,</tt>&rdquo;,<tt> </tt>
which would, in fact, be required
if any element of the vector were itself
not a constant.</p>

<p>A vector has a &ldquo;rank&rdquo; of one,
the term being used, 
as in tensor analysis,
to mean the number of indices required
to identify a single element in an array.
Hence, a scalar has rank zero
and a matrix has rank two.
This is shown in <a href="APL360TerminalSystem1.htm#tab3">Table 3</a>,
which illustrates the behavior 
of the dimension function<tt> ⍴</tt>&nbsp;.<tt> </tt>
As implied by this table,<tt> ⍴ </tt>operating
on an array always in a vector.
A second application of<tt> ⍴ </tt>
then yields the rank of the original array.</p>

<p>Vectors and other arrays in APL are neutral,
and represent nothing more than an ordered collection
of numbers and symbols,
as the case may be.
A vector comprised of ones and zeros,
for example, is not itself a binary number,
any more than a vector comprised of digits
from 0 to 9 is a decimal number.
A function of the vector must be invoked
to find the number represented,
if that is the intention.
Similarly, the numbers themselves do not depend
for their meaning on how they are derived.
The relations, for example, map into 0 or 1,
for false or true, 
and the results are treated simply as numbers.</p>

<p>To maintain simplicity and generality,
no elision of operators 
is permitted in APL statements.
At best, only one such elision could be tolerated,
and this would make the language undesirably
dependent upon its context.
The added convenience in one particular field
of application would be offset
by the relative inconvenience in others.
<br>&nbsp;</p>



<a name="fns"></a>
<p><b>Functions Applied to Arrays</b></p>

<p>Referring again to <a href="APL360TerminalSystem1.htm#tab1">Table 1</a>,
it will be observed that the dyadic scalar primitives
are extended to rectangular arrays in four ways.
No special notational convention is required
for the element-by-element extension,
so that in the expression<tt> a+b</tt>&nbsp;,<tt> </tt>
for example,<tt> a </tt>and<tt> b </tt>may be any pair
of matching arrays.
If one argument is a scalar the other may be any array,
and the operation is defined 
as if the scalar argument were a matching array
comprised of identical elements.
As a consequence of this,
many expressions composed with only a scalar
in mind are nonetheless valid
for arrays of higher rank.</p>

<p>For example, in the polynomial form given above
(that is,<tt> a+z×b+z×c+z×d</tt>),<tt> z </tt> could
well be a vector or matrix.
In fact, any one of the coefficients
could be a non-scalar array,
provided that the other variables were scalars,
or arrays of matching size.
Similarly, the generic expression for a single term
of a series is usually valid 
for any number of terms 
if the running variable is a vector.
Thus,<tt> (x*n)÷!n </tt>is 
either the n<sup>th</sup> term
of the expansion of e<sup>x</sup>,
the entire series,
or an arbitrary set of terms,
depending upon whether<tt> n </tt>
is a single integer,
the sequence<tt> 1,2,3,&nbsp;... </tt> ,
or some other set of integers.</p>

<p>The extension of scalar dyadic primitives
in &ldquo;reduction&rdquo; uses a composite symbol,
comprising the operator symbol followed 
by a solidus, as in<tt> +/a</tt>&nbsp;.<tt> </tt>
The meaning is derived formally 
by inserting the operator between the elements
of the array;
for example,<tt> +/3&nbsp;7&nbsp;9&nbsp;2 </tt>
is equivalent to<tt> 3 + 7 + 9 + 2</tt>&nbsp;.<tt> </tt>
The term &ldquo;reduction&rdquo; refers 
to the relative rank of the resulting array;
if<tt> a </tt>is a vector,<tt> +/a </tt>yields a scalar,
if<tt> a </tt>is a matrix<tt> +/[2]a </tt>
yields a vector of row-sums and<tt> +/[1]a </tt>
yields a vector of column sums, etc.</p>

<p>If<tt> a </tt>is a scalar or a single-element vector,
reduction by any operator yields the scalar itself;
if<tt> a </tt>is an empty vector,
reduction yields the identity (if it exists)
for the operator.
These rules carry over to reduction
the commutativity and associativity
of scalar operators,
and often allow special cases 
to be included in general expressions
without special provision.
For example,<tt> ×/⍳n </tt>is equal to
factorial<tt> n </tt>for 
integer<tt> n≥0</tt>&nbsp;.<tt> </tt>
This is explicated as follows:<tt> ⍳n </tt>
generates a vector 
of integers<tt> 1,2,...,n</tt>&nbsp;,<tt> </tt>
and in general<tt> ⍴⍳n </tt>
is exactly<tt> n</tt>&nbsp;.<tt> </tt>
Hence,<tt> ⍳1 </tt>is the vector<tt> 1 </tt>
and<tt> ×/⍳1 </tt>equals<tt> 1</tt>&nbsp;.<tt> </tt>
Since<tt> ⍳0 </tt>is an empty vector<tt> </tt>
(<tt>⍴⍳0 </tt>equals<tt> 0</tt>),<tt> ×/⍳0 </tt>
gives the identity for multiplication,
which is also equal to<tt> 1</tt>&nbsp;.</p>

<p>Using reduction, an alternative expression
for a polynomial with<tt> c </tt>
as a vector of coefficients,
and<tt> e </tt>the vector of exponents,
is<tt> +/c×x*e</tt>&nbsp;.<tt> </tt>
In the standard form for a polynomial
of degree<tt> d</tt>&nbsp;,<tt> e </tt>
is the vector of integers<tt> 0,1,...,d</tt>&nbsp;,<tt> </tt>
which can be written as<tt> ¯1+⍳⍴c</tt>&nbsp;.<tt> </tt>
The polynomial may therefore be written
as<tt> +/c×x*¯1+⍳⍴c</tt>&nbsp;.<tt> </tt>
It will be useful later on to take advantage
of the fact that element-by-element multiplication
of vectors is commutative,
and write this as<tt> +/(x*¯1+⍳⍴c)×c</tt>&nbsp;.</p>

<p>Along the same lines,
the evaluation of the series for e<sup>x</sup>,
up to<tt> t </tt>terms, can be written
as<tt> +/(x*n-1)×!n-1</tt>&nbsp;,<tt> </tt>
where<tt> n </tt>has the value<tt> ⍳t</tt>&nbsp;.<tt> </tt>
The evaluation of e<sup>-x</sup> is just as simply written,
as<tt> -/(x*n-1)×!n-1</tt>&nbsp;,<tt> </tt>
since the reduction by minus gives
the alternating sum.
The last expression could also be used
to evaluate<tt> t </tt>terms of the series
for sine or cosine by setting<tt> n </tt>
to<tt> 2×⍳t </tt>or<tt> ¯1+2×⍳t</tt>&nbsp;,<tt> </tt>
respectively.
<br>&nbsp;</p>



<a name="ip"></a>
<p><b>Inner and Outer Products</b></p>

<p>The inner product is indicated in APL
by the compound symbol comprised of two operators
with a period between, as in<tt> a+.×b</tt>&nbsp;.<tt> </tt>
This example is the ordinary scalar product 
if<tt> a </tt>and<tt> b </tt>are vectors,
or the usual matrix product if the arguments
are matrices.
The notation reflects the fact that a matrix product
is generated by an element-by-element operation 
followed by a reduction.</p>

<p>Virtually any pair of scalar dyadic operators
has a meaningful interpretation as inner product
in some context:<tt> p×.*e </tt>will generate
a number from its prime factors<tt> p </tt>
and their powers<tt> e</tt>&nbsp;;<tt> a+.≥b </tt>
will count the number of positions 
in which<tt> a </tt>dominates<tt> b</tt>&nbsp;;<tt> </tt>
the series for e<sup>-x</sup> can be written
as<tt> (x*n-1)-.÷!n-1</tt>&nbsp;;<tt> </tt>etc.</p>

<p>The result of an inner product is an array
with rank two less than the sum of the argument ranks.
The result of an outer product, on the other hand,
is always an array of rank equal to the sum 
of the argument ranks.
This follows from the fact that
the reduction operation,
which collapses two dimensions in an inner product,
is not used in the outer product.
The notation for outer product
reflects this by canonically using a small circle
as the first symbol.
Thus, the ordinary outer product is written
as<tt> a∘.×b</tt>&nbsp;.</p>

<p>The outer product with operators 
other than<tt> × </tt>has great utility.
For example, if<tt> n </tt>has the 
value<tt> ⍳t</tt>&nbsp;,<tt> </tt>
then<tt> n∘.=n</tt>&nbsp;,<tt> n∘.&lt;n</tt>&nbsp;,<tt> n∘.≥n</tt>&nbsp;,<tt> </tt>
and<tt> ÷¯1+n∘.+n </tt>are respectively
the identity matrix, a strict upper triangle matrix,
a lower triangle matrix, and a Hilbert matrix,
all of dimension<tt> t </tt>by<tt> t</tt>&nbsp;.</p>

<p>The expression for a polynomial can be written
as an inner product:<tt> (x*¯1+⍳⍴c)+.×c</tt>&nbsp;.<tt> </tt>
In this form it can be used to evaluate a given polynomial
of arbitrary degree for a single value of<tt> x </tt>only;
to generalize it further &mdash; allowing<tt> x </tt>
to be an array of arbitrary rank and dimension &mdash;
it is merely necessary to use the outer product 
thus:<tt> (x∘.*¯1+⍳⍴c)+.×c</tt>&nbsp;.
<br>&nbsp;</p>



<a name="other"></a>
<p><b>Other Array Operations</b></p>

<p>Single elements or subarrays can be selected
from arrays by naming their location (indexing),
or by pointing to their locations in an array
having a related structure (compression).
Arrays as a whole may also be 
transposed<tt> </tt>(<tt>⍉</tt>),<tt> </tt>
rotated<tt> </tt>(<tt>⌽</tt>),<tt> </tt>
or completely restructured<tt> </tt>(dyadic<tt> ⍴</tt>).<tt> </tt>
These operations are defined for arrays of any rank,
although a practical upper limit for arrays
in APL\360 is about 12.</p>

<p>The notation for indexing employs square brackets,
which follows the name of the array
and enclose a number of expressions
equal to the rank of the array.
Expressions within the index 
may themselves evaluate to arrays,
and in all cases the resultant array
will have a dimension vector composed
of the catenated dimension vectors 
of the indices.</p>

<p>The absence of an expression where one might appear
in an index means the selection of all components
along the corresponding axis.
Thus, columns or rows may be selected from matrices,
lines or planes from three-dimensional arrays, etc.
A matrix may be partitioned into arbitrary submatrices
by using appropriate partitions of its index sets.
For example, if<tt> a </tt>and<tt> b </tt>
are partitions of the row indices,
and<tt> c </tt>and<tt> d </tt>are partitions
of the column indices, then the four submatrices
of a matrix<tt> q </tt>would be given
by<tt> q[a;c]</tt>&nbsp;,<tt> q[a;d]</tt>&nbsp;,<tt> q[b;c]</tt>&nbsp;,<tt> </tt>
and<tt> q[b;d]</tt>&nbsp;.<tt> </tt>
If<tt> t </tt>is an<tt> n </tt>by<tt> n </tt>matrix
representing the multiplication table 
for a semigroup whose elements are represented 
by<tt> ⍳n</tt>&nbsp;,<tt> </tt>
then the test for associativity of the operation is given 
by<tt> ^/^/^/t[t;]=t[;t]</tt>&nbsp;.</p>

<p>If<tt> u </tt>is a vector of distinct elements,
and<tt> p </tt>is a predicate defined 
for the elements of<tt> u</tt>&nbsp;,<tt> </tt>
then<tt> p&nbsp;u </tt>is a vector 
of the same dimension as<tt> u</tt>&nbsp;,<tt> </tt>
but composed only of ones and zeros.
The expression<tt> (p&nbsp;u)/u </tt>will select
from<tt> u </tt>only those elements 
for which<tt> p </tt>is true.
This is an example of compression,
which is more generally defined for vectors 
and other arrays whose elements
need not necessarily be distinct.
Like reduction, compression is applied 
to matrices by columns or by rows,
but compression always produces a subarray
of the same rank as the original array.
For example, if<tt> m </tt>is a 
matrix,<tt> (m[;1]=⌈/m[;1])/[1]m </tt>
is the matrix comprising those (one or more)
rows of<tt> m </tt>which contains
as their first element the largest value
found in the first column.</p>

<p>If<tt> u </tt>is a set of numbers,
and the predicate is the relation<tt> 0=4|u</tt>&nbsp;,<tt> </tt>
then<tt> (0=4|u)/u </tt>is the set comprising
elements of<tt> u </tt>
which are exact multiples of four.
There is a simple relationship between this form
and ordinary set 
notation:<tt> {x:x∊u&nbsp;</tt>and<tt>&nbsp;4|x}</tt>&nbsp;.<tt> </tt>
The major difference lies in the suppression
in APL of the dummy variable<tt> x</tt>&nbsp;,<tt> </tt>
and the requirement that the universe 
always be named explicitly.</p>

<p>The transposition operator in APL illustrates
one of the guiding principles in the design
of the language:
The ordinary use is obtained simply,
but is a special case of a more general 
and powerful operation.
Thus, used monadically on a matrix,<tt> ⍉m </tt>
gives the ordinary transpose,
which is also equivalent to the dyadic 
form,<tt> 2&nbsp;1&nbsp;⍉m</tt>&nbsp;.<tt> </tt>
For arrays of rank above<tt> 2</tt>&nbsp;,<tt> </tt>
this is generalized to an inversion
of the last two coordinates;
e.g., if<tt> a </tt>is a three dimensional 
array,<tt> ⍉a </tt>is equivalent 
to<tt> 1&nbsp;3&nbsp;2⍉a</tt>&nbsp;.</p>

<p>The dyadic form is again generalized
to permit repetitions in left arguments,
as in<tt> 1&nbsp;2&nbsp;1&nbsp;⍉a</tt>&nbsp;.<tt> </tt>
This produces a matrix whose second coordinate
is the second coordinate of<tt> a</tt>&nbsp;,<tt> </tt>
and whose first coordinate is taken
along the diagonal where the first and third coordinates
of<tt> a </tt>run together.
That is, the result is a diagonal plane 
of<tt> a</tt>&nbsp;.<tt> </tt>
For a matrix,<tt> 1&nbsp;1&nbsp;⍉m </tt>
is simply the main diagonal of<tt> m</tt>&nbsp;,<tt> </tt>
and is a vector.
If<tt> r </tt>is the resultant array and<tt> t⍉a </tt>
is the operation, then for all cases the structure
of<tt> r </tt>is given by the relatively simple
formulation:<tt> (⍴r)[i] </tt>
is equal to<tt> ⌊/(t=i)/⍴a</tt>&nbsp;,<tt> </tt>
for all<tt> i </tt>in<tt> ⍳⍴r</tt>&nbsp;.</p>

<p>Used monadically, the symbol<tt> ⌽ </tt>reverses
the order of its argument.
For instance,<tt> ⌽⍳3 </tt>
is the sequence<tt> 3&nbsp;2&nbsp;1</tt>&nbsp;.<tt> </tt>
Used dyadically, the left argument causes 
an end-around shift to the left.
Thus,<tt> 2⌽⍳5 </tt>
is<tt> 3&nbsp;4&nbsp;5&nbsp;1&nbsp;2 </tt>
and<tt> ¯2⌽⍳5 </tt>
is<tt> 4&nbsp;5&nbsp;1&nbsp;2&nbsp;3</tt>&nbsp;.<tt> </tt>
In both cases, application to arrays of higher rank
requires an index to choose the affected coordinates,
as in reduction or compression.
Thus, if<tt> m </tt>is a 5-row 
matrix,<tt> (⍳5)⌽[2]m </tt>will rotate
the first row by one, the second row by two, etc.</p>

<p>The dyadic<tt> ⍴ </tt>obeys the relation that
if<tt> r </tt>is the result of<tt> s⍴a</tt>&nbsp;,<tt> </tt>
then<tt> ⍴r </tt>is equal to<tt> s</tt>&nbsp;.<tt> </tt>
As many elements of<tt> a </tt>are used
as are required to make up the full complement
for<tt> r </tt>(equal to<tt> ×/s</tt>),<tt> </tt>
and<tt> a </tt>is used repetitively if necessary.
Thus,<tt> 3&nbsp;3&nbsp;⍴&nbsp;1&nbsp;0&nbsp;0&nbsp;0 </tt>
will form the<tt> 3 </tt>by<tt> 3 </tt>unit matrix;
and<tt> 1&nbsp;⍴&nbsp;4&nbsp;5&nbsp;6 </tt>
will result in the vector<tt> 4</tt>&nbsp;.<tt> </tt>
Generally,<tt> n⍴m⌽v </tt>will select
the<tt> m+1</tt><sup>st</sup> to <tt> m+n</tt><sup>th</sup>
elements of<tt> v</tt>&nbsp;.</p>

<p>If the right hand argument for<tt> ⍴ </tt>
is an array of rank higher than one,
its elements are used in the sequence
of &ldquo;row major order&rdquo;.
This is also the order of elements
in the vector produced 
by &ldquo;ravelling&rdquo; the array,
indicated by the use of the monadic comma.
Thus<tt> ,3&nbsp;3&nbsp;⍴&nbsp;1&nbsp;0&nbsp;0&nbsp;0 </tt>
is the vector<tt> 1&nbsp;0&nbsp;0&nbsp;0&nbsp;1&nbsp;0&nbsp;0&nbsp;0&nbsp;1</tt>&nbsp;.
<br>&nbsp;</p>



<a name="prog"></a>
<p><b>Programming Primitives</b></p>

<p>Everything discussed so far can be regarded
as simply extensions and modifications
to ordinary algebraic notation,
and APL can be used similarly,
for investigating the relationships 
among mathematical entities by formal manipulation.
The additional primitive required
for a programming language is the notion of specification,
or replacement of one value by another.
The symbol for this in APL is the left-pointing arrow,
the equal sign being reserved for use
only as one of the six relations.
Because statements such as<tt> z←z+1 </tt>
(read,<tt> z </tt>is &ldquo;replaced by&rdquo;
or &ldquo;specified by&rdquo;<tt> z+1</tt>)<tt> </tt>
are meaningful,
specification carries with it 
the notion of sequence.</p>

<p>A more explicitly sequential operator
is the branch,
designated by a right-pointing arrow,
which is used to indicate the sequence
to follow in executing a set of statements.
The normal sequence follows a succession
of statements written one below the other.
A branching statement alters the sequence
if the expression to the right 
of the arrow evaluates to a number
other than that of the next succeeding statement.
If it evaluates to an empty vector
the normal sequence is unchanged.
<br>&nbsp;</p>



<a name="defined"></a>
<p><b>Defined Functions</b></p>

<p>New functions are defined in APL by programs,
which may be regarded simply 
as formal statements of algorithms.
In general, may different programs may define
the same function,
and any one of them is a particular representation
of that function.
Two examples of simple programs are show
in <a href="APL360TerminalSystem1.htm#fig1">Figure 1</a>.<sup><a href="APL360TerminalSystem1.htm#note2">*</a></sup>
One finds the n<sup>th</sup> prime,
the other computes and displays Pascal&rsquo;s triangle
up to the n<sup>th</sup> power.</p>

<a name="note2"></a>
<blockquote><font size=-1>* Note that, in general,
entries from the keyboard are indented 
relative to machine output.</font></blockquote>

<p>The formal function definition facility
provides for six syntactic forms,
which fall into two classes,
depending upon whether they have explicit resultants.
The six possibilities are shown 
in <a href="APL360TerminalSystem1.htm#tab4">Table 4</a>,
and the programs in <a href="APL360TerminalSystem1.htm#fig1">Figure 1</a>
illustrate the cases of monadic functions
with and without explicit resultants.
As shown in these examples,
the syntax of the function is prescribed
in the &ldquo;header&rdquo; of the function definition,
the variables appearing in the header being
regarded strictly as dummy variables.
Identifiers set off by semi-colons
are &ldquo;local&rdquo; variables,
which have no value outside of the function.</p>

<p>Defined functions with explicit resultants
are treated like their analogs 
among the primitive functions,
and may be used freely in compound statements.
The analog to a function so defined 
has the properties of one:
it may enter into a computation as an argument
to any other function,
but because it is a function it cannot appear
as the left argument to a specification.
This is illustrated in <a href="APL360TerminalSystem1.htm#fig2">Figure 2</a>.
Functions without explicit resultants
find use for generating displays 
or for producing implicit results
(&ldquo;global&rdquo; variables)
to be used subsequently by functions
having implicit arguments &mdash;
a standard technique 
in ordinary programming practice.</p>

<p>There is no necessary relationship between the syntax
of a defined function and the complexity
of the program necessary for defining it.
This makes it possible to tailor
a set of functions to a particular application,
such as conventional mathematical analysis,
and use them with the APL primitives always available.
A simple illustration of this is the set of 
ten programs in <a href="APL360TerminalSystem1.htm#fig3">Figure 3</a>
which can be used for complex arithmetic
on arrays representing complex numbers.
Another illustration is <a href="APL360TerminalSystem1.htm#fig4">Figure 4</a>,
which is a program for matrix inversion,
based on Gauss-Jordan elimination.
<br>&nbsp;</p>



<a name="sys"></a>
<p><b>SYSTEM CHARACTERISTICS</b></p>

<p>APL\360 is built around the idea of a workspace,
analogous to a notebook, 
in which one keeps work in progress.
The workspace holds both defined functions
and variables (data),
and it may be stored into and retrieved from a library
holding many such workspaces.
When retrieved from a library by an appropriate command
from a terminal,
a copy of the stored workspace 
becomes active at that terminal,
and the functions defined in it,
together with all the APL primitives,
become available to the user.</p>

<p>The three commands required 
for managing a library
are &ldquo;save&rdquo;, &ldquo;load&rdquo;, and
&ldquo;drop&rdquo;, which respectively 
store a copy of an active workspace into a library,
make a copy of a stored workspace active,
and destroys the library copy of a workspace.
Each user of the system has a private library
into which only he can store.
However, he may load a workspace 
from any of a number of common libraries,
or if he is privy to the necessary information,
from another user&rsquo;s private library.
Functions or variables in different workspaces
can be combined, 
either item by item or all at once,
by a fourth command, called &ldquo;copy&rdquo;.
By means of three cataloging commands,
a user may get the names of workspaces in his own
or a common library,
or get a listing of functions or variables
in his active workspace.</p>

<p>A statement entered at a terminal
is executed immediately,
and if the result is not assigned to a variable,
it is printed out.
This desk-calculator-like operation
makes the system very convenient
for casual use or experimental exploration.
Intermediate results may be retained
as named variables,
and used at any subsequent time.
Values must be assigned to variables
prior to their attempted use;
the value of a given variable may be respecified
at any time,
and it always retains 
only the last value assigned.
<br>&nbsp;</p>



<a name="rep"></a>
<p><b>Representation of Variables and Numbers</b></p>

<p>There is no practical limitation
to the length of names of variables,
the only requirement being that 
they comprise only alphabetic or numeric characters,
and start with an alphabetic.
No special statement is required
for establishing that a variable
is to be an array,
nor is there any fixed association
between variable names 
and the kinds of values they represent.</p>

<p>APL does not recognize any distinction
between &ldquo;fixed point&rdquo; 
and &ldquo;floating point&rdquo; numbers,
this being primarily a matter of the representation
in a particular medium,
and the user of the terminal system
need have no concern with such questions
unless his work strains the capacity of the machine
with respect to either space or accuracy.
Although three different representations
for numbers are used internally,
transformations between them are carried out 
automatically and the user can be completely
indifferent to the underlying machine
if 16 decimal digits are adequate for his work.
For operations such as floor and ceiling,
and in comparisons for equality,
a &ldquo;fuzz&rdquo; of about 10<sup>-13</sup>
is applied in order to avoid anomalous results
that might otherwise be engendered 
by doing decimal arithmetic on a binary machine.
However, this factor can be controlled 
within the system
(although not by a terminal command),
and a workspace with a fuzz of zero
is available for certain work
in numerical analysis.
<br>&nbsp;</p>



<a name="ts"></a>
<p><b>Time and Space</b></p>

<p>With regard to space, 
a workspace can hold about 250000 numbers
derived from logical operations (0 or 1),
about 8000 integers up to 2<sup>31</sup> in value,
about 4000 larger integers or fractional numbers,
or about 32000 symbols.
Since user-defined programs are retained
substantially in their input form,
they require relatively little storage,
and the workspace size of 36000 System/360 bytes
has proven to be adequate for very many problems.
As a rough measure, it may be noted 
that real matrices as large as 35 by 35
can be multiplied and matrices 15 by 15
can be worked with comfortably.</p>

<p>The system has a fast response to inputs
which require only minimal amounts of computation,
such as individual calculations with scalars,
or the steps in function definition.
Thus, there is no visible delay upon entering a line
in the course of defining a function,
since the terminal responds 
with the next succeeding line number
in about the time it take for return
of the type carrier.
The response to longer calculations
is necessarily a function of the kind of work
that other users happen to be 
doing at the moment.
<br>&nbsp;</p>



<a name="oper"></a>
<p><b>Operational Features</b></p>

<p>The system is completely interpretive;
that is, there is translation to machine language
only at the time of execution,
each time a statement or defined function
is executed.
Because of the array operations in APL, however,
the overhead associated with the translation
is often very small relative 
to the amount of work being done.
The multiplication of two 35 by 35 matrices,
for example, requires the interpretation
of only 5 symbols,
and takes less than 16 seconds on a Model 50 machine
on which the system is currently operating.
The inversion of a 15 by 15 matrix by
the defined function show in <a href="APL360TerminalSystem1.htm#fig4">Figure 4</a>
takes about 10 seconds of compute time.
The generation and summation 
of 2000 integers<tt> </tt>(<tt>+/⍳2000</tt>)<tt> </tt>
takes half a second.</p>

<p>Statements entered into the system
are not checked for validity 
until their execution is attempted,
at which time the nature of the offense is printed,
followed by a copy of the offending statement
and a mark indicating 
where in the statement the difficulty was encountered.
If the statement is part of a program,
the name of the program and the line number
are included in the display.
Two features of the system make this kind
of operation feasible:
First, except for the initial specification
of a function header,
there is no procedural difference
between the original definition
of a function and later changes.
Lines can be inserted and deleted simply,
a single statement can be altered
without affecting others,
and single characters can be changed
without the need for retyping 
an entire statement.
It is possible to reopen a function definition,
correct an error,
and close the definition on a single line.
Second, having completed the correction,
it is possible to continue the execution
of a function by entering a command
to branch to the line number
at which it stopped.
Thus, work up to that point 
is not necessarily wasted.</p>

<p>This ability to continue execution
from where it has stopped has more general application.
It is possible to plan a stop in a long
or complex computation for the purpose
of examining intermediate results,
or merely to put off completion to another time.
In the second case the workspace is stored
in a library with the program in its suspended state,
and upon subsequent retrieval of the workspace,
it can be restarted.
Planned stops are accomplished by means
of a family of distinguished variables
whose values are the line numbers
at which stops are desired.
It is also possible to stop a calculation
by an interrupt from the keyboard 
at any arbitrary time.
In either case, the number of the next line
to be executed is automatically provided
and execution may be resumed as above.</p>

<p>Other means of interacting with a program
during execution are provided by the trace
and the quad.
The trace uses a family of distinguished variables,
like the stop, to signify the statements
whose results are to be printed during execution.
The quad<tt> </tt>(<tt>⎕</tt>)<tt> </tt>
is used for indicating input or output.
A quad to the left of a specification arrow
calls for display of the assigned value,
and it may even be used thus 
within compound statements to print 
the intermediate results developed 
during their execution.
Without the specification arrow,
a quad is a request for input,
and execution is halted pending an entry
from the keyboard.
Examples of these uses are shown 
in <a href="APL360TerminalSystem1.htm#fig5">Figure 5</a>.</p>

<p>Erasures are accomplished by backspace and line feed;
anything to the right of a line feed during
statement entry is considered to be erased.
Backspaces, therefore, have the same character
as forward spaces,
serving only to position the typing head.
This has two benefits:
it permits the use of overstruck symbols,
such as<tt> ⍉ </tt>and<tt> !</tt>&nbsp;,<tt> </tt>
and it avoids the ambiguity that obtains
when overstriking is used for corrections.
In general, the system has &ldquo;visual fidelity&rdquo;
&mdash; as long as platen and type carrier
are not moved manually, 
the system sees exactly when appears
on the hard copy,
regardless of the order of entry.
<br>&nbsp;</p>



<a name="summary"></a>
<p><b>SUMMARY</b></p>

<p>The system has been designed
to minimize the distraction of a user
from his problem,
while not disguising the fact that
he is working with a machine.
The advantages that accrue from the discipline
imposed by a machine are not diluted 
by the imposition of tasks 
which are essentially only clerical.
Thus, on the one hand,
the burden has been placed on the machine
wherever sufficient information is available
in the normal course of events,
as in the automatic handling
of number representations and arrays,
and in the production of output at the terminal
when no other destination is specified.
On the other hand, necessary messages
to the user are as brief and impersonal as possible,
and any attempt at guessing 
what was &ldquo;really meant&rdquo;
in the case of obvious error is strictly avoided.</p>

<p>In the first ten months of its existence,
the APL\360 terminal system has attracted
more than 200 users 
within the IBM Research establishment.
Mathematical applications 
include work in statistical mechanics,
design of ultra-reliable computer systems,
experimental teaching of secondary school mathematics,
and the algebraic manipulation of polynomials.
It has proven attractive to many scientists
and engineers who heretofore have resisted
direct association with computers or programming.
<br>&nbsp;</p>



<a name="ack"></a>
<p><b>ACKNOWLEDGMENT</b></p>

<p>The authors wish to acknowledge 
the direct contributions of L.M. Breed,
R.H. Lathwell, R.D. Moore, and L. Woodrum,
all of whom worked on the implementation.
Breed, in particular, has contributed substantially
to many of the aspects of the system 
described in this paper,
as well as having led the implementation effort.
We are indebted, also, to many other 
of our colleagues at IBM
for discussions arising 
from their use of the system.
<br>&nbsp;</p>



<a name="ref"></a>
<p><b>REFERENCES</b></p>

<table>
<tr><td valign=top>1.</td><td>&nbsp;</td><td>
K.E. Iverson, 
<a target=_parent href="http://www.jsoftware.com/papers/APL.htm"><i>A Programming Language</i></a>.
Wiley, New York, 1962.
</td></tr>
<tr><td valign=top>2.</td><td>&nbsp;</td><td>
A.D. Falkoff, K.E. Iverson, and E.H. Sussenguth,
&ldquo;A Formal Description of System/360&rdquo;,
<i>IBM Systems Journal</i>, Vol. 3, No. 3, 1964.
</td></tr>
<tr><td valign=top>3.</td><td>&nbsp;</td><td>
K.E. Iverson, 
<a target=_parent href="http://www.jsoftware.com/jwiki/Doc/Elementary%20Functions%20An%20Algorithmic%20Treatment"><i>Elementary Functions</i></a>.
SRA, Chicago, 1966.
</td></tr>
<tr><td valign=top>4.</td><td>&nbsp;</td><td>
A.D. Falkoff and K.E. Iverson, 
&ldquo;The APL Terminal System:
Instructions for Operation&rdquo;.
IBM Research, Yorktown Heights, N.Y., 1966.
</td></tr>
<tr><td valign=top>5.</td><td>&nbsp;</td><td>
L.M. Breed and R.H. Lathwell,
&ldquo;The Implementation of APL\360&rdquo;.
(To be published.)
</td></tr>
</table>
<br>



<a name="tables"></a>
<p><b>TABLES</b></p>

<a name="tab1"></a>
<p><b>Table 1. Scalar Primitive Operations</b></p>

<p>Operations Defined on Scalar Arguments,
Yielding a Scalar as Result</p>

<table>
<tr><td colspan=3 align=center>Dyadic</td><td>&nbsp; &nbsp;</td><td colspan=3 align=center>Monadic</td></tr>
<tr><td><tt>a+b</tt>&nbsp;</td><td>&nbsp;</td><td>sum of<tt> a </tt>and<tt> b</tt></td><td>&nbsp;</td>
 <td><tt>+b</tt>&nbsp;</td><td>&nbsp;</td><td><tt>b</tt>&nbsp;</td></tr>
<tr><td><tt>a-b</tt>&nbsp;</td><td>&nbsp;</td><td><tt>b </tt>subtracted from<tt> a</tt></td><td>&nbsp;</td>
 <td><tt>-b</tt>&nbsp;</td><td>&nbsp;</td><td>negative of<tt> b</tt>&nbsp;</td></tr>
<tr><td><tt>a×b</tt>&nbsp;</td><td>&nbsp;</td><td>product of<tt> a </tt>and<tt> b</tt></td><td>&nbsp;</td>
 <td><tt>×b</tt>&nbsp;</td><td>&nbsp;</td><td><tt>b</tt>&nbsp;</td></tr>
<tr><td><tt>a÷b</tt>&nbsp;</td><td>&nbsp;</td><td><tt>a </tt>divided by<tt> b</tt></td><td>&nbsp;</td>
 <td><tt>÷b</tt>&nbsp;</td><td>&nbsp;</td><td>reciprocal of<tt> b</tt>&nbsp;</td></tr>
<tr><td><tt>a*b</tt>&nbsp;</td><td>&nbsp;</td><td><tt>a </tt>raised to the power<tt> b</tt></td><td>&nbsp;</td>
 <td><tt>*b</tt>&nbsp;</td><td>&nbsp;</td><td>exponential of<tt> b</tt>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td>
 <td><tt>⍟b</tt>&nbsp;</td><td>&nbsp;</td><td>natural logarithm of<tt> b</tt>&nbsp;</td></tr>
<tr><td><tt>a⌈b</tt>&nbsp;</td><td>&nbsp;</td><td>larger of<tt> a </tt>and<tt> b</tt></td><td>&nbsp;</td>
 <td><tt>⌈b</tt>&nbsp;</td><td>&nbsp;</td><td>ceiling of<tt> b</tt>&nbsp;</td></tr>
<tr><td><tt>a⌊b</tt>&nbsp;</td><td>&nbsp;</td><td>smaller of<tt> a </tt>and<tt> b</tt></td><td>&nbsp;</td>
 <td><tt>⌊b</tt>&nbsp;</td><td>&nbsp;</td><td>floor of<tt> b</tt>&nbsp;</td></tr>
<tr><td><tt>a|b</tt>&nbsp;</td><td>&nbsp;</td><td>residue of<tt> b </tt>modulo<tt> a</tt></td><td>&nbsp;</td>
 <td><tt>|b</tt>&nbsp;</td><td>&nbsp;</td><td>absolute value of<tt> b</tt>&nbsp;</td></tr>
<tr><td valign=top><tt>a!b</tt>&nbsp;</td><td>&nbsp;</td><td>combinations of<tt> b </tt>items taken<tt> a </tt>at a time</td><td>&nbsp;</td>
 <td valign=top><tt>!b</tt>&nbsp;</td><td>&nbsp;</td><td>factorial of<tt> b </tt>(gamma function of<tt> 1+b</tt>)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td>
 <td valign=top><tt>?b</tt>&nbsp;</td><td>&nbsp;</td><td>random integer between<tt> 1 </tt>and<tt> b </tt>inclusive</td></tr>
<tr><td><tt>a∨b</tt>&nbsp;</td><td>&nbsp;</td><td>logical &ldquo;or&rdquo; of<tt> a </tt>and<tt> b</tt></td></tr>
<tr><td><tt>a^b</tt>&nbsp;</td><td>&nbsp;</td><td>logical &ldquo;and&rdquo; of<tt> a </tt>and<tt> b</tt></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td>
 <td><tt>~b</tt></td><td>&nbsp;</td><td>logical negation of<tt> b</tt></td></tr>
<tr><td><tt>a&lt;b</tt>&nbsp;</td><td>&nbsp;</td><td><tt>┐ </tt>&nbsp;</td></tr>
<tr><td><tt>a≤b</tt>&nbsp;</td>   <td>&nbsp;</td><td><tt>│ </tt>relations yield</td></tr>
<tr><td><tt>a=b</tt>&nbsp;</td>   <td>&nbsp;</td><td><tt>│ </tt>1, if true</td></tr>
<tr><td><tt>a≥b</tt>&nbsp;</td>   <td>&nbsp;</td><td><tt>│ </tt>0, if false</td></tr>
<tr><td><tt>a&gt;b</tt>&nbsp;</td><td>&nbsp;</td><td><tt>│ </tt>&nbsp;</td></tr>
<tr><td><tt>a≠b</tt>&nbsp;</td>   <td>&nbsp;</td><td><tt>┘ </tt>&nbsp;</td></tr>
<tr><td>&nbsp;</td></tr>
<tr><td colspan=3>&nbsp; &nbsp; &nbsp; &nbsp;Extensions to Arrays:</td><td>&nbsp;</td><td colspan=3>&nbsp; &nbsp; &nbsp; &nbsp;Extensions to Arrays:</td></tr>
<tr><td colspan=3>component by component</td><td>&nbsp;</td><td colspan=3>component by component</td></tr>
<tr><td colspan=3>reduction (summation, etc.)</td></tr>
<tr><td colspan=3>inner product (scalar product, matrix product, etc.)</td></tr>
<tr><td colspan=3>outer product</td></tr>
</table>
<br>



<a name="tab2"></a>
<p><b>Table 2. Mixed Primitive Operations</b></p>

<p>Operations involving arrays of diverse rank</p>
<table>
<tr><td colspan=3>Monadic</td></tr>
<tr><td><tt>⍳b</tt>&nbsp;</td><td>&nbsp;</td>
 <td>interval vector of length<tt> b</tt></td></tr>
<tr><td><tt>⍴b</tt>&nbsp;</td><td>&nbsp;</td>
 <td>dimension vector of array<tt> b</tt></td></tr>
<tr><td><tt>,b</tt>&nbsp;</td><td>&nbsp;</td>
 <td>ravel of<tt> b </tt>(vector comprising of all elements of<tt> b</tt>)</td></tr>
<tr><td><tt>⍉b</tt>&nbsp;</td><td>&nbsp;</td>
 <td>transpose of array<tt> b</tt></td></tr>
<tr><td><tt>⌽b</tt>&nbsp;</td><td>&nbsp;</td>
 <td>reversal of sequence of elements of<tt> b</tt></td></tr>
<tr><td>&nbsp;</td></tr>
<tr><td><tt>→b</tt>&nbsp;</td><td>&nbsp;</td>
 <td>branch to line<tt> b</tt></td></tr>
<tr><td>&nbsp;</td></tr>
<tr><td colspan=3>Dyadic</td></tr>
<tr><td><tt>a⍺b</tt>&nbsp;</td><td>&nbsp;</td>
 <td>prefix vector of length<tt> a </tt>with<tt> b </tt>leading ones</td></tr>
<tr><td><tt>a⍵b</tt>&nbsp;</td><td>&nbsp;</td>
 <td>suffix vector of length<tt> a </tt>with<tt> b </tt>trailing ones</td></tr>
<tr><td><tt>a∊b</tt>&nbsp;</td><td>&nbsp;</td>
 <td>characteristic of<tt> b </tt>on<tt> a </tt>(result has dimension<tt> ⍴a</tt>)</td></tr>
<tr><td><tt>a⍳b</tt>&nbsp;</td><td>&nbsp;</td>
 <td>index of<tt> b </tt>in<tt> a </tt>(result has dimension<tt> ⍴b</tt>)</td></tr>
<tr><td><tt>a⍴b</tt>&nbsp;</td><td>&nbsp;</td>
 <td>array with dimension vector<tt> a</tt>&nbsp;,<tt> </tt>comprised of elements of<tt> b</tt></td></tr>
<tr><td><tt>a⊥b</tt>&nbsp;</td><td>&nbsp;</td>
 <td>value of<tt> b </tt>in radix<tt> a </tt>(result is a scalar)</td></tr>
<tr><td><tt>a⊤b</tt>&nbsp;</td><td>&nbsp;</td>
 <td>representation of<tt> b </tt>in radix<tt> a </tt>(result has dimension<tt> ⍴a</tt>)</td></tr>
<tr><td><tt>a,b</tt>&nbsp;</td><td>&nbsp;</td>
 <td>catenation of<tt> a </tt>and<tt> b</tt></td></tr>
<tr><td><tt>a/b</tt>&nbsp;</td><td>&nbsp;</td>
 <td>compression of<tt> b </tt>by<tt> a</tt></td></tr>
<tr><td><tt>a\b</tt>&nbsp;</td><td>&nbsp;</td>
 <td>expansion of<tt> b </tt>by<tt> a</tt></td></tr>
<tr><td><tt>a⍉b</tt>&nbsp;</td><td>&nbsp;</td>
 <td>generalized transpose of array<tt> b</tt>&nbsp;,<tt> </tt>according to<tt> a</tt></td></tr>
<tr><td><tt>a⌽b</tt>&nbsp;</td><td>&nbsp;</td>
 <td>rotation of<tt> b</tt>&nbsp;,<tt> a </tt>positions to the left</td></tr>
<tr><td><tt>a[b]</tt>&nbsp;</td><td>&nbsp;</td>
 <td>selection from<tt> a </tt>by index<tt> b </tt>
 (result has dimension<tt> ⍴b</tt>)</td></tr>
<tr><td>&nbsp;</td></tr>
<tr><td><tt>a←b</tt>&nbsp;</td><td>&nbsp;</td>
 <td><tt>a </tt>assumes the value of<tt> b</tt></td></tr>
</table>
<br>



<a name="tab3"></a>
<p><b>Table 3. Dimensions of Vectors and Ranks of Arrays</b></p>

<table border=1 cellspacing=0 cellpadding=5>
<tr><td>&nbsp;</td><td colspan=4 align=center>Array Type</td></tr>
<tr><td>&nbsp;</td><td>Scalar</td><td>Vector</td><td>Matrix</td><td>3-Array</td></tr>
<tr><td><tt>⍴array </tt>(dimension)</td><td>&nbsp;</td><td align=center><tt>n</tt></td><td align=center><tt>m,n</tt></td><td align=center><tt>l,m,n</tt></td></tr>
<tr><td><tt>⍴⍴array </tt>(rank)</td><td align=center><tt>0</tt></td><td align=center><tt>1</tt></td><td align=center><tt>2</tt></td><td align=center><tt>3</tt></td></tr>
<tr><td><tt>⍴⍴⍴array</tt></td>      <td align=center><tt>1</tt></td><td align=center><tt>1</tt></td><td align=center><tt>1</tt></td><td align=center><tt>1</tt></td></tr>
</table>
<br>


<a name="tab4"></a>
<p><b>Table 4. Header Forms in Function Definition</b></p>

<table border=1 cellspacing=0 cellpadding=5>
<tr><td>&nbsp;</td><td colspan=3 align=center>Number of Arguments</td></tr>
<tr><td>&nbsp;</td><td align=center>None</td><td align=center>One</td><td align=center>Two</td></tr>
<tr><td>no explicit result &nbsp; </td><td align=center><tt> ∇f</tt></td><td align=center><tt>∇f b</tt></td><td align=center><tt>∇a f b</tt></td></tr>
<tr><td>explicit result</td><td align=center><tt>&nbsp;∇c←f&nbsp;</tt></td><td align=center><tt>&nbsp;∇c←f b&nbsp;</tt></td><td align=center><tt>&nbsp;∇c←a f b&nbsp;</tt></td></tr>
</table>
<br><br>


<a name="figures"></a>
<p><b>FIGURES</b></p>

<a name="fig1"></a>
<p><b>Figure 1. Examples of Monadic Defined Functions</b></p>


<table>
<tr><td><pre>
    ∇ z←pn n;j    
[1]   z←2,j←3     
[2]   j←j+2       
[3]   →2×⍳∨/0=z|j 
[4]   z←z,j       
[5]   →2×⍳(⌈/n)>⍴z
[6]   z←z[n]
    ∇

      a←pn 3
      a
5
      n←pn a
      n
11
      3×pn a
33
      pn 1 2 3 4 5
2 3 5 7 11
      (pn 3)|pn 6
3
</pre></td><td><tt>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</tt></td><td><pre>
    ∇ pascal n
[1]   j← 1 1
[2]   j
[3]   →0×⍳n=j[2]
[4]   j←(j,0)+0,j
[5]   →2
    ∇

      pascal 1
1 1
      pascal 2
1 1
1 2 1
      pascal 5
1 1
1 2 1
1 3 3 1
1 4 6 4 1
1 5 10 10 5 1
      j
1 5 10 10 5 1
</pre></td></tr>
</table>
<br>



<a name="fig2"></a>
<p><b>Figure 2. Example of Defined Function Without Arguments</b></p>

<pre>
    ∇ z←pi
[1]   z←3.141592653589793
    ∇
      a←2×pi
      a
6.283185307
      pi÷6
0.5235987756
      pi←22÷7
SYNTAX ERROR
      pi←22÷7
      ∧

</pre>



<a name="fig3"></a>
<p><b>Figure 3. Set of Functions for Complex Arithmetic on Arrays</b></p>

<pre>
    ∇ z←a cadd b
[1]   z←a+b
    ∇

    ∇ z←a csub b
[1]   z←a-b
    ∇

    ∇ z←a cmpy b
[1]   z←(⍴a)⍴(,-/[1]a×b),,+/[1]a×⌽[1]b
    ∇

    ∇ z←a cdiv b
[1]   z←(a cmpy conj b)÷(⍴a)⍴+/[1]b*2
    ∇

    ∇ z←conj b;t
[1]   t←0.5××/⍴b
[2]   z←b×(⍴b)⍴(t⍴1),t⍴¯1
    ∇

    ∇ z←comp a
[1]   z←⍉((0.5×⍴a),2)⍴a
    ∇
 
    ∇ z←d rho x;a
[1]   a←0.5××/⍴x
[2]   z←(2,d)⍴((×/d)⍴(a⍴x)),(×/d)⍴⌽a⍴⌽,x
    ∇

    ∇ z←real a
[1]   z←((~(⍴⍴a)⍺1)⍴a)/⍴a
    ∇
 
    ∇ z←imag a
[1]   z←((~(⍴⍴a)⍺1)/⍴a)⍴⌽[1]a
    ∇

    ∇ z←mod a
[1]   z←(+/[1]a×a)*0.5
    ∇

</pre>



<a name="fig4"></a>
<p><b>Figure 4. Matrix Inversion by Gauss-Jordan Elimination With Pivoting</b></p>

<pre>
    ∇ b←rec a;p;k;i;j;s
[1]   →3×⍳(2=⍴⍴a)∧=/⍴a
[2]   →0=⍴⎕←'no inverse found'
[3]   p←⍳k←s←1⍴⍴a
[4]   a←((s⍴1),0)\a
[5]   a[;s+1]←s⍺1
[6]   i←j⍳⌈/j←|a[⍳k;1]
[7]   p[1,i]←p[i,1]
[8]   a[1,i;⍳s]←a[i,1;⍳s]
[9]   →2×⍳1E¯30>|a[1;1]÷⌈/|,a
[10]  a[1;]←a[1;]÷a[1;1]
[11]  a←a-((~s ⍺ 1)×a[;1])∘.×a[1;]
[12]  a←1⌽[1]1⌽a
[13]  p←1⌽p
[14]  →5×⍳0&lt;k←k-1
[15]  b←a[;p⍳⍳s]
    ∇

</pre>



<a name="fig5"></a>
<p><b>Figure 5. Use of Quad and Quoted Quad for Output and Input</b></p>

<pre>
      ⎕←5×4×3×2×1
120
      5×4×3×2×1
120
      5×⎕←4×⎕←3×⎕←2×⎕←1
1
2
6
24
120
      5×⎕×3×⎕×1
⎕:
      2
⎕:
      4
120
      s←'example of ',⍞,' input using composite ',⍞
symbol.
literal
      ⍴s
48
      s
example of literal input using composite symbol.

</pre>



<br><hr>
<font size=-1>
<p>Originally appeared as Research Report RC-1922, 1967-10-16.
<p><script src="apldisplay.js" type="text/javascript"></script></p>
</font>

<table>
<tr><td><font size="-1">created: &nbsp;</font></td><td><font size="-1">2009-10-10 20:55</font></td></tr>
<tr><td><font size="-1">updated:</font></td><td><font size="-1">2013-07-23 21:55</font></td></tr>
</table>

</td></tr></table>
<br><br><br>
</body>
</html>