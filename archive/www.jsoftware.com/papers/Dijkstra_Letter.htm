<html>
<head><meta http-equiv="content-type" content="text/html;charset=utf-8">
<title>A Letter from Dijkstra on APL</title>
<link href="https://www.jsoftware.com/papers/adoc.css" rel=stylesheet>
</head>

<body>

<br>

<table align=center width=520><tr><td>

<p align=center><font size=+2>A Letter from Dijkstra on APL</font><br><br>
<b>Roger K.W. Hui</b>
<br>&nbsp;</p>

<p><b>Acknowledgments.</b>  I would like to thank
Bob Bernecky, Nicolas Delcros, Jay Foad, and Eric Iverson
for comments on the manuscript.
<br>&nbsp;</p>



<hr>

<p>Nick Nickolov brought to my attention comments by Dijkstra on APL 
<acronym title=
"Daylight, Edgar Graham, A Letter about APL, 2012-04-05.">[0]</acronym>
that I had not seen before.  
I contacted the author of the website and obtained a copy
of Dijkstra&rsquo;s letter, transcribed below:
<br>&nbsp;</p>

<table border=1 cellpadding=10 cellspacing=0><tr><td>
<font size=+1><b>Burroughs</b></font>

<table><tr>
<td nowrap><font size=-1>PROF DR EDSGER W DIJKSTRA</font></td><td width=130></td>
 <td align=right><font size=-1>PLATAANSTRAAT 5</font></td></tr>
<td><font size=-1>RESEARCH FELLOW</font></td> <td></td>
 <td width=60% align=right><font size=-1>5671 AL NUENEN THE NETHERLANDS</font></td>
</tr></table>

<p>Dr A.Caplin<br>
[street address]<br>
<u>CROYDON</u>, Surrey<br>
United Kingdom</p>
                                     
<table><tr><td width=200></td><td>Tuesday 12 January 1982</td></tr></table>

<p>Dear Dr Caplin,</p>

<p> &nbsp; &nbsp; &nbsp; thank [<i>sic</i>] you for your letter dated 31 May (?) 1981.  You were right in your
reference to an APL &ldquo;cult&rdquo;: some adore it and others abhor it with very few in 
between.  Allow me to offer you another explanation for that phenomenon.</p>

<p> &nbsp; &nbsp; &nbsp; I think that most people (be it subconsciously) realize that &ldquo;ease of
use&rdquo; is not the most significant aspect.  Experience has show that, provided
people are sufficiently thrilled by a gadget, they are willing to put up with
the most terrible interfaces.  Much more important is that the tool shapes the
one who trains himself in its usage, just as the words we use shape our thoughts
and the instrument forms the violinist.  I think that a major reason for shunning
APL is that many people are repelled by the influence APL has on its devotees.
They implement the prayer &ldquo;Dear Lord, don&rsquo;t let me become like them&rdquo; by ignoring
it.</p>

<p> &nbsp; &nbsp; &nbsp; A typical characteristic of the APL devotee is, for instance, his closeness 
to an implementation of it.  I know of a visiting professor at an American
University [<i>sic</i>] who, trying to teach APL, bitterly complained about the absence of
APL terminals.  He was clearly unable to teach it without them.  And you, too,
write to me that you would like to meet me in your part of the world, so that
you can &ldquo;demonstrate APL&rdquo; to me.  This is in sharp contrast to people who
prefer programming languages that can be adadequately [<i>sic</i>] &ldquo;demonstrated&rdquo;&mdash;i.e.
shown, taught and discussed&mdash;with pencil and paper.</p>

<p> &nbsp; &nbsp; &nbsp; The fact that the printed or written word is apparently not the proper
medium for the propagation of APL may offer a further explanation for its relative 
isolation; at the same time that fact may be viewed as one of its major
shortcomings.</p>

<p> &nbsp; &nbsp; &nbsp; Your writings made me wonder in which discipline you got your doctor&rsquo;s
degree.</p>

<table><tr><td colspan=2>&nbsp; &nbsp; &nbsp; With my greetings and best wishes,</td></tr>
<tr><td width=200>&nbsp;</td><td>yours ever,<br>&nbsp; &nbsp; (signed) Edsger W. Dijkstra</td></tr>
<tr><td></td></tr>
<tr><td colspan=2>PS. I apologize for the quality of my signature; having broken my right arm
I have to sign with my left hand.</td></td>
<tr><td width=200></td><td>EWD</td></tr>
</table>
</td></tr></table>
<br>



<p>I find Dijkstra&rsquo;s comments deeply ironic, 
because Ken Iverson invented his notation 
as a means of communications among people
<acronym title=
"Iverson, Kenneth E., A Personal View of APL, IBM Systems Journal, Volume 30, Number 4, 1991-12.">[1]</acronym>, 
and it was only years later that the notation was implemented 
on a computer at which time it became APL.  
Moreover, Dijkstra encountered &ldquo;Iverson notation&rdquo; 
no later than August 1963 before there was an implementation 
<acronym title=
"Iverson, Kenneth E., Formalism in Programming Languages, Communications of the ACM, Volume 7, Number 2, 1964-02.">[2]</acronym>.
Even with APL, perhaps especially with APL, 
one can reasonably do non-trivial things 
without ever executing it on a computer.</p>

<p>I have read at least one of Dijkstra&rsquo;s EWDs in which he wrote programs 
using formal methods, at the end of which is derived a provably correct program.  
As I read it/them, I thought to myself, 
&ldquo;APL should have been natural for Dijkstra&rdquo;.  
One can argue what &ldquo;provably correct program&rdquo; means.  
To me, it means what a typical mathematician means when he/she says a theorem has been proven.  
I know it is far from saying that the program will produce a correct result 
in all circumstances (compiler/interpreter has a bug, 
somebody pulls the plug, cosmic ray strikes a transistor, etc.), 
but I believe I am using &ldquo;prove&rdquo; 
in the same sense that Dijkstra did.</p>

<p>Like Dijkstra&rsquo;s &ldquo;visiting professor at an American university&rdquo;, 
I would be distressed if I had to teach a course on APL 
without an APL machine.
Were it a course on formal methods, one can get by without a machine;
but even in a course on formal methods executability would be an asset,
because executability keeps you honest, a faithful servant that can be
used to check the steps of a proof.
Were it a general programming course, it seems extreme 
to eschew the use of a machine in showing, teaching, and discussing.
It would be like trying to learn a natural language without ever
conversing with a speaker of that language.</p>

<p>Herewith, two examples of using APL in formal manipulations.
Further such examples can be
found in Iverson&rsquo;s Turing Award Lecture 
<acronym title=
"Iverson, Kenneth E., Notation as a Tool of Thought, Communications of the ACM, Volume 23, Number 8, 1980-08.">[3]</acronym>.
A proof is here presented as in 
<acronym title=
"Iverson, Kenneth E., Notation as a Tool of Thought, Communications of the ACM, Volume 23, Number 8, 1980-08.">[3]</acronym>,
a sequence of expressions each identical to its predecessor,
annotated with the reasoning.</p>

<p>A Summary of Notation is provided at the end.
<br>&nbsp;
</p>



<p><b>Example 0: Ackermann&rsquo;s Function</b></p>

<p>The derivation first appeared in 1992 
<acronym title=
"Hui, Roger K.W., Three Combinatoric Puzzles, Vector, Volume 9, Number 2, 1992-10; also in Ackermann’s Function, J Wiki Essay, 2005-10-14.">[4]</acronym>
in J and is transcribed here in Dyalog APL.</p>

<p>Ackermann&rsquo;s function is defined on non-negative integers as follows:</p>

<pre>
   ack←{             
     0=⍺: 1+⍵       
     0=⍵: (⍺-1) ∇ 1
     (⍺-1) ∇ ⍺ ∇ ⍵-1
   }                 

   2 ack 3
9
   3 ack 2
29
</pre>

<p>Lemma: If<tt> ⍺ ack ⍵ ←→ f⍢(3∘+) ⍵</tt>&nbsp;,
then<tt> (⍺+1)ack ⍵ ←→ f⍣(1+⍵)⍢(3∘+)&nbsp;1</tt>&nbsp;.

<p>Proof: By induction on<tt> ⍵</tt>&nbsp;.

<table>
<tr><td><tt>(⍺+1) ack 0</tt></td>     <td>basis</td></tr>
<tr><td><tt>⍺ ack 1</tt></td>         <td>definition of<tt> ack </tt></td></tr> 
<tr><td><tt>f⍢(3∘+) 1</tt></td>       <td>antecedent of lemma</td></tr>
<tr><td><tt>f⍣(1+0)⍢(3∘+) 1</tt></td> <td><tt>⍣</tt></td></tr>
<tr><td>&nbsp;</td></tr>

<tr><td><tt>(⍺+1) ack ⍵</tt>&nbsp;</td>                     <td>induction</td></tr>
<tr><td><tt>⍺ ack (⍺+1) ack ⍵-1</tt>&nbsp;</td>             <td>definition of<tt> ack </tt></td></tr>
<tr><td><tt>f⍢(3∘+) (⍺+1) ack ⍵-1</tt>&nbsp;</td>           <td>antecedent of lemma</td></tr> 
<tr><td><tt>f⍢(3∘+) f⍣(1+⍵-1)⍢(3∘+) 1</tt>&nbsp;</td>       <td>inductive hypothesis</td></tr> 
<tr><td><tt>¯3∘+ f 3∘+ ¯3∘+ f⍣(1+⍵-1) 3∘+ 1 &nbsp; </tt>&nbsp;</td> <td><tt>⍢</tt>&nbsp;</td></tr> 
<tr><td><tt>¯3∘+ f f⍣(1+⍵-1) 3∘+ 1</tt>&nbsp;</td>          <td><tt>+</tt>&nbsp;</td></tr> 
<tr><td><tt>¯3∘+ f⍣(1+⍵) 3∘+ 1</tt>&nbsp;</td>              <td><tt>⍣</tt>&nbsp;</td></tr> 
<tr><td><tt>f⍣(1+⍵)⍢(3∘+) 1</tt>&nbsp;</td>                 <td><tt>⍢</tt>&nbsp;</td></tr> 
<tr><td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QED</td></tr> 
</table>

<p>Using the lemma (or otherwise), it can be shown that:</p>

<pre>
0∘ack = 1∘+⍢(3∘+)
1∘ack = 2∘+⍢(3∘+)
2∘ack = 2∘×⍢(3∘+)
3∘ack = 2∘*⍢(3∘+)
4∘ack = */∘(⍴∘2)⍢(3∘+)
5∘ack = {*/∘(⍴∘2)⍣(1+⍵)⍢(3∘+) 1}
</pre>
<br>


<p><b>Example 1: Inverted Table Index-Of</b></p>

<p>Presented at the 2013 Dyalog Conference 
<acronym title=
"Hui, Roger K.W., Rank & Friends, 2013 Dyalog Conference, 2013-10-22.">[5]</acronym>.</p>

<p>A <i>table</i> is a set of values organized into rows and columns. 
The rows are records. Values in a column have the same type and shape. 
A table has a specified number of columns but can have any number of rows.
The extended <i>index-of</i> on tables finds record indices.</p>

<pre>
   tx                   ty                    tx ⍳ ty
┌──────┬─┬───┬──┐    ┌──────┬─┬───┬──┐     3 1 5 2 5 5
│John  │M│USA│26│    │Min   │F│CN │17│
├──────┼─┼───┼──┤    ├──────┼─┼───┼──┤        tx ⍳ tx
│Mary  │F│UK │24│    │Mary  │F│UK │24│     0 1 2 3 4
├──────┼─┼───┼──┤    ├──────┼─┼───┼──┤
│Monika│F│DE │31│    │John  │M│UK │26│        ty ⍳ ty
├──────┼─┼───┼──┤    ├──────┼─┼───┼──┤     0 1 2 3 4 4
│Min   │F│CN │17│    │Monika│F│DE │31│
├──────┼─┼───┼──┤    ├──────┼─┼───┼──┤
│Max   │M│IT │29│    │Mesut │M│DE │24│
└──────┴─┴───┴──┘    ├──────┼─┼───┼──┤
                     │Mesut │M│DE │24│
                     └──────┴─┴───┴──┘
</pre>

<p>An <i>inverted table</i> is a table with the values of a column collected together. 
<i>Comma-bar each</i> (<tt>⍪¨</tt>) applied to an inverted table 
makes it &ldquo;look&rdquo; more like a table. 
And of course the columns have the same <i>tally</i> (<tt>≢</tt>).
A table can be readily inverted and <i>vice versa</i>.</p>

<pre>
   x
┌──────┬─────┬───┬──────────────┐
│John  │MFFFM│USA│26 24 31 17 29│
│Mary  │     │UK │              │
│Monika│     │DE │              │
│Min   │     │CN │              │
│Max   │     │IT │              │
└──────┴─────┴───┴──────────────┘
   ⍪¨x                     ≢¨x      
┌──────┬─┬───┬──┐       5 5 5 5
│John  │M│USA│26│
│Mary  │F│UK │24│
│Monika│F│DE │31│
│Min   │F│CN │17│
│Max   │M│IT │29│
└──────┴─┴───┴──┘

   invert ← {↑¨↓⍉⍵}  
   vert   ← {⍉↑⊂⍤¯1¨⍵}
            
   x  ≡ invert tx
1
   tx ≡ vert x
1
</pre>

<p>A table has array overhead per element. 
An inverted table has array overhead per column. 
The difference that this makes becomes apparent when you have a sufficiently large number of rows.
The other advantage of an inverted table is that column access is much faster.</p>

<p>An important computation is<tt> x index-of y </tt>
where<tt> x </tt>and<tt> y </tt>are compatible inverted tables. 
Obviously, it can not be just<tt> x⍳y</tt>&nbsp;.<tt> </tt> 
The computation obtains by first &ldquo;verting&rdquo; the arguments 
(un-inverting the tables) and then applying<tt> ⍳</tt>&nbsp;,<tt> </tt> 
but often there is not enough space for that.</p>

<pre>
   ⍪¨x                   ⍪¨y
┌──────┬─┬───┬──┐     ┌──────┬─┬───┬──┐
│John  │M│USA│26│     │Min   │F│CN │17│
│Mary  │F│UK │24│     │Mary  │F│UK │24│
│Monika│F│DE │31│     │John  │M│UK │26│
│Min   │F│CN │17│     │Monika│F│DE │31│
│Max   │M│IT │29│     │Mesut │M│DE │24│
└──────┴─┴───┴──┘     │Mesut │M│DE │24│
                      └──────┴─┴───┴──┘
   x ⍳ y
4 4 4 4

   (vert x) ⍳ (vert y)
3 1 5 2 5 5
</pre>

<p>We derive a more efficient computation of <i>index-of</i> on inverted tables:</p>

<table>
<tr><td><tt>(vert x)      ⍳ (vert y)</tt>&nbsp;</td>   <td>(a)</td></tr>
<tr><td><tt>({⍉↑⊂⍤¯1¨⍵}x) ⍳ ({⍉↑⊂⍤¯1¨⍵}y) &nbsp;</tt>&nbsp;</td><td>(b)</td></tr>
<tr><td><tt>(⍉↑⊂⍤¯1¨x)    ⍳ (⍉↑⊂⍤¯1¨y)</tt>&nbsp;</td> <td>(c)</td></tr>
<tr><td><tt>(⍉↑x⍳¨x)      ⍳ (⍉↑x⍳¨y)</tt>&nbsp;</td>   <td>(d)</td></tr>
</table>
<br>

<table>
<tr><td valign=top nowrap>(a) &nbsp;</td> <td>
The indices obtain by first uninverting the tables,
that is, by first applying<tt> vert</tt>&nbsp;.
 </td></tr>
<tr><td valign=top>(b)</td><td>
Replace<tt> vert </tt>by its definition.
 </td></tr>
<tr><td valign=top>(c)</td><td>
Replace the D-fn by its definition.
We see that<tt> ⊂⍤¯1 </tt>plays a major 
role.<tt> ⊂⍤¯1 </tt>encloses, or alternatively
computes a <i>scalar representation</i>.
 </td></tr>
<tr><td valign=top>(d)</td><td>
For purposes of <i>index-of</i><tt> x⍳¨x </tt>and<tt> x⍳¨y </tt>
have the same information as<tt> ⊂⍤¯1¨x </tt>and<tt> ⊂⍤¯1¨y</tt>&nbsp;,<tt> </tt>
but are much more efficient representations (small integers <i>v</i>
the data itself).
 </td></tr>
</table>

<p>Point (d) illustrated on column 0:</p>

<pre>
   ⊂⍤¯1⊢x0←0⊃x
┌──────┬──────┬──────┬──────┬──────┐
│John  │Mary  │Monika│Min   │Max   │
└──────┴──────┴──────┴──────┴──────┘
   x0 ⍳ x0
0 1 2 3 4

   ⊂⍤¯1⊢y0←0⊃y
┌──────┬──────┬──────┬──────┬──────┬──────┐
│Min   │Mary  │John  │Monika│Mesut │Mesut │
└──────┴──────┴──────┴──────┴──────┴──────┘
   x0 ⍳ y0
3 1 0 2 5 5
</pre>

<p>That is, the function<tt> {(⍉↑⍺⍳¨⍺)⍳(⍉↑⍺⍳¨⍵)} </tt>computes <i>index-of</i> on inverted tables.</p>

<p>I believe that in another language a derivation such as the one above would be very long 
(in part because the program would be very long), 
possibly impractically long.
<br>&nbsp;</p> 



<p><b>Summary of Notation</b></p>

<p>The following table lists the APL notation used in the paper.
A complete language reference can be found in 
<acronym title=
"Dyalog Limited, Dyalog APL Programmer’s Guide & Language Reference, Version 13.1, 2012.">[6]</acronym>.
D-fns are described in 
<acronym title=
"Dyalog Limited, Dyalog APL Programmer’s Guide & Language Reference, Version 13.1, 2012.">[6, pp. 112-127]</acronym>
and 
<acronym title=
"Scholes, John, D: A Functional Subset of Dyalog APL, Vector, Volume 17, Number 4, 2001-04.">[7]</acronym>.</p>

<table>
<tr><td><tt>←→</tt> &nbsp;</td>  <td>equivalent (extralingual)</td></tr>
<tr><td><tt>←</tt> &nbsp;</td>   <td>assignment</td></tr> 
<tr><td><tt>⍺</tt> &nbsp;</td>   <td>left &nbsp; argument</td></tr>
<tr><td><tt>⍵</tt> &nbsp;</td>   <td>right argument</td></tr>
<tr><td><tt>×</tt> &nbsp;</td>   <td>times</td></tr>
<tr><td><tt>*</tt> &nbsp;</td>   <td>exponentiation</td></tr>
<tr><td><tt>⍴</tt> &nbsp;</td>   <td>reshape;<tt> n⍴s </tt>makes<tt> n </tt>copies of<tt> s</tt></td></tr> 
<tr><td><tt>⍉</tt> &nbsp;</td>   <td>transpose</td></tr> 
<tr><td><tt>⍳</tt> &nbsp;</td>   <td>index-of</td></tr> 
<tr><td><tt>⊂</tt> &nbsp;</td>   <td>enclose</tt>
<tr><td><tt>⊃</tt> &nbsp;</td>   <td>pick</tt>
<tr><td><tt>↑</tt> &nbsp;</td>   <td>mix (disclose)</td></tr> 
<tr><td><tt>↓</tt> &nbsp;</td>   <td>split (enclose rows)</td></tr> 
<tr><td><tt>⍪</tt> &nbsp;</td>   <td>table, ravel the major cells</td></tr> 
<tr><td><tt>≡</tt> &nbsp;</td>   <td>match</td></tr> 
<tr><td><tt>≢</tt> &nbsp;</td>   <td>tally, the length of the leading dimension</td></tr> 
<tr><td><tt>⊢</tt> &nbsp;</td>   <td>right (identity function)</td></tr>
<tr><td><tt>f∘g</tt> &nbsp;</td> <td>function composition</td></tr>
<tr><td><tt>a∘f</tt> &nbsp;</td> <td>currying (fix left &nbsp; argument)</td></tr>
<tr><td><tt>f∘a</tt> &nbsp;</td> <td>currying (fix right argument)</td></tr>
<tr><td><tt>f⍤r</tt> &nbsp;</td> <td>rank operator;<tt> f </tt>on rank<tt> r </tt>subarrays</td></tr>
<tr><td><tt>f⍣n</tt> &nbsp;</td> <td>power operator;<tt> n </tt>applications of<tt> f</tt>&nbsp;;<tt> </tt>the<tt> n</tt>-th iterate of<tt> f</tt></td></tr>
<tr><td></td>                    <td><tt>f⍣¯1 </tt>is the inverse of<tt> f</tt></td></tr>
<tr><td><tt>f⍢g &nbsp;</tt> &nbsp;</td> <td>dual operator;<tt> g⍣¯1∘f∘g </tt>(not yet implemented in Dyalog APL)</td></tr>
<tr><td><tt>f/</tt> &nbsp;</td>  <td>reduce (fold)</td></tr>
<tr><td><tt>f¨</tt> &nbsp;</td>  <td>each (map)</td></tr>
<tr><td><tt>{⍺ &#133; ⍵}</tt> &nbsp;</td>  <td>D-function</td></tr>
<tr><td><tt>∇</tt> &nbsp;</td>   <td>D-function: recursion</td></tr>
<tr><td><tt>:</tt> &nbsp;</td>   <td>D-function: guard</td></tr>
</table>
<br>



<p><b>References</b></p>

<table>
<tr><td nowrap valign=top>[0] &nbsp;</td><td>
Daylight, Edgar Graham,  
 <a target=_parent href="http://www.dijkstrascry.com/node/90"><i>A Letter about APL</i></a>, 2012-04-05.</a>
 </td></tr>
<tr><td valign=top>[1]</td><td>
Iverson, Kenneth E.,
<a href="http://www.jsoftware.com/papers/APLPersonalView.htm"><i>A Personal View of APL</i></a>,
IBM Systems Journal, Volume 30, Number 4, 1991-12.
  </td></tr>
<tr><td valign=top>[2]</td><td>
Iverson, Kenneth E.,
<a target=_parent href="http://www.jsoftware.com/papers/FPL.htm"><i>Formalism in Programming Languages</i></a>,
Communications of the ACM, Volume 7, Number 2, 1964-02.  See the last question in the discussion.
  </td></tr>
<tr><td valign=top>[3]</td><td>
Iverson, Kenneth E.,
<a target=_parent href="http://www.jsoftware.com/papers/tot.htm"><i>Notation as a Tool of Thought</i></a>,
Communications of the ACM, Volume 23, Number 8, 1980-08.
  </td></tr>
<tr><td valign=top>[4]</td><td>
Hui, Roger K.W.,
<i>Three Combinatoric Puzzles</i>, Vector, Volume 9, Number 2, 1992-10; 
also in 
<a target=_parent href="http://www.jsoftware.com/jwiki/Essays/Ackermann%27s%20Function"><i>Ackermann&rsquo;s Function</i></a>, J Wiki Essay, 
2005-10-14.
  </td></tr>
<tr><td valign=top>[5]</td><td>
Hui, Roger K.W.,
<a target=_parent href="http://www.dyalog.com/uploads/conference/dyalog13/presentations/D08_Rank_and_Friends/friendsscript.htm"><i>Rank
&amp; Friends</i></a>,
2013 Dyalog Conference, 2013-10-22.
  </td></tr>
<tr><td valign=top>[6]</td><td>
Dyalog Limited,
<a target=_parent href="http://docs.dyalog.com/13.1/Dyalog%20APL%20Programmer's%20Guide%20&%20Language%20Reference.pdf"><i>Dyalog
APL Programmer&rsquo;s Guide &amp; Language Reference</i></a>,
Version 13.1, 2012.
  </td></tr>
<tr><td valign=top>[7]</td><td>
 Scholes, John,
<a target=_parent href="http://archive.vector.org.uk/art10007770"><i>D: 
A Functional Subset of Dyalog APL</i></a>, Vector, Volume 17, Number 4, 2001-04.
  </td></tr>
</table>


<br><hr>

<font size=-1>
<p>Written in honor of Ken Iverson&rsquo;s 93<sup>rd</sup> birthday.</p>

<p><script src="https://www.jsoftware.com/papers/apldisplay.js" type="text/javascript"></script></p>
</font>

<table>
<tr><td><font size="-1">created: &nbsp;</font></td><td><font size="-1">2013-12-15 08:30</font></td></tr>
<tr><td><font size="-1">updated:</font></td><td><font size="-1">2018-06-22 13:10</font></td></tr>
</table>

</td></tr></table>
<br><br><br>

</body></html>
